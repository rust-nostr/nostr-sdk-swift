// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(nostr_sdkFFI)
import nostr_sdkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_nostr_sdk_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_nostr_sdk_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}




public protocol AbortHandleProtocol : AnyObject {
    
    /**
     * Abort thread
     */
    func abort() 
    
    /**
     * Check if thread is aborted
     */
    func isAborted()  -> Bool
    
}

open class AbortHandle:
    AbortHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_aborthandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_aborthandle(pointer, $0) }
    }

    

    
    /**
     * Abort thread
     */
open func abort() {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_aborthandle_abort(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Check if thread is aborted
     */
open func isAborted() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_aborthandle_is_aborted(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeAbortHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AbortHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AbortHandle {
        return AbortHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AbortHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AbortHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AbortHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeAbortHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> AbortHandle {
    return try FfiConverterTypeAbortHandle.lift(pointer)
}

public func FfiConverterTypeAbortHandle_lower(_ value: AbortHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAbortHandle.lower(value)
}




public protocol ClientProtocol : AnyObject {
    
    /**
     * Add new relay
     *
     * Return `false` if the relay already exists.
     *
     * This method use perviously set or default `Options` to configure the `Relay` (ex. set proxy, set min POW, set relay limits, ...).
     * To use custom `RelayOptions`, check `add_relay_with_opts` method.
     *
     * Connection is **NOT** automatically started with relay, remember to call `connect` method!
     */
    func addRelay(url: String) throws  -> Bool
    
    /**
     * Add new relay with custom `RelayOptions`
     *
     * Return `false` if the relay already exists.
     *
     * Connection is **NOT** automatically started with relay, remember to call `connect` method!
     */
    func addRelayWithOpts(url: String, opts: RelayOptions) throws  -> Bool
    
    /**
     * Add multiple relays
     *
     * Connection is **NOT** automatically started with relays, remember to call `connect` method!
     */
    func addRelays(relays: [String]) throws 
    
    func connect() 
    
    func connectRelay(url: String) throws 
    
    func database()  -> NostrDatabase
    
    func disconnect() throws 
    
    func disconnectRelay(url: String) throws 
    
    /**
     * Disike event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
    func dislike(event: Event) throws  -> EventId
    
    func fileMetadata(description: String, metadata: FileMetadata) throws  -> EventId
    
    /**
     * Get events of filters from specific relays
     *
     * Get events both from **local database** and **relays**
     */
    func getEventsFrom(urls: [String], filters: [Filter], timeout: TimeInterval?) throws  -> [Event]
    
    func getEventsOf(filters: [Filter], timeout: TimeInterval?) throws  -> [Event]
    
    /**
     * Gift Wrap
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
    func giftWrap(receiver: PublicKey, rumor: EventBuilder, expiration: Timestamp?) throws 
    
    /**
     * Handle notifications
     *
     * **This method spawn a thread**, so ensure to keep up the app after calling this (if needed).
     */
    func handleNotifications(handler: HandleNotification) throws  -> AbortHandle
    
    /**
     * Like event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
    func like(event: Event) throws  -> EventId
    
    /**
     * React to an [`Event`]
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
    func reaction(event: Event, reaction: String) throws  -> EventId
    
    func reconcile(filter: Filter, opts: NegentropyOptions) throws 
    
    func relay(url: String) throws  -> Relay
    
    func relays()  -> [String: Relay]
    
    func removeRelay(url: String) throws 
    
    /**
     * Repost
     */
    func repost(event: Event, relayUrl: String?) throws  -> EventId
    
    func sendDirectMsg(receiver: PublicKey, msg: String, reply: EventId?) throws  -> EventId
    
    func sendEvent(event: Event) throws  -> EventId
    
    /**
     * Take an [`EventBuilder`], sign it by using the [`NostrSigner`] and broadcast to all relays.
     *
     * Rise an error if the [`NostrSigner`] is not set.
     */
    func sendEventBuilder(builder: EventBuilder) throws  -> EventId
    
    /**
     * Take an [`EventBuilder`], sign it by using the [`NostrSigner`] and broadcast to specific relays.
     *
     * Rise an error if the [`NostrSigner`] is not set.
     */
    func sendEventBuilderTo(urls: [String], builder: EventBuilder) throws  -> EventId
    
    func sendEventTo(urls: [String], event: Event) throws  -> EventId
    
    func sendMsg(msg: ClientMessage) throws 
    
    func sendMsgTo(urls: [String], msg: ClientMessage) throws 
    
    /**
     * Send GiftWrapper Sealed Direct message
     */
    func sendSealedMsg(receiver: PublicKey, message: String, expiration: Timestamp?) throws 
    
    func setMetadata(metadata: Metadata) throws  -> EventId
    
    func shutdown() throws 
    
    /**
     * Signs the `EventBuilder` into an `Event` using the `NostrSigner`
     */
    func signEventBuilder(builder: EventBuilder) throws  -> Event
    
    func signer() throws  -> NostrSigner
    
    func start() 
    
    func stop() throws 
    
    /**
     * Subscribe to filters
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
    func subscribe(filters: [Filter], opts: SubscribeAutoCloseOptions?)  -> String
    
    /**
     * Subscribe to filters with custom subscription ID
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
    func subscribeWithId(id: String, filters: [Filter], opts: SubscribeAutoCloseOptions?) 
    
    func subscription(id: String)  -> [Filter]?
    
    func subscriptions()  -> [String: [Filter]]
    
    func unsubscribe(subscriptionId: String) 
    
    func unsubscribeAll() 
    
    func updateDifficulty(difficulty: UInt8) 
    
    /**
     * Send a Zap!
     *
     * This method automatically create a split zap to support Rust Nostr development.
     */
    func zap(to: ZapEntity, satoshi: UInt64, details: ZapDetails?) throws 
    
}

open class Client:
    ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_client(self.pointer, $0) }
    }
public convenience init(signer: NostrSigner?) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_client_new(
        FfiConverterOptionTypeNostrSigner.lower(signer),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_client(pointer, $0) }
    }

    
public static func withOpts(signer: NostrSigner?, opts: Options) -> Client {
    return try!  FfiConverterTypeClient.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_client_with_opts(
        FfiConverterOptionTypeNostrSigner.lower(signer),
        FfiConverterTypeOptions.lower(opts),$0
    )
})
}
    

    
    /**
     * Add new relay
     *
     * Return `false` if the relay already exists.
     *
     * This method use perviously set or default `Options` to configure the `Relay` (ex. set proxy, set min POW, set relay limits, ...).
     * To use custom `RelayOptions`, check `add_relay_with_opts` method.
     *
     * Connection is **NOT** automatically started with relay, remember to call `connect` method!
     */
open func addRelay(url: String)throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_add_relay(self.uniffiClonePointer(),
        FfiConverterString.lower(url),$0
    )
})
}
    
    /**
     * Add new relay with custom `RelayOptions`
     *
     * Return `false` if the relay already exists.
     *
     * Connection is **NOT** automatically started with relay, remember to call `connect` method!
     */
open func addRelayWithOpts(url: String, opts: RelayOptions)throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_add_relay_with_opts(self.uniffiClonePointer(),
        FfiConverterString.lower(url),
        FfiConverterTypeRelayOptions.lower(opts),$0
    )
})
}
    
    /**
     * Add multiple relays
     *
     * Connection is **NOT** automatically started with relays, remember to call `connect` method!
     */
open func addRelays(relays: [String])throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_add_relays(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(relays),$0
    )
}
}
    
open func connect() {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_connect(self.uniffiClonePointer(),$0
    )
}
}
    
open func connectRelay(url: String)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_connect_relay(self.uniffiClonePointer(),
        FfiConverterString.lower(url),$0
    )
}
}
    
open func database() -> NostrDatabase {
    return try!  FfiConverterTypeNostrDatabase.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_database(self.uniffiClonePointer(),$0
    )
})
}
    
open func disconnect()throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_disconnect(self.uniffiClonePointer(),$0
    )
}
}
    
open func disconnectRelay(url: String)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_disconnect_relay(self.uniffiClonePointer(),
        FfiConverterString.lower(url),$0
    )
}
}
    
    /**
     * Disike event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
open func dislike(event: Event)throws  -> EventId {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_dislike(self.uniffiClonePointer(),
        FfiConverterTypeEvent_lower(event),$0
    )
})
}
    
open func fileMetadata(description: String, metadata: FileMetadata)throws  -> EventId {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_file_metadata(self.uniffiClonePointer(),
        FfiConverterString.lower(description),
        FfiConverterTypeFileMetadata_lower(metadata),$0
    )
})
}
    
    /**
     * Get events of filters from specific relays
     *
     * Get events both from **local database** and **relays**
     */
open func getEventsFrom(urls: [String], filters: [Filter], timeout: TimeInterval?)throws  -> [Event] {
    return try  FfiConverterSequenceTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_get_events_from(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(urls),
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    
open func getEventsOf(filters: [Filter], timeout: TimeInterval?)throws  -> [Event] {
    return try  FfiConverterSequenceTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_get_events_of(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    
    /**
     * Gift Wrap
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
open func giftWrap(receiver: PublicKey, rumor: EventBuilder, expiration: Timestamp?)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_gift_wrap(self.uniffiClonePointer(),
        FfiConverterTypePublicKey_lower(receiver),
        FfiConverterTypeEventBuilder_lower(rumor),
        FfiConverterOptionTypeTimestamp.lower(expiration),$0
    )
}
}
    
    /**
     * Handle notifications
     *
     * **This method spawn a thread**, so ensure to keep up the app after calling this (if needed).
     */
open func handleNotifications(handler: HandleNotification)throws  -> AbortHandle {
    return try  FfiConverterTypeAbortHandle.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_handle_notifications(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceHandleNotification.lower(handler),$0
    )
})
}
    
    /**
     * Like event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
open func like(event: Event)throws  -> EventId {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_like(self.uniffiClonePointer(),
        FfiConverterTypeEvent_lower(event),$0
    )
})
}
    
    /**
     * React to an [`Event`]
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
open func reaction(event: Event, reaction: String)throws  -> EventId {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_reaction(self.uniffiClonePointer(),
        FfiConverterTypeEvent_lower(event),
        FfiConverterString.lower(reaction),$0
    )
})
}
    
open func reconcile(filter: Filter, opts: NegentropyOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_reconcile(self.uniffiClonePointer(),
        FfiConverterTypeFilter_lower(filter),
        FfiConverterTypeNegentropyOptions.lower(opts),$0
    )
}
}
    
open func relay(url: String)throws  -> Relay {
    return try  FfiConverterTypeRelay.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_relay(self.uniffiClonePointer(),
        FfiConverterString.lower(url),$0
    )
})
}
    
open func relays() -> [String: Relay] {
    return try!  FfiConverterDictionaryStringTypeRelay.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_relays(self.uniffiClonePointer(),$0
    )
})
}
    
open func removeRelay(url: String)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_remove_relay(self.uniffiClonePointer(),
        FfiConverterString.lower(url),$0
    )
}
}
    
    /**
     * Repost
     */
open func repost(event: Event, relayUrl: String?)throws  -> EventId {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_repost(self.uniffiClonePointer(),
        FfiConverterTypeEvent_lower(event),
        FfiConverterOptionString.lower(relayUrl),$0
    )
})
}
    
open func sendDirectMsg(receiver: PublicKey, msg: String, reply: EventId?)throws  -> EventId {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_send_direct_msg(self.uniffiClonePointer(),
        FfiConverterTypePublicKey_lower(receiver),
        FfiConverterString.lower(msg),
        FfiConverterOptionTypeEventId.lower(reply),$0
    )
})
}
    
open func sendEvent(event: Event)throws  -> EventId {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_send_event(self.uniffiClonePointer(),
        FfiConverterTypeEvent_lower(event),$0
    )
})
}
    
    /**
     * Take an [`EventBuilder`], sign it by using the [`NostrSigner`] and broadcast to all relays.
     *
     * Rise an error if the [`NostrSigner`] is not set.
     */
open func sendEventBuilder(builder: EventBuilder)throws  -> EventId {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder(self.uniffiClonePointer(),
        FfiConverterTypeEventBuilder_lower(builder),$0
    )
})
}
    
    /**
     * Take an [`EventBuilder`], sign it by using the [`NostrSigner`] and broadcast to specific relays.
     *
     * Rise an error if the [`NostrSigner`] is not set.
     */
open func sendEventBuilderTo(urls: [String], builder: EventBuilder)throws  -> EventId {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder_to(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(urls),
        FfiConverterTypeEventBuilder_lower(builder),$0
    )
})
}
    
open func sendEventTo(urls: [String], event: Event)throws  -> EventId {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_send_event_to(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(urls),
        FfiConverterTypeEvent_lower(event),$0
    )
})
}
    
open func sendMsg(msg: ClientMessage)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_send_msg(self.uniffiClonePointer(),
        FfiConverterTypeClientMessage_lower(msg),$0
    )
}
}
    
open func sendMsgTo(urls: [String], msg: ClientMessage)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_send_msg_to(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(urls),
        FfiConverterTypeClientMessage_lower(msg),$0
    )
}
}
    
    /**
     * Send GiftWrapper Sealed Direct message
     */
open func sendSealedMsg(receiver: PublicKey, message: String, expiration: Timestamp?)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_send_sealed_msg(self.uniffiClonePointer(),
        FfiConverterTypePublicKey_lower(receiver),
        FfiConverterString.lower(message),
        FfiConverterOptionTypeTimestamp.lower(expiration),$0
    )
}
}
    
open func setMetadata(metadata: Metadata)throws  -> EventId {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_set_metadata(self.uniffiClonePointer(),
        FfiConverterTypeMetadata_lower(metadata),$0
    )
})
}
    
open func shutdown()throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_shutdown(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Signs the `EventBuilder` into an `Event` using the `NostrSigner`
     */
open func signEventBuilder(builder: EventBuilder)throws  -> Event {
    return try  FfiConverterTypeEvent_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_sign_event_builder(self.uniffiClonePointer(),
        FfiConverterTypeEventBuilder_lower(builder),$0
    )
})
}
    
open func signer()throws  -> NostrSigner {
    return try  FfiConverterTypeNostrSigner.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_signer(self.uniffiClonePointer(),$0
    )
})
}
    
open func start() {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_start(self.uniffiClonePointer(),$0
    )
}
}
    
open func stop()throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_stop(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Subscribe to filters
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
open func subscribe(filters: [Filter], opts: SubscribeAutoCloseOptions?) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_subscribe(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts),$0
    )
})
}
    
    /**
     * Subscribe to filters with custom subscription ID
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
open func subscribeWithId(id: String, filters: [Filter], opts: SubscribeAutoCloseOptions?) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_subscribe_with_id(self.uniffiClonePointer(),
        FfiConverterString.lower(id),
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts),$0
    )
}
}
    
open func subscription(id: String) -> [Filter]? {
    return try!  FfiConverterOptionSequenceTypeFilter.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_subscription(self.uniffiClonePointer(),
        FfiConverterString.lower(id),$0
    )
})
}
    
open func subscriptions() -> [String: [Filter]] {
    return try!  FfiConverterDictionaryStringSequenceTypeFilter.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_subscriptions(self.uniffiClonePointer(),$0
    )
})
}
    
open func unsubscribe(subscriptionId: String) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe(self.uniffiClonePointer(),
        FfiConverterString.lower(subscriptionId),$0
    )
}
}
    
open func unsubscribeAll() {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe_all(self.uniffiClonePointer(),$0
    )
}
}
    
open func updateDifficulty(difficulty: UInt8) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_update_difficulty(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
}
}
    
    /**
     * Send a Zap!
     *
     * This method automatically create a split zap to support Rust Nostr development.
     */
open func zap(to: ZapEntity, satoshi: UInt64, details: ZapDetails?)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_zap(self.uniffiClonePointer(),
        FfiConverterTypeZapEntity.lower(to),
        FfiConverterUInt64.lower(satoshi),
        FfiConverterOptionTypeZapDetails.lower(details),$0
    )
}
}
    

}

public struct FfiConverterTypeClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}




public protocol ClientBuilderProtocol : AnyObject {
    
    /**
     * Build [`Client`]
     */
    func build()  -> Client
    
    func database(database: NostrDatabase)  -> ClientBuilder
    
    /**
     * Set opts
     */
    func opts(opts: Options)  -> ClientBuilder
    
    func signer(signer: NostrSigner)  -> ClientBuilder
    
    func zapper(zapper: NostrZapper)  -> ClientBuilder
    
}

open class ClientBuilder:
    ClientBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_clientbuilder(self.pointer, $0) }
    }
    /**
     * New client builder
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_clientbuilder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_clientbuilder(pointer, $0) }
    }

    

    
    /**
     * Build [`Client`]
     */
open func build() -> Client {
    return try!  FfiConverterTypeClient.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_build(self.uniffiClonePointer(),$0
    )
})
}
    
open func database(database: NostrDatabase) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_database(self.uniffiClonePointer(),
        FfiConverterTypeNostrDatabase.lower(database),$0
    )
})
}
    
    /**
     * Set opts
     */
open func opts(opts: Options) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_opts(self.uniffiClonePointer(),
        FfiConverterTypeOptions.lower(opts),$0
    )
})
}
    
open func signer(signer: NostrSigner) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_signer(self.uniffiClonePointer(),
        FfiConverterTypeNostrSigner.lower(signer),$0
    )
})
}
    
open func zapper(zapper: NostrZapper) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_zapper(self.uniffiClonePointer(),
        FfiConverterTypeNostrZapper.lower(zapper),$0
    )
})
}
    

}

public struct FfiConverterTypeClientBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
        return ClientBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
    return try FfiConverterTypeClientBuilder.lift(pointer)
}

public func FfiConverterTypeClientBuilder_lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientBuilder.lower(value)
}




/**
 * Nostr Wallet Connect client
 */
public protocol NwcProtocol : AnyObject {
    
    /**
     * Get balance
     */
    func getBalance() throws  -> UInt64
    
    /**
     * Get info
     */
    func getInfo() throws  -> GetInfoResponseResult
    
    /**
     * List transactions
     */
    func listTransactions(params: ListTransactionsRequestParams) throws  -> [LookupInvoiceResponseResult]
    
    /**
     * Lookup invoice
     */
    func lookupInvoice(params: LookupInvoiceRequestParams) throws  -> LookupInvoiceResponseResult
    
    /**
     * Create invoice
     */
    func makeInvoice(params: MakeInvoiceRequestParams) throws  -> MakeInvoiceResponseResult
    
    /**
     * Pay invoice
     */
    func payInvoice(invoice: String) throws  -> String
    
    /**
     * Pay keysend
     */
    func payKeysend(params: PayKeysendRequestParams) throws  -> PayKeysendResponseResult
    
}

/**
 * Nostr Wallet Connect client
 */
open class Nwc:
    NwcProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nwc(self.pointer, $0) }
    }
    /**
     * Compose new `NWC` client
     */
public convenience init(uri: NostrWalletConnectUri)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nwc_new(
        FfiConverterTypeNostrWalletConnectURI_lower(uri),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nwc(pointer, $0) }
    }

    
    /**
     * Compose new `NWC` client with `NostrWalletConnectOptions`
     */
public static func withOpts(uri: NostrWalletConnectUri, opts: NostrWalletConnectOptions)throws  -> Nwc {
    return try  FfiConverterTypeNWC.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nwc_with_opts(
        FfiConverterTypeNostrWalletConnectURI_lower(uri),
        FfiConverterTypeNostrWalletConnectOptions.lower(opts),$0
    )
})
}
    

    
    /**
     * Get balance
     */
open func getBalance()throws  -> UInt64 {
    return try  FfiConverterUInt64.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nwc_get_balance(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get info
     */
open func getInfo()throws  -> GetInfoResponseResult {
    return try  FfiConverterTypeGetInfoResponseResult_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nwc_get_info(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * List transactions
     */
open func listTransactions(params: ListTransactionsRequestParams)throws  -> [LookupInvoiceResponseResult] {
    return try  FfiConverterSequenceTypeLookupInvoiceResponseResult.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nwc_list_transactions(self.uniffiClonePointer(),
        FfiConverterTypeListTransactionsRequestParams_lower(params),$0
    )
})
}
    
    /**
     * Lookup invoice
     */
open func lookupInvoice(params: LookupInvoiceRequestParams)throws  -> LookupInvoiceResponseResult {
    return try  FfiConverterTypeLookupInvoiceResponseResult_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nwc_lookup_invoice(self.uniffiClonePointer(),
        FfiConverterTypeLookupInvoiceRequestParams_lower(params),$0
    )
})
}
    
    /**
     * Create invoice
     */
open func makeInvoice(params: MakeInvoiceRequestParams)throws  -> MakeInvoiceResponseResult {
    return try  FfiConverterTypeMakeInvoiceResponseResult_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nwc_make_invoice(self.uniffiClonePointer(),
        FfiConverterTypeMakeInvoiceRequestParams_lower(params),$0
    )
})
}
    
    /**
     * Pay invoice
     */
open func payInvoice(invoice: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nwc_pay_invoice(self.uniffiClonePointer(),
        FfiConverterString.lower(invoice),$0
    )
})
}
    
    /**
     * Pay keysend
     */
open func payKeysend(params: PayKeysendRequestParams)throws  -> PayKeysendResponseResult {
    return try  FfiConverterTypePayKeysendResponseResult_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nwc_pay_keysend(self.uniffiClonePointer(),
        FfiConverterTypePayKeysendRequestParams_lower(params),$0
    )
})
}
    

}

public struct FfiConverterTypeNWC: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nwc

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nwc {
        return Nwc(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nwc) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nwc {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nwc, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNWC_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nwc {
    return try FfiConverterTypeNWC.lift(pointer)
}

public func FfiConverterTypeNWC_lower(_ value: Nwc) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNWC.lower(value)
}




public protocol NegentropyOptionsProtocol : AnyObject {
    
    /**
     * Negentropy Sync direction (default: down)
     */
    func direction(direction: NegentropyDirection)  -> NegentropyOptions
    
    /**
     * Timeout to check if negentropy it's supported (default: 10 secs)
     */
    func initialTimeout(timeout: TimeInterval)  -> NegentropyOptions
    
}

open class NegentropyOptions:
    NegentropyOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_negentropyoptions(self.pointer, $0) }
    }
    /**
     * New default options
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_negentropyoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_negentropyoptions(pointer, $0) }
    }

    

    
    /**
     * Negentropy Sync direction (default: down)
     */
open func direction(direction: NegentropyDirection) -> NegentropyOptions {
    return try!  FfiConverterTypeNegentropyOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_negentropyoptions_direction(self.uniffiClonePointer(),
        FfiConverterTypeNegentropyDirection.lower(direction),$0
    )
})
}
    
    /**
     * Timeout to check if negentropy it's supported (default: 10 secs)
     */
open func initialTimeout(timeout: TimeInterval) -> NegentropyOptions {
    return try!  FfiConverterTypeNegentropyOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_negentropyoptions_initial_timeout(self.uniffiClonePointer(),
        FfiConverterDuration.lower(timeout),$0
    )
})
}
    

}

public struct FfiConverterTypeNegentropyOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NegentropyOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NegentropyOptions {
        return NegentropyOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NegentropyOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NegentropyOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NegentropyOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNegentropyOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> NegentropyOptions {
    return try FfiConverterTypeNegentropyOptions.lift(pointer)
}

public func FfiConverterTypeNegentropyOptions_lower(_ value: NegentropyOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNegentropyOptions.lower(value)
}




public protocol Nip46SignerProtocol : AnyObject {
    
    /**
     * Get Nostr Connect URI in **bunker** format.
     */
    func nostrConnectUri()  -> NostrConnectUri
    
    /**
     * Get signer relays
     */
    func relays()  -> [String]
    
    /**
     * Get signer public key
     */
    func signerPublicKey()  -> PublicKey
    
}

open class Nip46Signer:
    Nip46SignerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nip46signer(self.pointer, $0) }
    }
    /**
     * New NIP46 remote signer
     */
public convenience init(uri: NostrConnectUri, appKeys: Keys, timeout: TimeInterval, opts: RelayOptions?)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nip46signer_new(
        FfiConverterTypeNostrConnectURI_lower(uri),
        FfiConverterTypeKeys_lower(appKeys),
        FfiConverterDuration.lower(timeout),
        FfiConverterOptionTypeRelayOptions.lower(opts),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nip46signer(pointer, $0) }
    }

    

    
    /**
     * Get Nostr Connect URI in **bunker** format.
     */
open func nostrConnectUri() -> NostrConnectUri {
    return try!  FfiConverterTypeNostrConnectURI_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip46signer_nostr_connect_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get signer relays
     */
open func relays() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip46signer_relays(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get signer public key
     */
open func signerPublicKey() -> PublicKey {
    return try!  FfiConverterTypePublicKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip46signer_signer_public_key(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeNip46Signer: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip46Signer

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip46Signer {
        return Nip46Signer(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip46Signer) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip46Signer {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip46Signer, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNip46Signer_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip46Signer {
    return try FfiConverterTypeNip46Signer.lift(pointer)
}

public func FfiConverterTypeNip46Signer_lower(_ value: Nip46Signer) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip46Signer.lower(value)
}




public protocol NostrDatabaseProtocol : AnyObject {
    
    func count(filters: [Filter]) throws  -> UInt64
    
    /**
     * Delete all events that match the `Filter`
     */
    func delete(filter: Filter) throws 
    
    /**
     * Get [`Event`] by [`EventId`]
     */
    func eventById(eventId: EventId) throws  -> Event
    
    /**
     * Get list of relays that have seen the [`EventId`]
     */
    func eventSeenOnRelays(eventId: EventId) throws  -> [String]?
    
    func profile(publicKey: PublicKey) throws  -> Profile
    
    func query(filters: [Filter]) throws  -> [Event]
    
    /**
     * Save [`Event`] into store
     *
     * Return `true` if event was successfully saved into database.
     */
    func saveEvent(event: Event) throws  -> Bool
    
    /**
     * Wipe all data
     */
    func wipe() throws 
    
}

open class NostrDatabase:
    NostrDatabaseProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrdatabase(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrdatabase(pointer, $0) }
    }

    
public static func custom(database: CustomNostrDatabase) -> NostrDatabase {
    return try!  FfiConverterTypeNostrDatabase.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_custom(
        FfiConverterCallbackInterfaceCustomNostrDatabase.lower(database),$0
    )
})
}
    
    /**
     * [`nostrdb`](https://github.com/damus-io/nostrdb) backend
     */
public static func ndb(path: String)throws  -> NostrDatabase {
    return try  FfiConverterTypeNostrDatabase.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_ndb(
        FfiConverterString.lower(path),$0
    )
})
}
    
public static func sqlite(path: String)throws  -> NostrDatabase {
    return try  FfiConverterTypeNostrDatabase.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_sqlite(
        FfiConverterString.lower(path),$0
    )
})
}
    

    
open func count(filters: [Filter])throws  -> UInt64 {
    return try  FfiConverterUInt64.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_count(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFilter.lower(filters),$0
    )
})
}
    
    /**
     * Delete all events that match the `Filter`
     */
open func delete(filter: Filter)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_delete(self.uniffiClonePointer(),
        FfiConverterTypeFilter_lower(filter),$0
    )
}
}
    
    /**
     * Get [`Event`] by [`EventId`]
     */
open func eventById(eventId: EventId)throws  -> Event {
    return try  FfiConverterTypeEvent_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_event_by_id(self.uniffiClonePointer(),
        FfiConverterTypeEventId_lower(eventId),$0
    )
})
}
    
    /**
     * Get list of relays that have seen the [`EventId`]
     */
open func eventSeenOnRelays(eventId: EventId)throws  -> [String]? {
    return try  FfiConverterOptionSequenceString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_event_seen_on_relays(self.uniffiClonePointer(),
        FfiConverterTypeEventId_lower(eventId),$0
    )
})
}
    
open func profile(publicKey: PublicKey)throws  -> Profile {
    return try  FfiConverterTypeProfile.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_profile(self.uniffiClonePointer(),
        FfiConverterTypePublicKey_lower(publicKey),$0
    )
})
}
    
open func query(filters: [Filter])throws  -> [Event] {
    return try  FfiConverterSequenceTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_query(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFilter.lower(filters),$0
    )
})
}
    
    /**
     * Save [`Event`] into store
     *
     * Return `true` if event was successfully saved into database.
     */
open func saveEvent(event: Event)throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_save_event(self.uniffiClonePointer(),
        FfiConverterTypeEvent_lower(event),$0
    )
})
}
    
    /**
     * Wipe all data
     */
open func wipe()throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_wipe(self.uniffiClonePointer(),$0
    )
}
}
    

}

public struct FfiConverterTypeNostrDatabase: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrDatabase

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrDatabase {
        return NostrDatabase(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrDatabase) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrDatabase {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrDatabase, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrDatabase_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrDatabase {
    return try FfiConverterTypeNostrDatabase.lift(pointer)
}

public func FfiConverterTypeNostrDatabase_lower(_ value: NostrDatabase) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrDatabase.lower(value)
}




public protocol NostrSignerProtocol : AnyObject {
    
    func nip04Decrypt(publicKey: PublicKey, encryptedContent: String) throws  -> String
    
    func nip04Encrypt(publicKey: PublicKey, content: String) throws  -> String
    
    func nip44Decrypt(publicKey: PublicKey, content: String) throws  -> String
    
    func nip44Encrypt(publicKey: PublicKey, content: String) throws  -> String
    
    /**
     * Get signer public key
     */
    func publicKey() throws  -> PublicKey
    
    func signEvent(unsignedEvent: UnsignedEvent) throws  -> Event
    
    func signEventBuilder(builder: EventBuilder) throws  -> Event
    
}

open class NostrSigner:
    NostrSignerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrsigner(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrsigner(pointer, $0) }
    }

    
public static func keys(keys: Keys) -> NostrSigner {
    return try!  FfiConverterTypeNostrSigner.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_keys(
        FfiConverterTypeKeys_lower(keys),$0
    )
})
}
    
public static func nip46(nip46: Nip46Signer) -> NostrSigner {
    return try!  FfiConverterTypeNostrSigner.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_nip46(
        FfiConverterTypeNip46Signer.lower(nip46),$0
    )
})
}
    

    
open func nip04Decrypt(publicKey: PublicKey, encryptedContent: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_decrypt(self.uniffiClonePointer(),
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterString.lower(encryptedContent),$0
    )
})
}
    
open func nip04Encrypt(publicKey: PublicKey, content: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_encrypt(self.uniffiClonePointer(),
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterString.lower(content),$0
    )
})
}
    
open func nip44Decrypt(publicKey: PublicKey, content: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_decrypt(self.uniffiClonePointer(),
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterString.lower(content),$0
    )
})
}
    
open func nip44Encrypt(publicKey: PublicKey, content: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_encrypt(self.uniffiClonePointer(),
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterString.lower(content),$0
    )
})
}
    
    /**
     * Get signer public key
     */
open func publicKey()throws  -> PublicKey {
    return try  FfiConverterTypePublicKey_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrsigner_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
open func signEvent(unsignedEvent: UnsignedEvent)throws  -> Event {
    return try  FfiConverterTypeEvent_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrsigner_sign_event(self.uniffiClonePointer(),
        FfiConverterTypeUnsignedEvent_lower(unsignedEvent),$0
    )
})
}
    
open func signEventBuilder(builder: EventBuilder)throws  -> Event {
    return try  FfiConverterTypeEvent_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrsigner_sign_event_builder(self.uniffiClonePointer(),
        FfiConverterTypeEventBuilder_lower(builder),$0
    )
})
}
    

}

public struct FfiConverterTypeNostrSigner: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrSigner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrSigner {
        return NostrSigner(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrSigner) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrSigner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrSigner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrSigner_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrSigner {
    return try FfiConverterTypeNostrSigner.lift(pointer)
}

public func FfiConverterTypeNostrSigner_lower(_ value: NostrSigner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrSigner.lower(value)
}




/**
 * NWC options
 */
public protocol NostrWalletConnectOptionsProtocol : AnyObject {
    
    /**
     * Set proxy
     */
    func proxy(proxy: String?) throws  -> NostrWalletConnectOptions
    
    /**
     * Set NWC requests timeout (default: 10 secs)
     */
    func timeout(timeout: TimeInterval)  -> NostrWalletConnectOptions
    
}

/**
 * NWC options
 */
open class NostrWalletConnectOptions:
    NostrWalletConnectOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrwalletconnectoptions(self.pointer, $0) }
    }
    /**
     * New default NWC options
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnectoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrwalletconnectoptions(pointer, $0) }
    }

    

    
    /**
     * Set proxy
     */
open func proxy(proxy: String?)throws  -> NostrWalletConnectOptions {
    return try  FfiConverterTypeNostrWalletConnectOptions.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_proxy(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(proxy),$0
    )
})
}
    
    /**
     * Set NWC requests timeout (default: 10 secs)
     */
open func timeout(timeout: TimeInterval) -> NostrWalletConnectOptions {
    return try!  FfiConverterTypeNostrWalletConnectOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_timeout(self.uniffiClonePointer(),
        FfiConverterDuration.lower(timeout),$0
    )
})
}
    

}

public struct FfiConverterTypeNostrWalletConnectOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrWalletConnectOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrWalletConnectOptions {
        return NostrWalletConnectOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrWalletConnectOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrWalletConnectOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrWalletConnectOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrWalletConnectOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrWalletConnectOptions {
    return try FfiConverterTypeNostrWalletConnectOptions.lift(pointer)
}

public func FfiConverterTypeNostrWalletConnectOptions_lower(_ value: NostrWalletConnectOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrWalletConnectOptions.lower(value)
}




/**
 * Nostr Zapper
 */
public protocol NostrZapperProtocol : AnyObject {
    
}

/**
 * Nostr Zapper
 */
open class NostrZapper:
    NostrZapperProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrzapper(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrzapper(pointer, $0) }
    }

    
public static func nwc(uri: NostrWalletConnectUri)throws  -> NostrZapper {
    return try  FfiConverterTypeNostrZapper.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrzapper_nwc(
        FfiConverterTypeNostrWalletConnectURI_lower(uri),$0
    )
})
}
    

    

}

public struct FfiConverterTypeNostrZapper: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrZapper

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrZapper {
        return NostrZapper(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrZapper) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrZapper {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrZapper, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrZapper_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrZapper {
    return try FfiConverterTypeNostrZapper.lift(pointer)
}

public func FfiConverterTypeNostrZapper_lower(_ value: NostrZapper) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrZapper.lower(value)
}




public protocol OptionsProtocol : AnyObject {
    
    /**
     * Connection timeout (default: None)
     *
     * If set to `None`, the client will try to connect to the relays without waiting.
     */
    func connectionTimeout(timeout: TimeInterval?)  -> Options
    
    func difficulty(difficulty: UInt8)  -> Options
    
    /**
     * Minimum POW difficulty for received events
     */
    func minPow(difficulty: UInt8)  -> Options
    
    /**
     * Proxy
     */
    func proxy(proxy: Proxy)  -> Options
    
    /**
     * Set custom relay limits
     */
    func relayLimits(limits: RelayLimits)  -> Options
    
    func reqFiltersChunkSize(reqFiltersChunkSize: UInt8)  -> Options
    
    func sendTimeout(sendTimeout: TimeInterval?)  -> Options
    
    func skipDisconnectedRelays(skip: Bool)  -> Options
    
    func timeout(timeout: TimeInterval)  -> Options
    
    func waitForSend(wait: Bool)  -> Options
    
    func waitForSubscription(wait: Bool)  -> Options
    
}

open class Options:
    OptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_options(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_options_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_options(pointer, $0) }
    }

    

    
    /**
     * Connection timeout (default: None)
     *
     * If set to `None`, the client will try to connect to the relays without waiting.
     */
open func connectionTimeout(timeout: TimeInterval?) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_connection_timeout(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    
open func difficulty(difficulty: UInt8) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_difficulty(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
})
}
    
    /**
     * Minimum POW difficulty for received events
     */
open func minPow(difficulty: UInt8) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_min_pow(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
})
}
    
    /**
     * Proxy
     */
open func proxy(proxy: Proxy) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_proxy(self.uniffiClonePointer(),
        FfiConverterTypeProxy.lower(proxy),$0
    )
})
}
    
    /**
     * Set custom relay limits
     */
open func relayLimits(limits: RelayLimits) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_relay_limits(self.uniffiClonePointer(),
        FfiConverterTypeRelayLimits.lower(limits),$0
    )
})
}
    
open func reqFiltersChunkSize(reqFiltersChunkSize: UInt8) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_req_filters_chunk_size(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(reqFiltersChunkSize),$0
    )
})
}
    
open func sendTimeout(sendTimeout: TimeInterval?) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_send_timeout(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(sendTimeout),$0
    )
})
}
    
open func skipDisconnectedRelays(skip: Bool) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_skip_disconnected_relays(self.uniffiClonePointer(),
        FfiConverterBool.lower(skip),$0
    )
})
}
    
open func timeout(timeout: TimeInterval) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_timeout(self.uniffiClonePointer(),
        FfiConverterDuration.lower(timeout),$0
    )
})
}
    
open func waitForSend(wait: Bool) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_wait_for_send(self.uniffiClonePointer(),
        FfiConverterBool.lower(wait),$0
    )
})
}
    
open func waitForSubscription(wait: Bool) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_wait_for_subscription(self.uniffiClonePointer(),
        FfiConverterBool.lower(wait),$0
    )
})
}
    

}

public struct FfiConverterTypeOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Options

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Options {
        return Options(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Options) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Options {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Options, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> Options {
    return try FfiConverterTypeOptions.lift(pointer)
}

public func FfiConverterTypeOptions_lower(_ value: Options) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOptions.lower(value)
}




public protocol ProfileProtocol : AnyObject {
    
    /**
     * Get profile metadata
     */
    func metadata()  -> Metadata
    
    /**
     * Get profile name
     *
     * Steps (go to next step if field is `None` or `empty`):
     * * Check `display_name` field
     * * Check `name` field
     * * Return cutted public key (ex. `00000000:00000002`)
     */
    func name()  -> String
    
    /**
     * Get profile public key
     */
    func publicKey()  -> PublicKey
    
}

open class Profile:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    ProfileProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_profile(self.pointer, $0) }
    }
    /**
     * Compose new profile
     */
public convenience init(publicKey: PublicKey, metadata: Metadata) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_profile_new(
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterTypeMetadata_lower(metadata),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_profile(pointer, $0) }
    }

    

    
    /**
     * Get profile metadata
     */
open func metadata() -> Metadata {
    return try!  FfiConverterTypeMetadata_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_metadata(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get profile name
     *
     * Steps (go to next step if field is `None` or `empty`):
     * * Check `display_name` field
     * * Check `name` field
     * * Return cutted public key (ex. `00000000:00000002`)
     */
open func name() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_name(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get profile public key
     */
open func publicKey() -> PublicKey {
    return try!  FfiConverterTypePublicKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Profile, other: Profile) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeProfile.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeProfile: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Profile

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Profile {
        return Profile(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Profile) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Profile {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Profile, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeProfile_lift(_ pointer: UnsafeMutableRawPointer) throws -> Profile {
    return try FfiConverterTypeProfile.lift(pointer)
}

public func FfiConverterTypeProfile_lower(_ value: Profile) -> UnsafeMutableRawPointer {
    return FfiConverterTypeProfile.lower(value)
}




/**
 * Proxy
 */
public protocol ProxyProtocol : AnyObject {
    
    /**
     * Set proxy target (default: all)
     */
    func target(target: ProxyTarget)  -> Proxy
    
}

/**
 * Proxy
 */
open class Proxy:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    ProxyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_proxy(self.pointer, $0) }
    }
    /**
     * Compose proxy (ex. `127.0.0.1:9050`)
     */
public convenience init(addr: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_proxy_new(
        FfiConverterString.lower(addr),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_proxy(pointer, $0) }
    }

    

    
    /**
     * Set proxy target (default: all)
     */
open func target(target: ProxyTarget) -> Proxy {
    return try!  FfiConverterTypeProxy.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_proxy_target(self.uniffiClonePointer(),
        FfiConverterTypeProxyTarget.lower(target),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_proxy_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Proxy, other: Proxy) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_proxy_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeProxy.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_proxy_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeProxy: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Proxy

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Proxy {
        return Proxy(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Proxy) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Proxy {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Proxy, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeProxy_lift(_ pointer: UnsafeMutableRawPointer) throws -> Proxy {
    return try FfiConverterTypeProxy.lift(pointer)
}

public func FfiConverterTypeProxy_lower(_ value: Proxy) -> UnsafeMutableRawPointer {
    return FfiConverterTypeProxy.lower(value)
}




public protocol RelayProtocol : AnyObject {
    
    /**
     * Send multiple `Event` at once
     */
    func batchEvent(events: [Event], opts: RelaySendOptions) throws 
    
    /**
     * Send multiple `ClientMessage` at once
     */
    func batchMsg(msgs: [ClientMessage], opts: RelaySendOptions) throws 
    
    /**
     * Connect to relay and keep alive connection
     */
    func connect(connectionTimeout: TimeInterval?) 
    
    /**
     * Count events of filters
     */
    func countEventsOf(filters: [Filter], timeout: TimeInterval) throws  -> UInt64
    
    func document()  -> RelayInformationDocument
    
    /**
     * Get events of filters
     *
     * Get events from local database and relay
     */
    func getEventsOf(filters: [Filter], timeout: TimeInterval) throws  -> [Event]
    
    /**
     * Check if `Relay` is connected
     */
    func isConnected()  -> Bool
    
    func opts()  -> RelayOptions
    
    /**
     * Get proxy
     */
    func proxy()  -> String?
    
    func queue()  -> UInt64
    
    /**
     * Negentropy reconciliation
     *
     * Use events stored in database
     */
    func reconcile(filter: Filter, opts: NegentropyOptions) throws 
    
    /**
     * Negentropy reconciliation with custom items
     */
    func reconcileWithItems(filter: Filter, items: [NegentropyItem], opts: NegentropyOptions) throws 
    
    /**
     * Send event and wait for `OK` relay msg
     */
    func sendEvent(event: Event, opts: RelaySendOptions) throws  -> EventId
    
    /**
     * Send msg to relay
     */
    func sendMsg(msg: ClientMessage, opts: RelaySendOptions) throws 
    
    func stats()  -> RelayConnectionStats
    
    /**
     * Get relay status
     */
    func status()  -> RelayStatus
    
    /**
     * Disconnect from relay and set status to 'Stopped'
     */
    func stop() throws 
    
    /**
     * Subscribe to filters
     *
     * Internally generate a new random subscription ID. Check `subscribe_with_id` method to use a custom subscription ID.
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
    func subscribe(filters: [Filter], opts: SubscribeOptions) throws  -> String
    
    /**
     * Subscribe with custom subscription ID
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
    func subscribeWithId(id: String, filters: [Filter], opts: SubscribeOptions) throws 
    
    /**
     * Get filters by subscription ID
     */
    func subscription(id: String)  -> [Filter]?
    
    func subscriptions()  -> [String: [Filter]]
    
    /**
     * Check if relay support negentropy protocol
     */
    func supportNegentropy() throws  -> Bool
    
    /**
     * Disconnect from relay and set status to 'Terminated'
     */
    func terminate() throws 
    
    /**
     * Unsubscribe
     */
    func unsubscribe(id: String, opts: RelaySendOptions) throws 
    
    /**
     * Unsubscribe from all subscriptions
     */
    func unsubscribeAll(opts: RelaySendOptions) throws 
    
    /**
     * Get relay url
     */
    func url()  -> String
    
}

open class Relay:
    RelayProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relay(self.pointer, $0) }
    }
    /**
     * Create new `Relay` with **default** `options` and `in-memory database`
     */
public convenience init(url: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_relay_new(
        FfiConverterString.lower(url),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relay(pointer, $0) }
    }

    
    /**
     * Create new `Relay` with **custom** `options` and/or `database`
     */
public static func custom(url: String, database: NostrDatabase, opts: RelayOptions)throws  -> Relay {
    return try  FfiConverterTypeRelay.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_relay_custom(
        FfiConverterString.lower(url),
        FfiConverterTypeNostrDatabase.lower(database),
        FfiConverterTypeRelayOptions.lower(opts),$0
    )
})
}
    
    /**
     * Create new `Relay` with default `in-memory database` and custom `options`
     */
public static func withOpts(url: String, opts: RelayOptions)throws  -> Relay {
    return try  FfiConverterTypeRelay.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_relay_with_opts(
        FfiConverterString.lower(url),
        FfiConverterTypeRelayOptions.lower(opts),$0
    )
})
}
    

    
    /**
     * Send multiple `Event` at once
     */
open func batchEvent(events: [Event], opts: RelaySendOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_batch_event(self.uniffiClonePointer(),
        FfiConverterSequenceTypeEvent.lower(events),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
}
}
    
    /**
     * Send multiple `ClientMessage` at once
     */
open func batchMsg(msgs: [ClientMessage], opts: RelaySendOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_batch_msg(self.uniffiClonePointer(),
        FfiConverterSequenceTypeClientMessage.lower(msgs),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
}
}
    
    /**
     * Connect to relay and keep alive connection
     */
open func connect(connectionTimeout: TimeInterval?) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_connect(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(connectionTimeout),$0
    )
}
}
    
    /**
     * Count events of filters
     */
open func countEventsOf(filters: [Filter], timeout: TimeInterval)throws  -> UInt64 {
    return try  FfiConverterUInt64.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_count_events_of(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterDuration.lower(timeout),$0
    )
})
}
    
open func document() -> RelayInformationDocument {
    return try!  FfiConverterTypeRelayInformationDocument_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_document(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get events of filters
     *
     * Get events from local database and relay
     */
open func getEventsOf(filters: [Filter], timeout: TimeInterval)throws  -> [Event] {
    return try  FfiConverterSequenceTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_get_events_of(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterDuration.lower(timeout),$0
    )
})
}
    
    /**
     * Check if `Relay` is connected
     */
open func isConnected() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_is_connected(self.uniffiClonePointer(),$0
    )
})
}
    
open func opts() -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_opts(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get proxy
     */
open func proxy() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_proxy(self.uniffiClonePointer(),$0
    )
})
}
    
open func queue() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_queue(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Negentropy reconciliation
     *
     * Use events stored in database
     */
open func reconcile(filter: Filter, opts: NegentropyOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_reconcile(self.uniffiClonePointer(),
        FfiConverterTypeFilter_lower(filter),
        FfiConverterTypeNegentropyOptions.lower(opts),$0
    )
}
}
    
    /**
     * Negentropy reconciliation with custom items
     */
open func reconcileWithItems(filter: Filter, items: [NegentropyItem], opts: NegentropyOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_reconcile_with_items(self.uniffiClonePointer(),
        FfiConverterTypeFilter_lower(filter),
        FfiConverterSequenceTypeNegentropyItem.lower(items),
        FfiConverterTypeNegentropyOptions.lower(opts),$0
    )
}
}
    
    /**
     * Send event and wait for `OK` relay msg
     */
open func sendEvent(event: Event, opts: RelaySendOptions)throws  -> EventId {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_send_event(self.uniffiClonePointer(),
        FfiConverterTypeEvent_lower(event),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
})
}
    
    /**
     * Send msg to relay
     */
open func sendMsg(msg: ClientMessage, opts: RelaySendOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_send_msg(self.uniffiClonePointer(),
        FfiConverterTypeClientMessage_lower(msg),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
}
}
    
open func stats() -> RelayConnectionStats {
    return try!  FfiConverterTypeRelayConnectionStats.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_stats(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get relay status
     */
open func status() -> RelayStatus {
    return try!  FfiConverterTypeRelayStatus.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_status(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Disconnect from relay and set status to 'Stopped'
     */
open func stop()throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_stop(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Subscribe to filters
     *
     * Internally generate a new random subscription ID. Check `subscribe_with_id` method to use a custom subscription ID.
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
open func subscribe(filters: [Filter], opts: SubscribeOptions)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_subscribe(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterTypeSubscribeOptions.lower(opts),$0
    )
})
}
    
    /**
     * Subscribe with custom subscription ID
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
open func subscribeWithId(id: String, filters: [Filter], opts: SubscribeOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_subscribe_with_id(self.uniffiClonePointer(),
        FfiConverterString.lower(id),
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterTypeSubscribeOptions.lower(opts),$0
    )
}
}
    
    /**
     * Get filters by subscription ID
     */
open func subscription(id: String) -> [Filter]? {
    return try!  FfiConverterOptionSequenceTypeFilter.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_subscription(self.uniffiClonePointer(),
        FfiConverterString.lower(id),$0
    )
})
}
    
open func subscriptions() -> [String: [Filter]] {
    return try!  FfiConverterDictionaryStringSequenceTypeFilter.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_subscriptions(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if relay support negentropy protocol
     */
open func supportNegentropy()throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_support_negentropy(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Disconnect from relay and set status to 'Terminated'
     */
open func terminate()throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_terminate(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Unsubscribe
     */
open func unsubscribe(id: String, opts: RelaySendOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe(self.uniffiClonePointer(),
        FfiConverterString.lower(id),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
}
}
    
    /**
     * Unsubscribe from all subscriptions
     */
open func unsubscribeAll(opts: RelaySendOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe_all(self.uniffiClonePointer(),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
}
}
    
    /**
     * Get relay url
     */
open func url() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_url(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeRelay: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Relay

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Relay {
        return Relay(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Relay) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Relay {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Relay, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelay_lift(_ pointer: UnsafeMutableRawPointer) throws -> Relay {
    return try FfiConverterTypeRelay.lift(pointer)
}

public func FfiConverterTypeRelay_lower(_ value: Relay) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelay.lower(value)
}




public protocol RelayConnectionStatsProtocol : AnyObject {
    
    /**
     * The number of times a connection has been attempted
     */
    func attempts()  -> UInt64
    
    /**
     * Bytes received
     */
    func bytesReceived()  -> UInt64
    
    /**
     * Bytes sent
     */
    func bytesSent()  -> UInt64
    
    /**
     * Get UNIX timestamp of the last connection
     */
    func connectedAt()  -> Timestamp
    
    /**
     * Get UNIX timestamp of the first connection
     */
    func firstConnectionTimestamp()  -> Timestamp
    
    func latency()  -> TimeInterval?
    
    /**
     * The number of times a connection has been successfully established
     */
    func success()  -> UInt64
    
    /**
     * Uptime
     */
    func uptime()  -> Double
    
}

open class RelayConnectionStats:
    RelayConnectionStatsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relayconnectionstats(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relayconnectionstats(pointer, $0) }
    }

    

    
    /**
     * The number of times a connection has been attempted
     */
open func attempts() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_attempts(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Bytes received
     */
open func bytesReceived() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_received(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Bytes sent
     */
open func bytesSent() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_sent(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get UNIX timestamp of the last connection
     */
open func connectedAt() -> Timestamp {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_connected_at(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get UNIX timestamp of the first connection
     */
open func firstConnectionTimestamp() -> Timestamp {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_first_connection_timestamp(self.uniffiClonePointer(),$0
    )
})
}
    
open func latency() -> TimeInterval? {
    return try!  FfiConverterOptionDuration.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_latency(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The number of times a connection has been successfully established
     */
open func success() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_success(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Uptime
     */
open func uptime() -> Double {
    return try!  FfiConverterDouble.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_uptime(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeRelayConnectionStats: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayConnectionStats

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayConnectionStats {
        return RelayConnectionStats(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayConnectionStats) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayConnectionStats {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayConnectionStats, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayConnectionStats_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayConnectionStats {
    return try FfiConverterTypeRelayConnectionStats.lift(pointer)
}

public func FfiConverterTypeRelayConnectionStats_lower(_ value: RelayConnectionStats) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayConnectionStats.lower(value)
}




/**
 * Relay Limits
 */
public protocol RelayLimitsProtocol : AnyObject {
    
    /**
     * Maximum number of tags allowed (default: 2_000)
     */
    func eventMaxNumTags(maxNumTags: UInt16?)  -> RelayLimits
    
    /**
     * Maximum size of normalised JSON, in bytes (default: 70_000)
     */
    func eventMaxSize(maxSize: UInt32?)  -> RelayLimits
    
    /**
     * Maximum size of normalised JSON, in bytes (default: 5_250_000)
     */
    func messageMaxSize(maxSize: UInt32?)  -> RelayLimits
    
}

/**
 * Relay Limits
 */
open class RelayLimits:
    CustomDebugStringConvertible,
    Equatable,
    RelayLimitsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relaylimits(self.pointer, $0) }
    }
    /**
     * Construct with default limits
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relaylimits(pointer, $0) }
    }

    
    /**
     * Disable all limits
     */
public static func disable() -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_disable($0
    )
})
}
    

    
    /**
     * Maximum number of tags allowed (default: 2_000)
     */
open func eventMaxNumTags(maxNumTags: UInt16?) -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_num_tags(self.uniffiClonePointer(),
        FfiConverterOptionUInt16.lower(maxNumTags),$0
    )
})
}
    
    /**
     * Maximum size of normalised JSON, in bytes (default: 70_000)
     */
open func eventMaxSize(maxSize: UInt32?) -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_size(self.uniffiClonePointer(),
        FfiConverterOptionUInt32.lower(maxSize),$0
    )
})
}
    
    /**
     * Maximum size of normalised JSON, in bytes (default: 5_250_000)
     */
open func messageMaxSize(maxSize: UInt32?) -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_message_max_size(self.uniffiClonePointer(),
        FfiConverterOptionUInt32.lower(maxSize),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: RelayLimits, other: RelayLimits) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeRelayLimits.lower(other),$0
    )
}
        )
    }

}

public struct FfiConverterTypeRelayLimits: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayLimits

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayLimits {
        return RelayLimits(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayLimits) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayLimits {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayLimits, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayLimits_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayLimits {
    return try FfiConverterTypeRelayLimits.lift(pointer)
}

public func FfiConverterTypeRelayLimits_lower(_ value: RelayLimits) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayLimits.lower(value)
}




/**
 * `Relay` options
 */
public protocol RelayOptionsProtocol : AnyObject {
    
    /**
     * Automatically adjust retry seconds based on success/attempts (default: true)
     */
    func adjustRetrySec(adjustRetrySec: Bool)  -> RelayOptions
    
    /**
     * Set custom limits
     */
    func limits(limits: RelayLimits)  -> RelayOptions
    
    /**
     * Set ping flag
     */
    func ping(ping: Bool)  -> RelayOptions
    
    /**
     * Minimum POW for received events (default: 0)
     */
    func pow(diffculty: UInt8)  -> RelayOptions
    
    /**
     * Set proxy
     */
    func proxy(proxy: String?) throws  -> RelayOptions
    
    /**
     * Set read flag
     */
    func read(read: Bool)  -> RelayOptions
    
    /**
     * Enable/disable auto reconnection (default: true)
     */
    func reconnect(reconnect: Bool)  -> RelayOptions
    
    /**
     * Retry connection time (default: 10 sec)
     *
     * Are allowed values `>=` 5 secs
     */
    func retrySec(retrySec: UInt64)  -> RelayOptions
    
    /**
     * Set adjust_retry_sec option
     */
    func updateAdjustRetrySec(adjustRetrySec: Bool) 
    
    /**
     * Update `pow` option
     */
    func updatePowDifficulty(diffculty: UInt8) 
    
    /**
     * Update `reconnect` option
     */
    func updateReconnect(reconnect: Bool) 
    
    /**
     * Set retry_sec option
     */
    func updateRetrySec(retrySec: UInt64) 
    
    /**
     * Set write flag
     */
    func write(write: Bool)  -> RelayOptions
    
}

/**
 * `Relay` options
 */
open class RelayOptions:
    RelayOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relayoptions(self.pointer, $0) }
    }
    /**
     * New default relay options
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relayoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relayoptions(pointer, $0) }
    }

    

    
    /**
     * Automatically adjust retry seconds based on success/attempts (default: true)
     */
open func adjustRetrySec(adjustRetrySec: Bool) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_adjust_retry_sec(self.uniffiClonePointer(),
        FfiConverterBool.lower(adjustRetrySec),$0
    )
})
}
    
    /**
     * Set custom limits
     */
open func limits(limits: RelayLimits) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_limits(self.uniffiClonePointer(),
        FfiConverterTypeRelayLimits.lower(limits),$0
    )
})
}
    
    /**
     * Set ping flag
     */
open func ping(ping: Bool) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_ping(self.uniffiClonePointer(),
        FfiConverterBool.lower(ping),$0
    )
})
}
    
    /**
     * Minimum POW for received events (default: 0)
     */
open func pow(diffculty: UInt8) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_pow(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(diffculty),$0
    )
})
}
    
    /**
     * Set proxy
     */
open func proxy(proxy: String?)throws  -> RelayOptions {
    return try  FfiConverterTypeRelayOptions.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_proxy(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(proxy),$0
    )
})
}
    
    /**
     * Set read flag
     */
open func read(read: Bool) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_read(self.uniffiClonePointer(),
        FfiConverterBool.lower(read),$0
    )
})
}
    
    /**
     * Enable/disable auto reconnection (default: true)
     */
open func reconnect(reconnect: Bool) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_reconnect(self.uniffiClonePointer(),
        FfiConverterBool.lower(reconnect),$0
    )
})
}
    
    /**
     * Retry connection time (default: 10 sec)
     *
     * Are allowed values `>=` 5 secs
     */
open func retrySec(retrySec: UInt64) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_retry_sec(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(retrySec),$0
    )
})
}
    
    /**
     * Set adjust_retry_sec option
     */
open func updateAdjustRetrySec(adjustRetrySec: Bool) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_update_adjust_retry_sec(self.uniffiClonePointer(),
        FfiConverterBool.lower(adjustRetrySec),$0
    )
}
}
    
    /**
     * Update `pow` option
     */
open func updatePowDifficulty(diffculty: UInt8) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_update_pow_difficulty(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(diffculty),$0
    )
}
}
    
    /**
     * Update `reconnect` option
     */
open func updateReconnect(reconnect: Bool) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_update_reconnect(self.uniffiClonePointer(),
        FfiConverterBool.lower(reconnect),$0
    )
}
}
    
    /**
     * Set retry_sec option
     */
open func updateRetrySec(retrySec: UInt64) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_update_retry_sec(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(retrySec),$0
    )
}
}
    
    /**
     * Set write flag
     */
open func write(write: Bool) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_write(self.uniffiClonePointer(),
        FfiConverterBool.lower(write),$0
    )
})
}
    

}

public struct FfiConverterTypeRelayOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayOptions {
        return RelayOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayOptions {
    return try FfiConverterTypeRelayOptions.lift(pointer)
}

public func FfiConverterTypeRelayOptions_lower(_ value: RelayOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayOptions.lower(value)
}




public protocol RelayPoolProtocol : AnyObject {
    
    func addRelay(url: String, opts: RelayOptions) throws  -> Bool
    
    /**
     * Send multiple `Event` at once to **all connected relays** and wait for `OK` message
     */
    func batchEvent(events: [Event], opts: RelaySendOptions) throws 
    
    /**
     * Send multiple events at once to **specific relays** and wait for `OK` message
     */
    func batchEventTo(urls: [String], events: [Event], opts: RelaySendOptions) throws 
    
    /**
     * Send multiple client messages at once to all connected relays
     */
    func batchMsg(msgs: [ClientMessage], opts: RelaySendOptions) throws 
    
    /**
     * Send multiple client messages at once to specific relays
     *
     * Note: **the relays must already be added!**
     */
    func batchMsgTo(urls: [String], msgs: [ClientMessage], opts: RelaySendOptions) throws 
    
    /**
     * Connect to all added relays and keep connection alive
     */
    func connect(connectionTimeout: TimeInterval?) 
    
    /**
     * Connect to relay
     */
    func connectRelay(url: String, connectionTimeout: TimeInterval?) throws 
    
    /**
     * Get database
     */
    func database()  -> NostrDatabase
    
    /**
     * Disconnect from all relays
     */
    func disconnect() throws 
    
    /**
     * Get events of filters from **specific relays**
     *
     * Get events both from **local database** and **relays**
     */
    func getEventsFrom(urls: [String], filters: [Filter], timeout: TimeInterval, opts: FilterOptions) throws  -> [Event]
    
    /**
     * Get events of filters
     *
     * Get events both from **local database** and **relays**
     */
    func getEventsOf(filters: [Filter], timeout: TimeInterval, opts: FilterOptions) throws  -> [Event]
    
    /**
     * Handle relay pool notifications
     */
    func handleNotifications(handler: HandleNotification) throws 
    
    /**
     * Negentropy reconciliation
     *
     * Use events stored in database
     */
    func reconcile(filter: Filter, opts: NegentropyOptions) throws 
    
    /**
     * Negentropy reconciliation with custom items
     */
    func reconcileWithItems(filter: Filter, items: [NegentropyItem], opts: NegentropyOptions) throws 
    
    /**
     * Get relay
     */
    func relay(url: String) throws  -> Relay
    
    /**
     * Get relays
     */
    func relays()  -> [String: Relay]
    
    func removeAllRelay() throws 
    
    func removeRelay(url: String) throws 
    
    /**
     * Send event to **all connected relays** and wait for `OK` message
     */
    func sendEvent(event: Event, opts: RelaySendOptions) throws  -> EventId
    
    /**
     * Send event to **specific relays** and wait for `OK` message
     */
    func sendEventTo(urls: [String], event: Event, opts: RelaySendOptions) throws  -> EventId
    
    /**
     * Send client message to all connected relays
     */
    func sendMsg(msg: ClientMessage, opts: RelaySendOptions) throws 
    
    /**
     * Send client message to specific relays
     *
     * Note: **the relays must already be added!**
     */
    func sendMsgTo(urls: [String], msg: ClientMessage, opts: RelaySendOptions) throws 
    
    /**
     * Completely shutdown pool
     */
    func shutdown() throws 
    
    /**
     * Stop
     *
     * Call `connect` to re-start relays connections
     */
    func stop() throws 
    
    /**
     * Subscribe to filters
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
    func subscribe(filters: [Filter], opts: SubscribeOptions)  -> String
    
    /**
     * Subscribe with custom subscription ID
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
    func subscribeWithId(id: String, filters: [Filter], opts: SubscribeOptions) 
    
    /**
     * Get filters by subscription ID
     */
    func subscription(id: String)  -> [Filter]?
    
    /**
     * Get subscriptions
     */
    func subscriptions()  -> [String: [Filter]]
    
    /**
     * Unsubscribe
     */
    func unsubscribe(id: String, opts: RelaySendOptions) 
    
    /**
     * Unsubscribe from all subscriptions
     */
    func unsubscribeAll(opts: RelaySendOptions) 
    
}

open class RelayPool:
    RelayPoolProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relaypool(self.pointer, $0) }
    }
    /**
     * Create new `RelayPool` with `in-memory` database
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaypool_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relaypool(pointer, $0) }
    }

    
    /**
     * Create new `RelayPool` with `custom` database
     */
public static func withDatabase(database: NostrDatabase) -> RelayPool {
    return try!  FfiConverterTypeRelayPool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaypool_with_database(
        FfiConverterTypeNostrDatabase.lower(database),$0
    )
})
}
    

    
open func addRelay(url: String, opts: RelayOptions)throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_add_relay(self.uniffiClonePointer(),
        FfiConverterString.lower(url),
        FfiConverterTypeRelayOptions.lower(opts),$0
    )
})
}
    
    /**
     * Send multiple `Event` at once to **all connected relays** and wait for `OK` message
     */
open func batchEvent(events: [Event], opts: RelaySendOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_batch_event(self.uniffiClonePointer(),
        FfiConverterSequenceTypeEvent.lower(events),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
}
}
    
    /**
     * Send multiple events at once to **specific relays** and wait for `OK` message
     */
open func batchEventTo(urls: [String], events: [Event], opts: RelaySendOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_batch_event_to(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(urls),
        FfiConverterSequenceTypeEvent.lower(events),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
}
}
    
    /**
     * Send multiple client messages at once to all connected relays
     */
open func batchMsg(msgs: [ClientMessage], opts: RelaySendOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_batch_msg(self.uniffiClonePointer(),
        FfiConverterSequenceTypeClientMessage.lower(msgs),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
}
}
    
    /**
     * Send multiple client messages at once to specific relays
     *
     * Note: **the relays must already be added!**
     */
open func batchMsgTo(urls: [String], msgs: [ClientMessage], opts: RelaySendOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_batch_msg_to(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(urls),
        FfiConverterSequenceTypeClientMessage.lower(msgs),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
}
}
    
    /**
     * Connect to all added relays and keep connection alive
     */
open func connect(connectionTimeout: TimeInterval?) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_connect(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(connectionTimeout),$0
    )
}
}
    
    /**
     * Connect to relay
     */
open func connectRelay(url: String, connectionTimeout: TimeInterval?)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_connect_relay(self.uniffiClonePointer(),
        FfiConverterString.lower(url),
        FfiConverterOptionDuration.lower(connectionTimeout),$0
    )
}
}
    
    /**
     * Get database
     */
open func database() -> NostrDatabase {
    return try!  FfiConverterTypeNostrDatabase.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_database(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Disconnect from all relays
     */
open func disconnect()throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_disconnect(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Get events of filters from **specific relays**
     *
     * Get events both from **local database** and **relays**
     */
open func getEventsFrom(urls: [String], filters: [Filter], timeout: TimeInterval, opts: FilterOptions)throws  -> [Event] {
    return try  FfiConverterSequenceTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_get_events_from(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(urls),
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterDuration.lower(timeout),
        FfiConverterTypeFilterOptions.lower(opts),$0
    )
})
}
    
    /**
     * Get events of filters
     *
     * Get events both from **local database** and **relays**
     */
open func getEventsOf(filters: [Filter], timeout: TimeInterval, opts: FilterOptions)throws  -> [Event] {
    return try  FfiConverterSequenceTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_get_events_of(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterDuration.lower(timeout),
        FfiConverterTypeFilterOptions.lower(opts),$0
    )
})
}
    
    /**
     * Handle relay pool notifications
     */
open func handleNotifications(handler: HandleNotification)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_handle_notifications(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceHandleNotification.lower(handler),$0
    )
}
}
    
    /**
     * Negentropy reconciliation
     *
     * Use events stored in database
     */
open func reconcile(filter: Filter, opts: NegentropyOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_reconcile(self.uniffiClonePointer(),
        FfiConverterTypeFilter_lower(filter),
        FfiConverterTypeNegentropyOptions.lower(opts),$0
    )
}
}
    
    /**
     * Negentropy reconciliation with custom items
     */
open func reconcileWithItems(filter: Filter, items: [NegentropyItem], opts: NegentropyOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_reconcile_with_items(self.uniffiClonePointer(),
        FfiConverterTypeFilter_lower(filter),
        FfiConverterSequenceTypeNegentropyItem.lower(items),
        FfiConverterTypeNegentropyOptions.lower(opts),$0
    )
}
}
    
    /**
     * Get relay
     */
open func relay(url: String)throws  -> Relay {
    return try  FfiConverterTypeRelay.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_relay(self.uniffiClonePointer(),
        FfiConverterString.lower(url),$0
    )
})
}
    
    /**
     * Get relays
     */
open func relays() -> [String: Relay] {
    return try!  FfiConverterDictionaryStringTypeRelay.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_relays(self.uniffiClonePointer(),$0
    )
})
}
    
open func removeAllRelay()throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_remove_all_relay(self.uniffiClonePointer(),$0
    )
}
}
    
open func removeRelay(url: String)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_remove_relay(self.uniffiClonePointer(),
        FfiConverterString.lower(url),$0
    )
}
}
    
    /**
     * Send event to **all connected relays** and wait for `OK` message
     */
open func sendEvent(event: Event, opts: RelaySendOptions)throws  -> EventId {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_send_event(self.uniffiClonePointer(),
        FfiConverterTypeEvent_lower(event),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
})
}
    
    /**
     * Send event to **specific relays** and wait for `OK` message
     */
open func sendEventTo(urls: [String], event: Event, opts: RelaySendOptions)throws  -> EventId {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_send_event_to(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(urls),
        FfiConverterTypeEvent_lower(event),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
})
}
    
    /**
     * Send client message to all connected relays
     */
open func sendMsg(msg: ClientMessage, opts: RelaySendOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_send_msg(self.uniffiClonePointer(),
        FfiConverterTypeClientMessage_lower(msg),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
}
}
    
    /**
     * Send client message to specific relays
     *
     * Note: **the relays must already be added!**
     */
open func sendMsgTo(urls: [String], msg: ClientMessage, opts: RelaySendOptions)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_send_msg_to(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(urls),
        FfiConverterTypeClientMessage_lower(msg),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
}
}
    
    /**
     * Completely shutdown pool
     */
open func shutdown()throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_shutdown(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Stop
     *
     * Call `connect` to re-start relays connections
     */
open func stop()throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_stop(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Subscribe to filters
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
open func subscribe(filters: [Filter], opts: SubscribeOptions) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_subscribe(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterTypeSubscribeOptions.lower(opts),$0
    )
})
}
    
    /**
     * Subscribe with custom subscription ID
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
open func subscribeWithId(id: String, filters: [Filter], opts: SubscribeOptions) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_subscribe_with_id(self.uniffiClonePointer(),
        FfiConverterString.lower(id),
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterTypeSubscribeOptions.lower(opts),$0
    )
}
}
    
    /**
     * Get filters by subscription ID
     */
open func subscription(id: String) -> [Filter]? {
    return try!  FfiConverterOptionSequenceTypeFilter.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_subscription(self.uniffiClonePointer(),
        FfiConverterString.lower(id),$0
    )
})
}
    
    /**
     * Get subscriptions
     */
open func subscriptions() -> [String: [Filter]] {
    return try!  FfiConverterDictionaryStringSequenceTypeFilter.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_subscriptions(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Unsubscribe
     */
open func unsubscribe(id: String, opts: RelaySendOptions) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_unsubscribe(self.uniffiClonePointer(),
        FfiConverterString.lower(id),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
}
}
    
    /**
     * Unsubscribe from all subscriptions
     */
open func unsubscribeAll(opts: RelaySendOptions) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_unsubscribe_all(self.uniffiClonePointer(),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
}
}
    

}

public struct FfiConverterTypeRelayPool: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayPool

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayPool {
        return RelayPool(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayPool) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayPool {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayPool, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayPool_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayPool {
    return try FfiConverterTypeRelayPool.lift(pointer)
}

public func FfiConverterTypeRelayPool_lower(_ value: RelayPool) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayPool.lower(value)
}




public protocol RelaySendOptionsProtocol : AnyObject {
    
    /**
     * Skip wait for disconnected relay (default: true)
     */
    func skipDisconnected(value: Bool)  -> RelaySendOptions
    
    /**
     * Skip wait for confirmation that message is sent (default: false)
     */
    func skipSendConfirmation(value: Bool)  -> RelaySendOptions
    
    /**
     * Timeout for sending event (default: 20 secs)
     *
     * If `None`, the default timeout will be used
     */
    func timeout(timeout: TimeInterval?)  -> RelaySendOptions
    
}

open class RelaySendOptions:
    RelaySendOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relaysendoptions(self.pointer, $0) }
    }
    /**
     * New default `RelaySendOptions`
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaysendoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relaysendoptions(pointer, $0) }
    }

    

    
    /**
     * Skip wait for disconnected relay (default: true)
     */
open func skipDisconnected(value: Bool) -> RelaySendOptions {
    return try!  FfiConverterTypeRelaySendOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaysendoptions_skip_disconnected(self.uniffiClonePointer(),
        FfiConverterBool.lower(value),$0
    )
})
}
    
    /**
     * Skip wait for confirmation that message is sent (default: false)
     */
open func skipSendConfirmation(value: Bool) -> RelaySendOptions {
    return try!  FfiConverterTypeRelaySendOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaysendoptions_skip_send_confirmation(self.uniffiClonePointer(),
        FfiConverterBool.lower(value),$0
    )
})
}
    
    /**
     * Timeout for sending event (default: 20 secs)
     *
     * If `None`, the default timeout will be used
     */
open func timeout(timeout: TimeInterval?) -> RelaySendOptions {
    return try!  FfiConverterTypeRelaySendOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaysendoptions_timeout(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    

}

public struct FfiConverterTypeRelaySendOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelaySendOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelaySendOptions {
        return RelaySendOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelaySendOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelaySendOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelaySendOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelaySendOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelaySendOptions {
    return try FfiConverterTypeRelaySendOptions.lift(pointer)
}

public func FfiConverterTypeRelaySendOptions_lower(_ value: RelaySendOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelaySendOptions.lower(value)
}




/**
 * Auto-closing subscribe options
 */
public protocol SubscribeAutoCloseOptionsProtocol : AnyObject {
    
    /**
     * Close subscription when `FilterOptions` is satisfied
     */
    func filter(filter: FilterOptions)  -> SubscribeAutoCloseOptions
    
    /**
     * Automatically close subscription after `Duration`
     */
    func timeout(timeout: TimeInterval?)  -> SubscribeAutoCloseOptions
    
}

/**
 * Auto-closing subscribe options
 */
open class SubscribeAutoCloseOptions:
    SubscribeAutoCloseOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_subscribeautocloseoptions(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_subscribeautocloseoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_subscribeautocloseoptions(pointer, $0) }
    }

    

    
    /**
     * Close subscription when `FilterOptions` is satisfied
     */
open func filter(filter: FilterOptions) -> SubscribeAutoCloseOptions {
    return try!  FfiConverterTypeSubscribeAutoCloseOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_filter(self.uniffiClonePointer(),
        FfiConverterTypeFilterOptions.lower(filter),$0
    )
})
}
    
    /**
     * Automatically close subscription after `Duration`
     */
open func timeout(timeout: TimeInterval?) -> SubscribeAutoCloseOptions {
    return try!  FfiConverterTypeSubscribeAutoCloseOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_timeout(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    

}

public struct FfiConverterTypeSubscribeAutoCloseOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SubscribeAutoCloseOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeAutoCloseOptions {
        return SubscribeAutoCloseOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SubscribeAutoCloseOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubscribeAutoCloseOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SubscribeAutoCloseOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSubscribeAutoCloseOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeAutoCloseOptions {
    return try FfiConverterTypeSubscribeAutoCloseOptions.lift(pointer)
}

public func FfiConverterTypeSubscribeAutoCloseOptions_lower(_ value: SubscribeAutoCloseOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSubscribeAutoCloseOptions.lower(value)
}




/**
 * Subscribe options
 */
public protocol SubscribeOptionsProtocol : AnyObject {
    
    /**
     * Set auto-close conditions
     */
    func closeOn(opts: SubscribeAutoCloseOptions?)  -> SubscribeOptions
    
    /**
     * Set [RelaySendOptions]
     */
    func sendOpts(opts: RelaySendOptions)  -> SubscribeOptions
    
}

/**
 * Subscribe options
 */
open class SubscribeOptions:
    SubscribeOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_subscribeoptions(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_subscribeoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_subscribeoptions(pointer, $0) }
    }

    

    
    /**
     * Set auto-close conditions
     */
open func closeOn(opts: SubscribeAutoCloseOptions?) -> SubscribeOptions {
    return try!  FfiConverterTypeSubscribeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeoptions_close_on(self.uniffiClonePointer(),
        FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts),$0
    )
})
}
    
    /**
     * Set [RelaySendOptions]
     */
open func sendOpts(opts: RelaySendOptions) -> SubscribeOptions {
    return try!  FfiConverterTypeSubscribeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeoptions_send_opts(self.uniffiClonePointer(),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
})
}
    

}

public struct FfiConverterTypeSubscribeOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SubscribeOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeOptions {
        return SubscribeOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SubscribeOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubscribeOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SubscribeOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSubscribeOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeOptions {
    return try FfiConverterTypeSubscribeOptions.lift(pointer)
}

public func FfiConverterTypeSubscribeOptions_lower(_ value: SubscribeOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSubscribeOptions.lower(value)
}




/**
 * Zap Details
 */
public protocol ZapDetailsProtocol : AnyObject {
    
    /**
     * Add message
     */
    func message(message: String)  -> ZapDetails
    
}

/**
 * Zap Details
 */
open class ZapDetails:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    ZapDetailsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_zapdetails(self.pointer, $0) }
    }
    /**
     * Create new Zap Details
     *
     * **Note: `private` zaps are not currently supported here!**
     */
public convenience init(zapType: ZapType) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_zapdetails_new(
        FfiConverterTypeZapType_lower(zapType),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_zapdetails(pointer, $0) }
    }

    

    
    /**
     * Add message
     */
open func message(message: String) -> ZapDetails {
    return try!  FfiConverterTypeZapDetails.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapdetails_message(self.uniffiClonePointer(),
        FfiConverterString.lower(message),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapdetails_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: ZapDetails, other: ZapDetails) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapdetails_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeZapDetails.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapdetails_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeZapDetails: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZapDetails

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapDetails {
        return ZapDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZapDetails) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZapDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZapDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeZapDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapDetails {
    return try FfiConverterTypeZapDetails.lift(pointer)
}

public func FfiConverterTypeZapDetails_lower(_ value: ZapDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZapDetails.lower(value)
}




/**
 * Zap entity
 */
public protocol ZapEntityProtocol : AnyObject {
    
}

/**
 * Zap entity
 */
open class ZapEntity:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    ZapEntityProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_zapentity(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_zapentity(pointer, $0) }
    }

    
public static func event(eventId: EventId) -> ZapEntity {
    return try!  FfiConverterTypeZapEntity.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_zapentity_event(
        FfiConverterTypeEventId_lower(eventId),$0
    )
})
}
    
public static func publicKey(publicKey: PublicKey) -> ZapEntity {
    return try!  FfiConverterTypeZapEntity.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_zapentity_public_key(
        FfiConverterTypePublicKey_lower(publicKey),$0
    )
})
}
    

    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapentity_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: ZapEntity, other: ZapEntity) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapentity_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeZapEntity.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapentity_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeZapEntity: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZapEntity

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapEntity {
        return ZapEntity(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZapEntity) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZapEntity {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZapEntity, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeZapEntity_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapEntity {
    return try FfiConverterTypeZapEntity.lift(pointer)
}

public func FfiConverterTypeZapEntity_lower(_ value: ZapEntity) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZapEntity.lower(value)
}


public struct NegentropyItem {
    public var id: EventId
    public var timestamp: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: EventId, timestamp: Timestamp) {
        self.id = id
        self.timestamp = timestamp
    }
}



public struct FfiConverterTypeNegentropyItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NegentropyItem {
        return
            try NegentropyItem(
                id: FfiConverterTypeEventId.read(from: &buf), 
                timestamp: FfiConverterTypeTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: NegentropyItem, into buf: inout [UInt8]) {
        FfiConverterTypeEventId.write(value.id, into: &buf)
        FfiConverterTypeTimestamp.write(value.timestamp, into: &buf)
    }
}


public func FfiConverterTypeNegentropyItem_lift(_ buf: RustBuffer) throws -> NegentropyItem {
    return try FfiConverterTypeNegentropyItem.lift(buf)
}

public func FfiConverterTypeNegentropyItem_lower(_ value: NegentropyItem) -> RustBuffer {
    return FfiConverterTypeNegentropyItem.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Filter options
 */

public enum FilterOptions {
    
    /**
     * Exit on EOSE
     */
    case exitOnEose
    /**
     * After EOSE is received, keep listening for N more events that match the filter, then return
     */
    case waitForEventsAfterEose(num: UInt16
    )
    /**
     * After EOSE is received, keep listening for matching events for `Duration` more time, then return
     */
    case waitDurationAfterEose(duration: TimeInterval
    )
}


public struct FfiConverterTypeFilterOptions: FfiConverterRustBuffer {
    typealias SwiftType = FilterOptions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FilterOptions {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .exitOnEose
        
        case 2: return .waitForEventsAfterEose(num: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 3: return .waitDurationAfterEose(duration: try FfiConverterDuration.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FilterOptions, into buf: inout [UInt8]) {
        switch value {
        
        
        case .exitOnEose:
            writeInt(&buf, Int32(1))
        
        
        case let .waitForEventsAfterEose(num):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(num, into: &buf)
            
        
        case let .waitDurationAfterEose(duration):
            writeInt(&buf, Int32(3))
            FfiConverterDuration.write(duration, into: &buf)
            
        }
    }
}


public func FfiConverterTypeFilterOptions_lift(_ buf: RustBuffer) throws -> FilterOptions {
    return try FfiConverterTypeFilterOptions.lift(buf)
}

public func FfiConverterTypeFilterOptions_lower(_ value: FilterOptions) -> RustBuffer {
    return FfiConverterTypeFilterOptions.lower(value)
}



extension FilterOptions: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogLevel {
    
    case error
    case warn
    case info
    case debug
    case trace
}


public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .error
        
        case 2: return .warn
        
        case 3: return .info
        
        case 4: return .debug
        
        case 5: return .trace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .error:
            writeInt(&buf, Int32(1))
        
        
        case .warn:
            writeInt(&buf, Int32(2))
        
        
        case .info:
            writeInt(&buf, Int32(3))
        
        
        case .debug:
            writeInt(&buf, Int32(4))
        
        
        case .trace:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}



extension LogLevel: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NegentropyDirection {
    
    case up
    case down
    case both
}


public struct FfiConverterTypeNegentropyDirection: FfiConverterRustBuffer {
    typealias SwiftType = NegentropyDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NegentropyDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .up
        
        case 2: return .down
        
        case 3: return .both
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NegentropyDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .up:
            writeInt(&buf, Int32(1))
        
        
        case .down:
            writeInt(&buf, Int32(2))
        
        
        case .both:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeNegentropyDirection_lift(_ buf: RustBuffer) throws -> NegentropyDirection {
    return try FfiConverterTypeNegentropyDirection.lift(buf)
}

public func FfiConverterTypeNegentropyDirection_lower(_ value: NegentropyDirection) -> RustBuffer {
    return FfiConverterTypeNegentropyDirection.lower(value)
}



extension NegentropyDirection: Equatable, Hashable {}




public enum NostrSdkError {

    
    
    case Generic(message: String)
    
}


public struct FfiConverterTypeNostrSdkError: FfiConverterRustBuffer {
    typealias SwiftType = NostrSdkError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrSdkError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NostrSdkError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


extension NostrSdkError: Equatable, Hashable {}

extension NostrSdkError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Proxy target
 */

public enum ProxyTarget {
    
    /**
     * Use proxy for all relays
     */
    case all
    /**
     * Use proxy only for `.onion` relays
     */
    case onion
}


public struct FfiConverterTypeProxyTarget: FfiConverterRustBuffer {
    typealias SwiftType = ProxyTarget

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProxyTarget {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .all
        
        case 2: return .onion
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProxyTarget, into buf: inout [UInt8]) {
        switch value {
        
        
        case .all:
            writeInt(&buf, Int32(1))
        
        
        case .onion:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeProxyTarget_lift(_ buf: RustBuffer) throws -> ProxyTarget {
    return try FfiConverterTypeProxyTarget.lift(buf)
}

public func FfiConverterTypeProxyTarget_lower(_ value: ProxyTarget) -> RustBuffer {
    return FfiConverterTypeProxyTarget.lower(value)
}



extension ProxyTarget: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RelayStatus {
    
    /**
     * Relay initialized
     */
    case initialized
    /**
     * Pending
     */
    case pending
    /**
     * Connecting
     */
    case connecting
    /**
     * Relay connected
     */
    case connected
    /**
     * Relay disconnected, will retry to connect again
     */
    case disconnected
    /**
     * Stop
     */
    case stopped
    /**
     * Relay completely disconnected
     */
    case terminated
}


public struct FfiConverterTypeRelayStatus: FfiConverterRustBuffer {
    typealias SwiftType = RelayStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initialized
        
        case 2: return .pending
        
        case 3: return .connecting
        
        case 4: return .connected
        
        case 5: return .disconnected
        
        case 6: return .stopped
        
        case 7: return .terminated
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RelayStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .initialized:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case .connecting:
            writeInt(&buf, Int32(3))
        
        
        case .connected:
            writeInt(&buf, Int32(4))
        
        
        case .disconnected:
            writeInt(&buf, Int32(5))
        
        
        case .stopped:
            writeInt(&buf, Int32(6))
        
        
        case .terminated:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeRelayStatus_lift(_ buf: RustBuffer) throws -> RelayStatus {
    return try FfiConverterTypeRelayStatus.lift(buf)
}

public func FfiConverterTypeRelayStatus_lower(_ value: RelayStatus) -> RustBuffer {
    return FfiConverterTypeRelayStatus.lower(value)
}



extension RelayStatus: Equatable, Hashable {}






public protocol CustomNostrDatabase : AnyObject {
    
    /**
     * Name of backend
     */
    func backend()  -> String
    
    /**
     * Save [`Event`] into store
     *
     * Return `true` if event was successfully saved into database.
     *
     * **This method assume that [`Event`] was already verified**
     */
    func saveEvent(event: Event) throws  -> Bool
    
    /**
     * Check if [`Event`] has already been saved
     */
    func hasEventAlreadyBeenSaved(eventId: EventId) throws  -> Bool
    
    /**
     * Check if [`EventId`] has already been seen
     */
    func hasEventAlreadyBeenSeen(eventId: EventId) throws  -> Bool
    
    /**
     * Check if [`EventId`] has been deleted
     */
    func hasEventIdBeenDeleted(eventId: EventId) throws  -> Bool
    
    /**
     * Check if event with [`Coordinate`] has been deleted before [`Timestamp`]
     */
    func hasCoordinateBeenDeleted(coordinate: Coordinate, timestamp: Timestamp) throws  -> Bool
    
    /**
     * Set [`EventId`] as seen by relay
     *
     * Useful for NIP65 (aka gossip)
     */
    func eventIdSeen(eventId: EventId, relayUrl: String) throws 
    
    /**
     * Get list of relays that have seen the [`EventId`]
     */
    func eventSeenOnRelays(eventId: EventId) throws  -> [String]?
    
    /**
     * Get [`Event`] by [`EventId`]
     */
    func eventById(eventId: EventId) throws  -> Event
    
    /**
     * Count number of [`Event`] found by filters
     *
     * Use `Filter::new()` or `Filter::default()` to count all events.
     */
    func count(filters: [Filter]) throws  -> UInt64
    
    /**
     * Query store with filters
     */
    func query(filters: [Filter]) throws  -> [Event]
    
    /**
     * Delete all events that match the `Filter`
     */
    func delete(filter: Filter) throws 
    
    /**
     * Wipe all data
     */
    func wipe() throws 
    
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceCustomNostrDatabase {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceCustomNostrDatabase = UniffiVTableCallbackInterfaceCustomNostrDatabase(
        backend: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> String in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.backend(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        saveEvent: { (
            uniffiHandle: UInt64,
            event: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.saveEvent(
                     event: try FfiConverterTypeEvent_lift(event)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
        },
        hasEventAlreadyBeenSaved: { (
            uniffiHandle: UInt64,
            eventId: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.hasEventAlreadyBeenSaved(
                     eventId: try FfiConverterTypeEventId_lift(eventId)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
        },
        hasEventAlreadyBeenSeen: { (
            uniffiHandle: UInt64,
            eventId: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.hasEventAlreadyBeenSeen(
                     eventId: try FfiConverterTypeEventId_lift(eventId)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
        },
        hasEventIdBeenDeleted: { (
            uniffiHandle: UInt64,
            eventId: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.hasEventIdBeenDeleted(
                     eventId: try FfiConverterTypeEventId_lift(eventId)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
        },
        hasCoordinateBeenDeleted: { (
            uniffiHandle: UInt64,
            coordinate: UnsafeMutableRawPointer,
            timestamp: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.hasCoordinateBeenDeleted(
                     coordinate: try FfiConverterTypeCoordinate_lift(coordinate),
                     timestamp: try FfiConverterTypeTimestamp_lift(timestamp)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
        },
        eventIdSeen: { (
            uniffiHandle: UInt64,
            eventId: UnsafeMutableRawPointer,
            relayUrl: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.eventIdSeen(
                     eventId: try FfiConverterTypeEventId_lift(eventId),
                     relayUrl: try FfiConverterString.lift(relayUrl)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
        },
        eventSeenOnRelays: { (
            uniffiHandle: UInt64,
            eventId: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> [String]? in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.eventSeenOnRelays(
                     eventId: try FfiConverterTypeEventId_lift(eventId)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionSequenceString.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
        },
        eventById: { (
            uniffiHandle: UInt64,
            eventId: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutablePointer<UnsafeMutableRawPointer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Event in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.eventById(
                     eventId: try FfiConverterTypeEventId_lift(eventId)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeEvent_lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
        },
        count: { (
            uniffiHandle: UInt64,
            filters: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<UInt64>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> UInt64 in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.count(
                     filters: try FfiConverterSequenceTypeFilter.lift(filters)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterUInt64.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
        },
        query: { (
            uniffiHandle: UInt64,
            filters: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> [Event] in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.query(
                     filters: try FfiConverterSequenceTypeFilter.lift(filters)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterSequenceTypeEvent.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
        },
        delete: { (
            uniffiHandle: UInt64,
            filter: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.delete(
                     filter: try FfiConverterTypeFilter_lift(filter)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
        },
        wipe: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.wipe(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceCustomNostrDatabase.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface CustomNostrDatabase: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitCustomNostrDatabase() {
    uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customnostrdatabase(&UniffiCallbackInterfaceCustomNostrDatabase.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceCustomNostrDatabase {
    fileprivate static var handleMap = UniffiHandleMap<CustomNostrDatabase>()
}

extension FfiConverterCallbackInterfaceCustomNostrDatabase : FfiConverter {
    typealias SwiftType = CustomNostrDatabase
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol HandleNotification : AnyObject {
    
    func handleMsg(relayUrl: String, msg: RelayMessage) 
    
    func handle(relayUrl: String, subscriptionId: String, event: Event) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceHandleNotification {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceHandleNotification = UniffiVTableCallbackInterfaceHandleNotification(
        handleMsg: { (
            uniffiHandle: UInt64,
            relayUrl: RustBuffer,
            msg: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceHandleNotification.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.handleMsg(
                     relayUrl: try FfiConverterString.lift(relayUrl),
                     msg: try FfiConverterTypeRelayMessage_lift(msg)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        handle: { (
            uniffiHandle: UInt64,
            relayUrl: RustBuffer,
            subscriptionId: RustBuffer,
            event: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceHandleNotification.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.handle(
                     relayUrl: try FfiConverterString.lift(relayUrl),
                     subscriptionId: try FfiConverterString.lift(subscriptionId),
                     event: try FfiConverterTypeEvent_lift(event)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceHandleNotification.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HandleNotification: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitHandleNotification() {
    uniffi_nostr_sdk_ffi_fn_init_callback_vtable_handlenotification(&UniffiCallbackInterfaceHandleNotification.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceHandleNotification {
    fileprivate static var handleMap = UniffiHandleMap<HandleNotification>()
}

extension FfiConverterCallbackInterfaceHandleNotification : FfiConverter {
    typealias SwiftType = HandleNotification
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDuration.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDuration.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeNostrSigner: FfiConverterRustBuffer {
    typealias SwiftType = NostrSigner?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNostrSigner.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNostrSigner.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRelayOptions: FfiConverterRustBuffer {
    typealias SwiftType = RelayOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRelayOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRelayOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSubscribeAutoCloseOptions: FfiConverterRustBuffer {
    typealias SwiftType = SubscribeAutoCloseOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSubscribeAutoCloseOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSubscribeAutoCloseOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeZapDetails: FfiConverterRustBuffer {
    typealias SwiftType = ZapDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZapDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZapDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = [Filter]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFilter.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFilter.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventId: FfiConverterRustBuffer {
    typealias SwiftType = EventId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Timestamp?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTimestamp.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTimestamp.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNegentropyItem: FfiConverterRustBuffer {
    typealias SwiftType = [NegentropyItem]

    public static func write(_ value: [NegentropyItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNegentropyItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NegentropyItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [NegentropyItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNegentropyItem.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeClientMessage: FfiConverterRustBuffer {
    typealias SwiftType = [ClientMessage]

    public static func write(_ value: [ClientMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeClientMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ClientMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [ClientMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeClientMessage.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = [Event]

    public static func write(_ value: [Event], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEvent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Event] {
        let len: Int32 = try readInt(&buf)
        var seq = [Event]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEvent.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = [Filter]

    public static func write(_ value: [Filter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Filter] {
        let len: Int32 = try readInt(&buf)
        var seq = [Filter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFilter.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLookupInvoiceResponseResult: FfiConverterRustBuffer {
    typealias SwiftType = [LookupInvoiceResponseResult]

    public static func write(_ value: [LookupInvoiceResponseResult], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLookupInvoiceResponseResult.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LookupInvoiceResponseResult] {
        let len: Int32 = try readInt(&buf)
        var seq = [LookupInvoiceResponseResult]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLookupInvoiceResponseResult.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringTypeRelay: FfiConverterRustBuffer {
    public static func write(_ value: [String: Relay], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeRelay.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Relay] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Relay]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeRelay.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceTypeFilter: FfiConverterRustBuffer {
    public static func write(_ value: [String: [Filter]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeFilter.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [Filter]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [Filter]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeFilter.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


















































public func initLogger(level: LogLevel) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_func_init_logger(
        FfiConverterTypeLogLevel.lower(level),$0
    )
}
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_nostr_sdk_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_init_logger() != 38847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_aborthandle_abort() != 2978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_aborthandle_is_aborted() != 57233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_add_relay() != 55300) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_add_relay_with_opts() != 23524) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_add_relays() != 45072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_connect() != 931) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_connect_relay() != 33775) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_database() != 35722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_disconnect() != 38433) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_disconnect_relay() != 40874) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_dislike() != 64607) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_file_metadata() != 18115) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_get_events_from() != 62752) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_get_events_of() != 44675) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap() != 18998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_handle_notifications() != 16945) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_like() != 55130) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_reaction() != 48411) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_reconcile() != 3186) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_relay() != 36119) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_relays() != 48003) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_remove_relay() != 222) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_repost() != 27770) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_direct_msg() != 12788) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event() != 10342) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder() != 61169) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder_to() != 7515) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event_to() != 13155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_msg() != 258) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_msg_to() != 48694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_sealed_msg() != 15891) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_set_metadata() != 18910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_shutdown() != 18928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_sign_event_builder() != 40727) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_signer() != 55907) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_start() != 10767) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_stop() != 46184) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscribe() != 7326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id() != 43239) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscription() != 64265) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscriptions() != 25974) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe() != 33797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe_all() != 27202) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_update_difficulty() != 40801) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_zap() != 9277) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_build() != 61424) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_database() != 21061) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_opts() != 22620) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_signer() != 30905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_zapper() != 2114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_get_balance() != 36444) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_get_info() != 38523) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_list_transactions() != 25126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_lookup_invoice() != 11572) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_make_invoice() != 9387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_invoice() != 34897) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_keysend() != 7706) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_negentropyoptions_direction() != 49635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_negentropyoptions_initial_timeout() != 40199) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip46signer_nostr_connect_uri() != 2988) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip46signer_relays() != 17292) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip46signer_signer_public_key() != 60994) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_count() != 29275) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_delete() != 38412) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_event_by_id() != 13951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_event_seen_on_relays() != 50082) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_profile() != 1798) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_query() != 32625) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_save_event() != 2944) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_wipe() != 31282) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_decrypt() != 14262) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_encrypt() != 50191) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_decrypt() != 32958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_encrypt() != 41961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_public_key() != 8592) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_sign_event() != 56917) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_sign_event_builder() != 45366) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_proxy() != 51105) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_timeout() != 18259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_connection_timeout() != 57708) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_difficulty() != 20804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_min_pow() != 54102) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_proxy() != 35233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_relay_limits() != 11682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_req_filters_chunk_size() != 19808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_send_timeout() != 11614) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_skip_disconnected_relays() != 28418) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_timeout() != 10820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_wait_for_send() != 50702) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_wait_for_subscription() != 52599) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_profile_metadata() != 34875) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_profile_name() != 10929) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_profile_public_key() != 31716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_proxy_target() != 3274) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_batch_event() != 50645) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_batch_msg() != 7075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_connect() != 65283) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_count_events_of() != 30433) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_document() != 59362) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_get_events_of() != 9342) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_is_connected() != 18284) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_opts() != 21198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_proxy() != 64699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_queue() != 4051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_reconcile() != 21720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_reconcile_with_items() != 54896) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_send_event() != 31892) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_send_msg() != 36151) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_stats() != 58574) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_status() != 27198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_stop() != 57079) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe() != 49075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe_with_id() != 31136) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscription() != 19975) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscriptions() != 42295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_support_negentropy() != 24573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_terminate() != 8947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe() != 40808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe_all() != 27135) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_url() != 1351) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_attempts() != 52060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_received() != 157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_sent() != 64970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_connected_at() != 17598) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_first_connection_timestamp() != 30824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_latency() != 14031) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_success() != 52759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_uptime() != 29449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags() != 29781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size() != 63930) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_message_max_size() != 9957) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_adjust_retry_sec() != 36994) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_limits() != 10405) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_ping() != 51607) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_pow() != 22672) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_proxy() != 35156) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_read() != 47081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_reconnect() != 48820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_retry_sec() != 58762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_update_adjust_retry_sec() != 1296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_update_pow_difficulty() != 50131) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_update_reconnect() != 23173) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_update_retry_sec() != 43799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_write() != 45946) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_add_relay() != 8583) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_batch_event() != 34872) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_batch_event_to() != 43807) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_batch_msg() != 25834) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_batch_msg_to() != 4853) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_connect() != 1941) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_connect_relay() != 25665) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_database() != 4532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_disconnect() != 50009) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_get_events_from() != 6791) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_get_events_of() != 28280) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_handle_notifications() != 16655) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_reconcile() != 45175) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_reconcile_with_items() != 45346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_relay() != 18458) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_relays() != 1591) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_remove_all_relay() != 18940) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_remove_relay() != 52499) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_send_event() != 64654) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_send_event_to() != 54866) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_send_msg() != 49690) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_send_msg_to() != 21347) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_shutdown() != 56982) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_stop() != 37084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscribe() != 21574) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscribe_with_id() != 1822) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscription() != 46314) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscriptions() != 32801) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_unsubscribe() != 53170) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_unsubscribe_all() != 51928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaysendoptions_skip_disconnected() != 4190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaysendoptions_skip_send_confirmation() != 22060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaysendoptions_timeout() != 16256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_filter() != 17195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_timeout() != 36298) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeoptions_close_on() != 31672) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeoptions_send_opts() != 55685) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_zapdetails_message() != 43166) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_client_new() != 1292) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_client_with_opts() != 35054) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_clientbuilder_new() != 11332) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nwc_new() != 39796) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nwc_with_opts() != 31044) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_negentropyoptions_new() != 15449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip46signer_new() != 61017) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_custom() != 22316) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_ndb() != 25092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_sqlite() != 10843) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_keys() != 51910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_nip46() != 28927) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnectoptions_new() != 35456) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrzapper_nwc() != 62259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_options_new() != 30503) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_profile_new() != 65224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_proxy_new() != 51726) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relay_custom() != 55798) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relay_new() != 3279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relay_with_opts() != 9335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_disable() != 39641) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_new() != 1364) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relayoptions_new() != 32157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaypool_new() != 50786) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaypool_with_database() != 59953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaysendoptions_new() != 31427) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_subscribeautocloseoptions_new() != 39595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_subscribeoptions_new() != 56214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_zapdetails_new() != 18563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_zapentity_event() != 61043) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_zapentity_public_key() != 56616) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_backend() != 43310) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_save_event() != 35737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_has_event_already_been_saved() != 17970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_has_event_already_been_seen() != 32737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_has_event_id_been_deleted() != 18305) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_has_coordinate_been_deleted() != 21374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_event_id_seen() != 31417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_event_seen_on_relays() != 47225) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_event_by_id() != 16633) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_count() != 14898) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_query() != 38513) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_delete() != 55000) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_wipe() != 65517) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle_msg() != 55169) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle() != 9914) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitCustomNostrDatabase()
    uniffiCallbackInitHandleNotification()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all