// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(nostr_sdk_ffiFFI)
import nostr_sdk_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_nostr_sdk_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_nostr_sdk_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}




public protocol AbortHandleProtocol : AnyObject {
    
    /**
     * Abort thread
     */
    func abort() 
    
    /**
     * Check if thread is aborted
     */
    func isAborted()  -> Bool
    
}

open class AbortHandle:
    AbortHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_aborthandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_aborthandle(pointer, $0) }
    }

    

    
    /**
     * Abort thread
     */
open func abort() {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_aborthandle_abort(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Check if thread is aborted
     */
open func isAborted() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_aborthandle_is_aborted(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeAbortHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AbortHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AbortHandle {
        return AbortHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AbortHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AbortHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AbortHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeAbortHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> AbortHandle {
    return try FfiConverterTypeAbortHandle.lift(pointer)
}

public func FfiConverterTypeAbortHandle_lower(_ value: AbortHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAbortHandle.lower(value)
}




public protocol ClientProtocol : AnyObject {
    
    /**
     * Add new relay
     *
     * Return `false` if the relay already exists.
     *
     * If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
     * to avoid to set pool subscriptions.
     *
     * This method use previously set or default `Options` to configure the `Relay` (ex. set proxy, set min POW, set relay limits, ...).
     * To use custom `RelayOptions`, check `add_relay_with_opts` method.
     *
     * Connection is **NOT** automatically started with relay, remember to call `connect` method!
     */
    func addRelay(url: String) async throws  -> Bool
    
    /**
     * Add new relay with custom `RelayOptions`
     *
     * Return `false` if the relay already exists.
     *
     * If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
     * to avoid to set pool subscriptions.
     *
     * Connection is **NOT** automatically started with relay, remember to call `connect` method!
     */
    func addRelayWithOpts(url: String, opts: RelayOptions) async throws  -> Bool
    
    /**
     * Add multiple relays
     *
     * If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
     * to avoid to set pool subscriptions.
     *
     * Connection is **NOT** automatically started with relays, remember to call `connect` method!
     */
    func addRelays(relays: [String]) async throws 
    
    /**
     * Get blacklist
     */
    func blacklist()  -> RelayBlacklist
    
    /**
     * Connect to all added relays
     */
    func connect() async 
    
    /**
     * Connect to a previously added relay
     */
    func connectRelay(url: String) async throws 
    
    /**
     * Connect to all added relays
     *
     * Try to connect to the relays and wait for them to be connected at most for the specified `timeout`.
     * The code continues if the `timeout` is reached or if all relays connect.
     */
    func connectWithTimeout(timeout: TimeInterval) async 
    
    func database()  -> NostrDatabase
    
    func disconnect() async throws 
    
    func disconnectRelay(url: String) async throws 
    
    /**
     * Disike event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
    func dislike(event: Event) async throws  -> EventId
    
    func fileMetadata(description: String, metadata: FileMetadata) async throws  -> EventId
    
    /**
     * Get events of filters from specific relays
     *
     * Get events both from **local database** and **relays**
     */
    func getEventsFrom(urls: [String], filters: [Filter], timeout: TimeInterval?) async throws  -> [Event]
    
    func getEventsOf(filters: [Filter], timeout: TimeInterval?) async throws  -> [Event]
    
    /**
     * Gift Wrap
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
    func giftWrap(receiver: PublicKey, rumor: EventBuilder, expiration: Timestamp?) async throws 
    
    /**
     * Handle notifications
     *
     * **This method spawn a thread**, so ensure to keep up the app after calling this (if needed).
     *
     * <div class="warning">Python bindings needs to call `uniffi_set_event_loop(asyncio.get_running_loop())` before this method!</div>
     */
    func handleNotifications(handler: HandleNotification) throws  -> AbortHandle
    
    /**
     * Like event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
    func like(event: Event) async throws  -> EventId
    
    /**
     * Mute event IDs
     *
     * Add event IDs to blacklist
     *
     * <div class="warning">Mute list event is not currently created/updated!</div>
     */
    func muteIds(ids: [EventId]) async 
    
    /**
     * Mute public keys
     *
     * Add public keys to blacklist
     *
     * <div class="warning">Mute list event is not currently created/updated!</div>
     */
    func mutePublicKeys(publicKeys: [PublicKey]) async 
    
    /**
     * React to an [`Event`]
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
    func reaction(event: Event, reaction: String) async throws  -> EventId
    
    func reconcile(filter: Filter, opts: NegentropyOptions) async throws 
    
    func relay(url: String) async throws  -> Relay
    
    func relays() async  -> [String: Relay]
    
    func removeRelay(url: String) async throws 
    
    /**
     * Repost
     */
    func repost(event: Event, relayUrl: String?) async throws  -> EventId
    
    /**
     * Encrypted direct msg
     *
     * <div class="warning"><strong>Unsecure!</strong> Use `send_private_msg` instead!</div>
     *
     * <https://github.com/nostr-protocol/nips/blob/master/04.md>
     */
    func sendDirectMsg(receiver: PublicKey, msg: String, reply: EventId?) async throws  -> EventId
    
    func sendEvent(event: Event) async throws  -> EventId
    
    /**
     * Take an [`EventBuilder`], sign it by using the [`NostrSigner`] and broadcast to all relays.
     *
     * Rise an error if the [`NostrSigner`] is not set.
     */
    func sendEventBuilder(builder: EventBuilder) async throws  -> EventId
    
    /**
     * Take an [`EventBuilder`], sign it by using the [`NostrSigner`] and broadcast to specific relays.
     *
     * Rise an error if the [`NostrSigner`] is not set.
     */
    func sendEventBuilderTo(urls: [String], builder: EventBuilder) async throws  -> EventId
    
    func sendEventTo(urls: [String], event: Event) async throws  -> EventId
    
    func sendMsg(msg: ClientMessage) async throws 
    
    func sendMsgTo(urls: [String], msg: ClientMessage) async throws 
    
    /**
     * Send private direct message
     *
     * <https://github.com/nostr-protocol/nips/blob/master/17.md>
     */
    func sendPrivateMsg(receiver: PublicKey, message: String, replyTo: EventId?) async throws 
    
    func setMetadata(metadata: Metadata) async throws  -> EventId
    
    func shutdown() async throws 
    
    /**
     * Signs the `EventBuilder` into an `Event` using the `NostrSigner`
     */
    func signEventBuilder(builder: EventBuilder) async throws  -> Event
    
    func signer() async throws  -> NostrSigner
    
    func start() async 
    
    func stop() async throws 
    
    /**
     * Subscribe to filters to all connected relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
    func subscribe(filters: [Filter], opts: SubscribeAutoCloseOptions?) async  -> String
    
    /**
     * Subscribe to filters to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
    func subscribeTo(urls: [String], filters: [Filter], opts: SubscribeAutoCloseOptions?) async throws  -> String
    
    /**
     * Subscribe to filters with custom subscription ID to all connected relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
    func subscribeWithId(id: String, filters: [Filter], opts: SubscribeAutoCloseOptions?) async 
    
    /**
     * Subscribe to filters with custom subscription ID to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
    func subscribeWithIdTo(urls: [String], id: String, filters: [Filter], opts: SubscribeAutoCloseOptions?) async throws 
    
    func subscription(id: String) async  -> [Filter]?
    
    func subscriptions() async  -> [String: [Filter]]
    
    /**
     * Unmute event IDs
     *
     * Remove event IDs from blacklist
     *
     * <div class="warning">Mute list event is not currently created/updated!</div>
     */
    func unmuteIds(ids: [EventId]) async 
    
    /**
     * Unmute public keys
     *
     * Remove public keys from blacklist
     *
     * <div class="warning">Mute list event is not currently created/updated!</div>
     */
    func unmutePublicKeys(publicKeys: [PublicKey]) async 
    
    func unsubscribe(subscriptionId: String) async 
    
    func unsubscribeAll() async 
    
    /**
     * Update default difficulty for new `Event`
     */
    func updateDifficulty(difficulty: UInt8) 
    
    /**
     * Update minimum POW difficulty for received events
     *
     * Events with a POW lower than the current value will be ignored to prevent resources exhaustion.
     */
    func updateMinPowDifficulty(difficulty: UInt8) 
    
    /**
     * Send a Zap!
     */
    func zap(to: ZapEntity, satoshi: UInt64, details: ZapDetails?) async throws 
    
}

open class Client:
    ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_client(self.pointer, $0) }
    }
public convenience init(signer: NostrSigner? = nil) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_client_new(
        FfiConverterOptionTypeNostrSigner.lower(signer),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_client(pointer, $0) }
    }

    
public static func withOpts(signer: NostrSigner?, opts: Options) -> Client {
    return try!  FfiConverterTypeClient.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_client_with_opts(
        FfiConverterOptionTypeNostrSigner.lower(signer),
        FfiConverterTypeOptions.lower(opts),$0
    )
})
}
    

    
    /**
     * Add new relay
     *
     * Return `false` if the relay already exists.
     *
     * If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
     * to avoid to set pool subscriptions.
     *
     * This method use previously set or default `Options` to configure the `Relay` (ex. set proxy, set min POW, set relay limits, ...).
     * To use custom `RelayOptions`, check `add_relay_with_opts` method.
     *
     * Connection is **NOT** automatically started with relay, remember to call `connect` method!
     */
open func addRelay(url: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_add_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Add new relay with custom `RelayOptions`
     *
     * Return `false` if the relay already exists.
     *
     * If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
     * to avoid to set pool subscriptions.
     *
     * Connection is **NOT** automatically started with relay, remember to call `connect` method!
     */
open func addRelayWithOpts(url: String, opts: RelayOptions)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_add_relay_with_opts(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterTypeRelayOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Add multiple relays
     *
     * If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
     * to avoid to set pool subscriptions.
     *
     * Connection is **NOT** automatically started with relays, remember to call `connect` method!
     */
open func addRelays(relays: [String])async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_add_relays(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(relays)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get blacklist
     */
open func blacklist() -> RelayBlacklist {
    return try!  FfiConverterTypeRelayBlacklist.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_blacklist(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Connect to all added relays
     */
open func connect()async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_connect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Connect to a previously added relay
     */
open func connectRelay(url: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_connect_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Connect to all added relays
     *
     * Try to connect to the relays and wait for them to be connected at most for the specified `timeout`.
     * The code continues if the `timeout` is reached or if all relays connect.
     */
open func connectWithTimeout(timeout: TimeInterval)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_connect_with_timeout(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func database() -> NostrDatabase {
    return try!  FfiConverterTypeNostrDatabase.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_database(self.uniffiClonePointer(),$0
    )
})
}
    
open func disconnect()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_disconnect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func disconnectRelay(url: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_disconnect_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Disike event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
open func dislike(event: Event)async throws  -> EventId {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_dislike(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func fileMetadata(description: String, metadata: FileMetadata)async throws  -> EventId {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_file_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(description),FfiConverterTypeFileMetadata_lower(metadata)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get events of filters from specific relays
     *
     * Get events both from **local database** and **relays**
     */
open func getEventsFrom(urls: [String], filters: [Filter], timeout: TimeInterval?)async throws  -> [Event] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_get_events_from(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterOptionDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func getEventsOf(filters: [Filter], timeout: TimeInterval?)async throws  -> [Event] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_get_events_of(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters),FfiConverterOptionDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Gift Wrap
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
open func giftWrap(receiver: PublicKey, rumor: EventBuilder, expiration: Timestamp?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_gift_wrap(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(receiver),FfiConverterTypeEventBuilder_lower(rumor),FfiConverterOptionTypeTimestamp.lower(expiration)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Handle notifications
     *
     * **This method spawn a thread**, so ensure to keep up the app after calling this (if needed).
     *
     * <div class="warning">Python bindings needs to call `uniffi_set_event_loop(asyncio.get_running_loop())` before this method!</div>
     */
open func handleNotifications(handler: HandleNotification)throws  -> AbortHandle {
    return try  FfiConverterTypeAbortHandle.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_client_handle_notifications(self.uniffiClonePointer(),
        FfiConverterTypeHandleNotification.lower(handler),$0
    )
})
}
    
    /**
     * Like event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
open func like(event: Event)async throws  -> EventId {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_like(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Mute event IDs
     *
     * Add event IDs to blacklist
     *
     * <div class="warning">Mute list event is not currently created/updated!</div>
     */
open func muteIds(ids: [EventId])async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_mute_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeEventId.lower(ids)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Mute public keys
     *
     * Add public keys to blacklist
     *
     * <div class="warning">Mute list event is not currently created/updated!</div>
     */
open func mutePublicKeys(publicKeys: [PublicKey])async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_mute_public_keys(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypePublicKey.lower(publicKeys)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * React to an [`Event`]
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
open func reaction(event: Event, reaction: String)async throws  -> EventId {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_reaction(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event),FfiConverterString.lower(reaction)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func reconcile(filter: Filter, opts: NegentropyOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_reconcile(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterTypeNegentropyOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func relay(url: String)async throws  -> Relay {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRelay.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func relays()async  -> [String: Relay] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_relays(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringTypeRelay.lift,
            errorHandler: nil
            
        )
}
    
open func removeRelay(url: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_remove_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Repost
     */
open func repost(event: Event, relayUrl: String?)async throws  -> EventId {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_repost(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event),FfiConverterOptionString.lower(relayUrl)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Encrypted direct msg
     *
     * <div class="warning"><strong>Unsecure!</strong> Use `send_private_msg` instead!</div>
     *
     * <https://github.com/nostr-protocol/nips/blob/master/04.md>
     */
open func sendDirectMsg(receiver: PublicKey, msg: String, reply: EventId?)async throws  -> EventId {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_direct_msg(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(receiver),FfiConverterString.lower(msg),FfiConverterOptionTypeEventId.lower(reply)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func sendEvent(event: Event)async throws  -> EventId {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Take an [`EventBuilder`], sign it by using the [`NostrSigner`] and broadcast to all relays.
     *
     * Rise an error if the [`NostrSigner`] is not set.
     */
open func sendEventBuilder(builder: EventBuilder)async throws  -> EventId {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventBuilder_lower(builder)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Take an [`EventBuilder`], sign it by using the [`NostrSigner`] and broadcast to specific relays.
     *
     * Rise an error if the [`NostrSigner`] is not set.
     */
open func sendEventBuilderTo(urls: [String], builder: EventBuilder)async throws  -> EventId {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterTypeEventBuilder_lower(builder)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func sendEventTo(urls: [String], event: Event)async throws  -> EventId {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_event_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func sendMsg(msg: ClientMessage)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_msg(
                    self.uniffiClonePointer(),
                    FfiConverterTypeClientMessage_lower(msg)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func sendMsgTo(urls: [String], msg: ClientMessage)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_msg_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterTypeClientMessage_lower(msg)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send private direct message
     *
     * <https://github.com/nostr-protocol/nips/blob/master/17.md>
     */
open func sendPrivateMsg(receiver: PublicKey, message: String, replyTo: EventId? = nil)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_private_msg(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(receiver),FfiConverterString.lower(message),FfiConverterOptionTypeEventId.lower(replyTo)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func setMetadata(metadata: Metadata)async throws  -> EventId {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_set_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMetadata_lower(metadata)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func shutdown()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_shutdown(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Signs the `EventBuilder` into an `Event` using the `NostrSigner`
     */
open func signEventBuilder(builder: EventBuilder)async throws  -> Event {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_sign_event_builder(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventBuilder_lower(builder)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvent_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func signer()async throws  -> NostrSigner {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_signer(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNostrSigner.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func start()async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_start(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func stop()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_stop(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Subscribe to filters to all connected relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
open func subscribe(filters: [Filter], opts: SubscribeAutoCloseOptions? = nil)async  -> String {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscribe(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters),FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Subscribe to filters to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
open func subscribeTo(urls: [String], filters: [Filter], opts: SubscribeAutoCloseOptions? = nil)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscribe_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Subscribe to filters with custom subscription ID to all connected relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
open func subscribeWithId(id: String, filters: [Filter], opts: SubscribeAutoCloseOptions? = nil)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscribe_with_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Subscribe to filters with custom subscription ID to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
open func subscribeWithIdTo(urls: [String], id: String, filters: [Filter], opts: SubscribeAutoCloseOptions? = nil)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscribe_with_id_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterString.lower(id),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func subscription(id: String)async  -> [Filter]? {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscription(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
open func subscriptions()async  -> [String: [Filter]] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscriptions(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Unmute event IDs
     *
     * Remove event IDs from blacklist
     *
     * <div class="warning">Mute list event is not currently created/updated!</div>
     */
open func unmuteIds(ids: [EventId])async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_unmute_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeEventId.lower(ids)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Unmute public keys
     *
     * Remove public keys from blacklist
     *
     * <div class="warning">Mute list event is not currently created/updated!</div>
     */
open func unmutePublicKeys(publicKeys: [PublicKey])async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_unmute_public_keys(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypePublicKey.lower(publicKeys)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func unsubscribe(subscriptionId: String)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(subscriptionId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func unsubscribeAll()async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe_all(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Update default difficulty for new `Event`
     */
open func updateDifficulty(difficulty: UInt8) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_update_difficulty(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
}
}
    
    /**
     * Update minimum POW difficulty for received events
     *
     * Events with a POW lower than the current value will be ignored to prevent resources exhaustion.
     */
open func updateMinPowDifficulty(difficulty: UInt8) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_update_min_pow_difficulty(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
}
}
    
    /**
     * Send a Zap!
     */
open func zap(to: ZapEntity, satoshi: UInt64, details: ZapDetails?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_zap(
                    self.uniffiClonePointer(),
                    FfiConverterTypeZapEntity.lower(to),FfiConverterUInt64.lower(satoshi),FfiConverterOptionTypeZapDetails.lower(details)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

}

public struct FfiConverterTypeClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}




public protocol ClientBuilderProtocol : AnyObject {
    
    /**
     * Build [`Client`]
     */
    func build()  -> Client
    
    func database(database: NostrDatabase)  -> ClientBuilder
    
    /**
     * Set opts
     */
    func opts(opts: Options)  -> ClientBuilder
    
    func signer(signer: NostrSigner)  -> ClientBuilder
    
    func zapper(zapper: NostrZapper)  -> ClientBuilder
    
}

open class ClientBuilder:
    ClientBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_clientbuilder(self.pointer, $0) }
    }
    /**
     * New client builder
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_clientbuilder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_clientbuilder(pointer, $0) }
    }

    

    
    /**
     * Build [`Client`]
     */
open func build() -> Client {
    return try!  FfiConverterTypeClient.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_build(self.uniffiClonePointer(),$0
    )
})
}
    
open func database(database: NostrDatabase) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_database(self.uniffiClonePointer(),
        FfiConverterTypeNostrDatabase.lower(database),$0
    )
})
}
    
    /**
     * Set opts
     */
open func opts(opts: Options) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_opts(self.uniffiClonePointer(),
        FfiConverterTypeOptions.lower(opts),$0
    )
})
}
    
open func signer(signer: NostrSigner) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_signer(self.uniffiClonePointer(),
        FfiConverterTypeNostrSigner.lower(signer),$0
    )
})
}
    
open func zapper(zapper: NostrZapper) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_zapper(self.uniffiClonePointer(),
        FfiConverterTypeNostrZapper.lower(zapper),$0
    )
})
}
    

}

public struct FfiConverterTypeClientBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
        return ClientBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
    return try FfiConverterTypeClientBuilder.lift(pointer)
}

public func FfiConverterTypeClientBuilder_lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientBuilder.lower(value)
}




public protocol CustomNostrDatabaseProtocol : AnyObject {
    
    /**
     * Name of backend
     */
    func backend()  -> String
    
    /**
     * Save [`Event`] into store
     *
     * Return `true` if event was successfully saved into database.
     *
     * **This method assume that [`Event`] was already verified**
     */
    func saveEvent(event: Event) async throws  -> Bool
    
    /**
     * Check if [`Event`] has already been saved
     */
    func hasEventAlreadyBeenSaved(eventId: EventId) async throws  -> Bool
    
    /**
     * Check if [`EventId`] has already been seen
     */
    func hasEventAlreadyBeenSeen(eventId: EventId) async throws  -> Bool
    
    /**
     * Check if [`EventId`] has been deleted
     */
    func hasEventIdBeenDeleted(eventId: EventId) async throws  -> Bool
    
    /**
     * Check if event with [`Coordinate`] has been deleted before [`Timestamp`]
     */
    func hasCoordinateBeenDeleted(coordinate: Coordinate, timestamp: Timestamp) async throws  -> Bool
    
    /**
     * Set [`EventId`] as seen by relay
     *
     * Useful for NIP65 (aka gossip)
     */
    func eventIdSeen(eventId: EventId, relayUrl: String) async throws 
    
    /**
     * Get list of relays that have seen the [`EventId`]
     */
    func eventSeenOnRelays(eventId: EventId) async throws  -> [String]?
    
    /**
     * Get [`Event`] by [`EventId`]
     */
    func eventById(eventId: EventId) async throws  -> Event
    
    /**
     * Count number of [`Event`] found by filters
     *
     * Use `Filter::new()` or `Filter::default()` to count all events.
     */
    func count(filters: [Filter]) async throws  -> UInt64
    
    /**
     * Query store with filters
     */
    func query(filters: [Filter]) async throws  -> [Event]
    
    /**
     * Delete all events that match the `Filter`
     */
    func delete(filter: Filter) async throws 
    
    /**
     * Wipe all data
     */
    func wipe() async throws 
    
}

open class CustomNostrDatabase:
    CustomNostrDatabaseProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_customnostrdatabase(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_customnostrdatabase(pointer, $0) }
    }

    

    
    /**
     * Name of backend
     */
open func backend() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_backend(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Save [`Event`] into store
     *
     * Return `true` if event was successfully saved into database.
     *
     * **This method assume that [`Event`] was already verified**
     */
open func saveEvent(event: Event)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_save_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Check if [`Event`] has already been saved
     */
open func hasEventAlreadyBeenSaved(eventId: EventId)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_has_event_already_been_saved(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Check if [`EventId`] has already been seen
     */
open func hasEventAlreadyBeenSeen(eventId: EventId)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_has_event_already_been_seen(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Check if [`EventId`] has been deleted
     */
open func hasEventIdBeenDeleted(eventId: EventId)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_has_event_id_been_deleted(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Check if event with [`Coordinate`] has been deleted before [`Timestamp`]
     */
open func hasCoordinateBeenDeleted(coordinate: Coordinate, timestamp: Timestamp)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_has_coordinate_been_deleted(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCoordinate_lower(coordinate),FfiConverterTypeTimestamp_lower(timestamp)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Set [`EventId`] as seen by relay
     *
     * Useful for NIP65 (aka gossip)
     */
open func eventIdSeen(eventId: EventId, relayUrl: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_event_id_seen(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId),FfiConverterString.lower(relayUrl)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get list of relays that have seen the [`EventId`]
     */
open func eventSeenOnRelays(eventId: EventId)async throws  -> [String]? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_event_seen_on_relays(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get [`Event`] by [`EventId`]
     */
open func eventById(eventId: EventId)async throws  -> Event {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_event_by_id(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvent_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Count number of [`Event`] found by filters
     *
     * Use `Filter::new()` or `Filter::default()` to count all events.
     */
open func count(filters: [Filter])async throws  -> UInt64 {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_count(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Query store with filters
     */
open func query(filters: [Filter])async throws  -> [Event] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_query(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Delete all events that match the `Filter`
     */
open func delete(filter: Filter)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_delete(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Wipe all data
     */
open func wipe()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_wipe(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

}

public struct FfiConverterTypeCustomNostrDatabase: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CustomNostrDatabase

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CustomNostrDatabase {
        return CustomNostrDatabase(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CustomNostrDatabase) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CustomNostrDatabase {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CustomNostrDatabase, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeCustomNostrDatabase_lift(_ pointer: UnsafeMutableRawPointer) throws -> CustomNostrDatabase {
    return try FfiConverterTypeCustomNostrDatabase.lift(pointer)
}

public func FfiConverterTypeCustomNostrDatabase_lower(_ value: CustomNostrDatabase) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCustomNostrDatabase.lower(value)
}




public protocol HandleNotification : AnyObject {
    
    func handleMsg(relayUrl: String, msg: RelayMessage) async 
    
    func handle(relayUrl: String, subscriptionId: String, event: Event) async 
    
}

open class HandleNotificationImpl:
    HandleNotification {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_handlenotification(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_handlenotification(pointer, $0) }
    }

    

    
open func handleMsg(relayUrl: String, msg: RelayMessage)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_handlenotification_handle_msg(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(relayUrl),FfiConverterTypeRelayMessage_lower(msg)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func handle(relayUrl: String, subscriptionId: String, event: Event)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_handlenotification_handle(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(relayUrl),FfiConverterString.lower(subscriptionId),FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceHandleNotification {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceHandleNotification = UniffiVTableCallbackInterfaceHandleNotification(
        handleMsg: { (
            uniffiHandle: UInt64,
            relayUrl: RustBuffer,
            msg: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeHandleNotification.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.handleMsg(
                     relayUrl: try FfiConverterString.lift(relayUrl),
                     msg: try FfiConverterTypeRelayMessage_lift(msg)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        handle: { (
            uniffiHandle: UInt64,
            relayUrl: RustBuffer,
            subscriptionId: RustBuffer,
            event: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeHandleNotification.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.handle(
                     relayUrl: try FfiConverterString.lift(relayUrl),
                     subscriptionId: try FfiConverterString.lift(subscriptionId),
                     event: try FfiConverterTypeEvent_lift(event)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeHandleNotification.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HandleNotification: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitHandleNotification() {
    uniffi_nostr_sdk_ffi_fn_init_callback_vtable_handlenotification(&UniffiCallbackInterfaceHandleNotification.vtable)
}

public struct FfiConverterTypeHandleNotification: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<HandleNotification>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HandleNotification

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HandleNotification {
        return HandleNotificationImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HandleNotification) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HandleNotification {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HandleNotification, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeHandleNotification_lift(_ pointer: UnsafeMutableRawPointer) throws -> HandleNotification {
    return try FfiConverterTypeHandleNotification.lift(pointer)
}

public func FfiConverterTypeHandleNotification_lower(_ value: HandleNotification) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHandleNotification.lower(value)
}




/**
 * Nostr Wallet Connect client
 */
public protocol NwcProtocol : AnyObject {
    
    /**
     * Get balance
     */
    func getBalance() async throws  -> UInt64
    
    /**
     * Get info
     */
    func getInfo() async throws  -> GetInfoResponseResult
    
    /**
     * List transactions
     */
    func listTransactions(params: ListTransactionsRequestParams) async throws  -> [LookupInvoiceResponseResult]
    
    /**
     * Lookup invoice
     */
    func lookupInvoice(params: LookupInvoiceRequestParams) async throws  -> LookupInvoiceResponseResult
    
    /**
     * Create invoice
     */
    func makeInvoice(params: MakeInvoiceRequestParams) async throws  -> MakeInvoiceResponseResult
    
    /**
     * Pay invoice
     */
    func payInvoice(invoice: String) async throws  -> String
    
    /**
     * Pay keysend
     */
    func payKeysend(params: PayKeysendRequestParams) async throws  -> PayKeysendResponseResult
    
}

/**
 * Nostr Wallet Connect client
 */
open class Nwc:
    NwcProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nwc(self.pointer, $0) }
    }
    /**
     * Compose new `NWC` client
     */
public convenience init(uri: NostrWalletConnectUri) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nwc_new(
        FfiConverterTypeNostrWalletConnectURI_lower(uri),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nwc(pointer, $0) }
    }

    
    /**
     * Compose new `NWC` client with `NostrWalletConnectOptions`
     */
public static func withOpts(uri: NostrWalletConnectUri, opts: NostrWalletConnectOptions) -> Nwc {
    return try!  FfiConverterTypeNWC.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nwc_with_opts(
        FfiConverterTypeNostrWalletConnectURI_lower(uri),
        FfiConverterTypeNostrWalletConnectOptions.lower(opts),$0
    )
})
}
    

    
    /**
     * Get balance
     */
open func getBalance()async throws  -> UInt64 {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_get_balance(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get info
     */
open func getInfo()async throws  -> GetInfoResponseResult {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_get_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetInfoResponseResult_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * List transactions
     */
open func listTransactions(params: ListTransactionsRequestParams)async throws  -> [LookupInvoiceResponseResult] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_list_transactions(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListTransactionsRequestParams_lower(params)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeLookupInvoiceResponseResult.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Lookup invoice
     */
open func lookupInvoice(params: LookupInvoiceRequestParams)async throws  -> LookupInvoiceResponseResult {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_lookup_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLookupInvoiceRequestParams_lower(params)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLookupInvoiceResponseResult_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Create invoice
     */
open func makeInvoice(params: MakeInvoiceRequestParams)async throws  -> MakeInvoiceResponseResult {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_make_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMakeInvoiceRequestParams_lower(params)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMakeInvoiceResponseResult_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Pay invoice
     */
open func payInvoice(invoice: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_pay_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(invoice)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Pay keysend
     */
open func payKeysend(params: PayKeysendRequestParams)async throws  -> PayKeysendResponseResult {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_pay_keysend(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayKeysendRequestParams_lower(params)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayKeysendResponseResult_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

}

public struct FfiConverterTypeNWC: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nwc

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nwc {
        return Nwc(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nwc) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nwc {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nwc, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNWC_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nwc {
    return try FfiConverterTypeNWC.lift(pointer)
}

public func FfiConverterTypeNWC_lower(_ value: Nwc) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNWC.lower(value)
}




public protocol NegentropyOptionsProtocol : AnyObject {
    
    /**
     * Negentropy Sync direction (default: down)
     */
    func direction(direction: NegentropyDirection)  -> NegentropyOptions
    
    /**
     * Timeout to check if negentropy it's supported (default: 10 secs)
     */
    func initialTimeout(timeout: TimeInterval)  -> NegentropyOptions
    
}

open class NegentropyOptions:
    NegentropyOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_negentropyoptions(self.pointer, $0) }
    }
    /**
     * New default options
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_negentropyoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_negentropyoptions(pointer, $0) }
    }

    

    
    /**
     * Negentropy Sync direction (default: down)
     */
open func direction(direction: NegentropyDirection) -> NegentropyOptions {
    return try!  FfiConverterTypeNegentropyOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_negentropyoptions_direction(self.uniffiClonePointer(),
        FfiConverterTypeNegentropyDirection.lower(direction),$0
    )
})
}
    
    /**
     * Timeout to check if negentropy it's supported (default: 10 secs)
     */
open func initialTimeout(timeout: TimeInterval) -> NegentropyOptions {
    return try!  FfiConverterTypeNegentropyOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_negentropyoptions_initial_timeout(self.uniffiClonePointer(),
        FfiConverterDuration.lower(timeout),$0
    )
})
}
    

}

public struct FfiConverterTypeNegentropyOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NegentropyOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NegentropyOptions {
        return NegentropyOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NegentropyOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NegentropyOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NegentropyOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNegentropyOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> NegentropyOptions {
    return try FfiConverterTypeNegentropyOptions.lift(pointer)
}

public func FfiConverterTypeNegentropyOptions_lower(_ value: NegentropyOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNegentropyOptions.lower(value)
}




public protocol Nip46SignerProtocol : AnyObject {
    
    /**
     * Get Nostr Connect URI in **bunker** format.
     */
    func nostrConnectUri() async  -> NostrConnectUri
    
    /**
     * Get signer relays
     */
    func relays() async  -> [String]
    
    /**
     * Get signer public key
     */
    func signerPublicKey()  -> PublicKey
    
}

open class Nip46Signer:
    Nip46SignerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nip46signer(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nip46signer(pointer, $0) }
    }

    
    /**
     * Construct Nostr Connect client
     */
public static func `init`(uri: NostrConnectUri, appKeys: Keys, timeout: TimeInterval, opts: RelayOptions?)async throws  -> Nip46Signer {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_constructor_nip46signer_init(FfiConverterTypeNostrConnectURI_lower(uri),FfiConverterTypeKeys_lower(appKeys),FfiConverterDuration.lower(timeout),FfiConverterOptionTypeRelayOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNip46Signer.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

    
    /**
     * Get Nostr Connect URI in **bunker** format.
     */
open func nostrConnectUri()async  -> NostrConnectUri {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nip46signer_nostr_connect_uri(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNostrConnectURI_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get signer relays
     */
open func relays()async  -> [String] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nip46signer_relays(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get signer public key
     */
open func signerPublicKey() -> PublicKey {
    return try!  FfiConverterTypePublicKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip46signer_signer_public_key(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeNip46Signer: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip46Signer

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip46Signer {
        return Nip46Signer(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip46Signer) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip46Signer {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip46Signer, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNip46Signer_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip46Signer {
    return try FfiConverterTypeNip46Signer.lift(pointer)
}

public func FfiConverterTypeNip46Signer_lower(_ value: Nip46Signer) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip46Signer.lower(value)
}




/**
 * Nostr Connect Signer
 *
 * Signer that listen for requests from client, handle them and send the response.
 *
 * <https://github.com/nostr-protocol/nips/blob/master/46.md>
 */
public protocol NostrConnectRemoteSignerProtocol : AnyObject {
    
    /**
     * Get Nostr Connect URI
     */
    func nostrConnectUri() async  -> NostrConnectUri
    
    /**
     * Get signer relays
     */
    func relays() async  -> [String]
    
    /**
     * Serve signer
     */
    func serve(actions: NostrConnectSignerActions) async throws 
    
}

/**
 * Nostr Connect Signer
 *
 * Signer that listen for requests from client, handle them and send the response.
 *
 * <https://github.com/nostr-protocol/nips/blob/master/46.md>
 */
open class NostrConnectRemoteSigner:
    NostrConnectRemoteSignerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrconnectremotesigner(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrconnectremotesigner(pointer, $0) }
    }

    
    /**
     * Construct remote signer from client URI (`nostrconnect://..`)
     */
public static func fromUri(uri: NostrConnectUri, secretKey: SecretKey, secret: String? = nil, opts: RelayOptions? = nil)async throws  -> NostrConnectRemoteSigner {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_constructor_nostrconnectremotesigner_from_uri(FfiConverterTypeNostrConnectURI_lower(uri),FfiConverterTypeSecretKey_lower(secretKey),FfiConverterOptionString.lower(secret),FfiConverterOptionTypeRelayOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNostrConnectRemoteSigner.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
public static func `init`(secretKey: SecretKey, relays: [String], secret: String? = nil, opts: RelayOptions? = nil)async throws  -> NostrConnectRemoteSigner {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_constructor_nostrconnectremotesigner_init(FfiConverterTypeSecretKey_lower(secretKey),FfiConverterSequenceString.lower(relays),FfiConverterOptionString.lower(secret),FfiConverterOptionTypeRelayOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNostrConnectRemoteSigner.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

    
    /**
     * Get Nostr Connect URI
     */
open func nostrConnectUri()async  -> NostrConnectUri {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrconnectremotesigner_nostr_connect_uri(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNostrConnectURI_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get signer relays
     */
open func relays()async  -> [String] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrconnectremotesigner_relays(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Serve signer
     */
open func serve(actions: NostrConnectSignerActions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrconnectremotesigner_serve(
                    self.uniffiClonePointer(),
                    FfiConverterTypeNostrConnectSignerActions.lower(actions)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

}

public struct FfiConverterTypeNostrConnectRemoteSigner: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrConnectRemoteSigner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectRemoteSigner {
        return NostrConnectRemoteSigner(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrConnectRemoteSigner) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectRemoteSigner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrConnectRemoteSigner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrConnectRemoteSigner_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectRemoteSigner {
    return try FfiConverterTypeNostrConnectRemoteSigner.lift(pointer)
}

public func FfiConverterTypeNostrConnectRemoteSigner_lower(_ value: NostrConnectRemoteSigner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrConnectRemoteSigner.lower(value)
}




public protocol NostrConnectSignerActions : AnyObject {
    
    /**
     * Approve
     */
    func approve(req: Nip46Request)  -> Bool
    
}

open class NostrConnectSignerActionsImpl:
    NostrConnectSignerActions {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrconnectsigneractions(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrconnectsigneractions(pointer, $0) }
    }

    

    
    /**
     * Approve
     */
open func approve(req: Nip46Request) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrconnectsigneractions_approve(self.uniffiClonePointer(),
        FfiConverterTypeNip46Request_lower(req),$0
    )
})
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceNostrConnectSignerActions {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceNostrConnectSignerActions = UniffiVTableCallbackInterfaceNostrConnectSignerActions(
        approve: { (
            uniffiHandle: UInt64,
            req: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterTypeNostrConnectSignerActions.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.approve(
                     req: try FfiConverterTypeNip46Request_lift(req)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeNostrConnectSignerActions.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface NostrConnectSignerActions: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitNostrConnectSignerActions() {
    uniffi_nostr_sdk_ffi_fn_init_callback_vtable_nostrconnectsigneractions(&UniffiCallbackInterfaceNostrConnectSignerActions.vtable)
}

public struct FfiConverterTypeNostrConnectSignerActions: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<NostrConnectSignerActions>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrConnectSignerActions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectSignerActions {
        return NostrConnectSignerActionsImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrConnectSignerActions) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectSignerActions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrConnectSignerActions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrConnectSignerActions_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectSignerActions {
    return try FfiConverterTypeNostrConnectSignerActions.lift(pointer)
}

public func FfiConverterTypeNostrConnectSignerActions_lower(_ value: NostrConnectSignerActions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrConnectSignerActions.lower(value)
}




public protocol NostrDatabaseProtocol : AnyObject {
    
    func count(filters: [Filter]) async throws  -> UInt64
    
    /**
     * Delete all events that match the `Filter`
     */
    func delete(filter: Filter) async throws 
    
    /**
     * Get [`Event`] by [`EventId`]
     */
    func eventById(eventId: EventId) async throws  -> Event
    
    /**
     * Get list of relays that have seen the [`EventId`]
     */
    func eventSeenOnRelays(eventId: EventId) async throws  -> [String]?
    
    func profile(publicKey: PublicKey) async throws  -> Profile
    
    func query(filters: [Filter]) async throws  -> [Event]
    
    /**
     * Save [`Event`] into store
     *
     * Return `true` if event was successfully saved into database.
     */
    func saveEvent(event: Event) async throws  -> Bool
    
    /**
     * Wipe all data
     */
    func wipe() async throws 
    
}

open class NostrDatabase:
    NostrDatabaseProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrdatabase(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrdatabase(pointer, $0) }
    }

    
public static func custom(database: CustomNostrDatabase) -> NostrDatabase {
    return try!  FfiConverterTypeNostrDatabase.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_custom(
        FfiConverterTypeCustomNostrDatabase.lower(database),$0
    )
})
}
    
    /**
     * [`nostrdb`](https://github.com/damus-io/nostrdb) backend
     */
public static func ndb(path: String)throws  -> NostrDatabase {
    return try  FfiConverterTypeNostrDatabase.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_ndb(
        FfiConverterString.lower(path),$0
    )
})
}
    
public static func sqlite(path: String)async throws  -> NostrDatabase {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_sqlite(FfiConverterString.lower(path)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNostrDatabase.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

    
open func count(filters: [Filter])async throws  -> UInt64 {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_count(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Delete all events that match the `Filter`
     */
open func delete(filter: Filter)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_delete(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get [`Event`] by [`EventId`]
     */
open func eventById(eventId: EventId)async throws  -> Event {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_event_by_id(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvent_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get list of relays that have seen the [`EventId`]
     */
open func eventSeenOnRelays(eventId: EventId)async throws  -> [String]? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_event_seen_on_relays(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func profile(publicKey: PublicKey)async throws  -> Profile {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_profile(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeProfile.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func query(filters: [Filter])async throws  -> [Event] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_query(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Save [`Event`] into store
     *
     * Return `true` if event was successfully saved into database.
     */
open func saveEvent(event: Event)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_save_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Wipe all data
     */
open func wipe()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_wipe(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

}

public struct FfiConverterTypeNostrDatabase: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrDatabase

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrDatabase {
        return NostrDatabase(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrDatabase) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrDatabase {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrDatabase, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrDatabase_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrDatabase {
    return try FfiConverterTypeNostrDatabase.lift(pointer)
}

public func FfiConverterTypeNostrDatabase_lower(_ value: NostrDatabase) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrDatabase.lower(value)
}




public protocol NostrSignerProtocol : AnyObject {
    
    func nip04Decrypt(publicKey: PublicKey, encryptedContent: String) async throws  -> String
    
    func nip04Encrypt(publicKey: PublicKey, content: String) async throws  -> String
    
    func nip44Decrypt(publicKey: PublicKey, content: String) async throws  -> String
    
    func nip44Encrypt(publicKey: PublicKey, content: String) async throws  -> String
    
    /**
     * Get signer public key
     */
    func publicKey() async throws  -> PublicKey
    
    func signEvent(unsignedEvent: UnsignedEvent) async throws  -> Event
    
    func signEventBuilder(builder: EventBuilder) async throws  -> Event
    
}

open class NostrSigner:
    NostrSignerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrsigner(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrsigner(pointer, $0) }
    }

    
public static func keys(keys: Keys) -> NostrSigner {
    return try!  FfiConverterTypeNostrSigner.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_keys(
        FfiConverterTypeKeys_lower(keys),$0
    )
})
}
    
public static func nip46(nip46: Nip46Signer) -> NostrSigner {
    return try!  FfiConverterTypeNostrSigner.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_nip46(
        FfiConverterTypeNip46Signer.lower(nip46),$0
    )
})
}
    

    
open func nip04Decrypt(publicKey: PublicKey, encryptedContent: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_decrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(encryptedContent)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func nip04Encrypt(publicKey: PublicKey, content: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_encrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func nip44Decrypt(publicKey: PublicKey, content: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_decrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func nip44Encrypt(publicKey: PublicKey, content: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_encrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get signer public key
     */
open func publicKey()async throws  -> PublicKey {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_public_key(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypePublicKey_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func signEvent(unsignedEvent: UnsignedEvent)async throws  -> Event {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_sign_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUnsignedEvent_lower(unsignedEvent)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvent_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func signEventBuilder(builder: EventBuilder)async throws  -> Event {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_sign_event_builder(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventBuilder_lower(builder)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvent_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

}

public struct FfiConverterTypeNostrSigner: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrSigner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrSigner {
        return NostrSigner(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrSigner) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrSigner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrSigner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrSigner_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrSigner {
    return try FfiConverterTypeNostrSigner.lift(pointer)
}

public func FfiConverterTypeNostrSigner_lower(_ value: NostrSigner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrSigner.lower(value)
}




/**
 * NWC options
 */
public protocol NostrWalletConnectOptionsProtocol : AnyObject {
    
    /**
     * Set proxy
     */
    func proxy(proxy: String?) throws  -> NostrWalletConnectOptions
    
    /**
     * Set NWC requests timeout (default: 10 secs)
     */
    func timeout(timeout: TimeInterval)  -> NostrWalletConnectOptions
    
}

/**
 * NWC options
 */
open class NostrWalletConnectOptions:
    NostrWalletConnectOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrwalletconnectoptions(self.pointer, $0) }
    }
    /**
     * New default NWC options
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnectoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrwalletconnectoptions(pointer, $0) }
    }

    

    
    /**
     * Set proxy
     */
open func proxy(proxy: String?)throws  -> NostrWalletConnectOptions {
    return try  FfiConverterTypeNostrWalletConnectOptions.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_proxy(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(proxy),$0
    )
})
}
    
    /**
     * Set NWC requests timeout (default: 10 secs)
     */
open func timeout(timeout: TimeInterval) -> NostrWalletConnectOptions {
    return try!  FfiConverterTypeNostrWalletConnectOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_timeout(self.uniffiClonePointer(),
        FfiConverterDuration.lower(timeout),$0
    )
})
}
    

}

public struct FfiConverterTypeNostrWalletConnectOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrWalletConnectOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrWalletConnectOptions {
        return NostrWalletConnectOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrWalletConnectOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrWalletConnectOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrWalletConnectOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrWalletConnectOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrWalletConnectOptions {
    return try FfiConverterTypeNostrWalletConnectOptions.lift(pointer)
}

public func FfiConverterTypeNostrWalletConnectOptions_lower(_ value: NostrWalletConnectOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrWalletConnectOptions.lower(value)
}




/**
 * Nostr Zapper
 */
public protocol NostrZapperProtocol : AnyObject {
    
}

/**
 * Nostr Zapper
 */
open class NostrZapper:
    NostrZapperProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrzapper(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrzapper(pointer, $0) }
    }

    
public static func nwc(client: Nwc) -> NostrZapper {
    return try!  FfiConverterTypeNostrZapper.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrzapper_nwc(
        FfiConverterTypeNWC.lower(client),$0
    )
})
}
    

    

}

public struct FfiConverterTypeNostrZapper: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrZapper

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrZapper {
        return NostrZapper(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrZapper) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrZapper {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrZapper, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrZapper_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrZapper {
    return try FfiConverterTypeNostrZapper.lift(pointer)
}

public func FfiConverterTypeNostrZapper_lower(_ value: NostrZapper) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrZapper.lower(value)
}




public protocol OptionsProtocol : AnyObject {
    
    /**
     * Auto authenticate to relays (default: true)
     *
     * <https://github.com/nostr-protocol/nips/blob/master/42.md>
     */
    func automaticAuthentication(enabled: Bool)  -> Options
    
    /**
     * Connection timeout (default: None)
     *
     * If set to `None`, the client will try to connect to the relays without waiting.
     */
    func connectionTimeout(timeout: TimeInterval?)  -> Options
    
    func difficulty(difficulty: UInt8)  -> Options
    
    /**
     * Minimum POW difficulty for received events
     */
    func minPow(difficulty: UInt8)  -> Options
    
    /**
     * Proxy
     */
    func proxy(proxy: Proxy)  -> Options
    
    /**
     * Set custom relay limits
     */
    func relayLimits(limits: RelayLimits)  -> Options
    
    func reqFiltersChunkSize(reqFiltersChunkSize: UInt8)  -> Options
    
    func sendTimeout(sendTimeout: TimeInterval?)  -> Options
    
    func skipDisconnectedRelays(skip: Bool)  -> Options
    
    func timeout(timeout: TimeInterval)  -> Options
    
    func waitForSend(wait: Bool)  -> Options
    
    func waitForSubscription(wait: Bool)  -> Options
    
}

open class Options:
    OptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_options(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_options_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_options(pointer, $0) }
    }

    

    
    /**
     * Auto authenticate to relays (default: true)
     *
     * <https://github.com/nostr-protocol/nips/blob/master/42.md>
     */
open func automaticAuthentication(enabled: Bool) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_automatic_authentication(self.uniffiClonePointer(),
        FfiConverterBool.lower(enabled),$0
    )
})
}
    
    /**
     * Connection timeout (default: None)
     *
     * If set to `None`, the client will try to connect to the relays without waiting.
     */
open func connectionTimeout(timeout: TimeInterval?) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_connection_timeout(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    
open func difficulty(difficulty: UInt8) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_difficulty(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
})
}
    
    /**
     * Minimum POW difficulty for received events
     */
open func minPow(difficulty: UInt8) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_min_pow(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
})
}
    
    /**
     * Proxy
     */
open func proxy(proxy: Proxy) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_proxy(self.uniffiClonePointer(),
        FfiConverterTypeProxy.lower(proxy),$0
    )
})
}
    
    /**
     * Set custom relay limits
     */
open func relayLimits(limits: RelayLimits) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_relay_limits(self.uniffiClonePointer(),
        FfiConverterTypeRelayLimits.lower(limits),$0
    )
})
}
    
open func reqFiltersChunkSize(reqFiltersChunkSize: UInt8) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_req_filters_chunk_size(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(reqFiltersChunkSize),$0
    )
})
}
    
open func sendTimeout(sendTimeout: TimeInterval?) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_send_timeout(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(sendTimeout),$0
    )
})
}
    
open func skipDisconnectedRelays(skip: Bool) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_skip_disconnected_relays(self.uniffiClonePointer(),
        FfiConverterBool.lower(skip),$0
    )
})
}
    
open func timeout(timeout: TimeInterval) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_timeout(self.uniffiClonePointer(),
        FfiConverterDuration.lower(timeout),$0
    )
})
}
    
open func waitForSend(wait: Bool) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_wait_for_send(self.uniffiClonePointer(),
        FfiConverterBool.lower(wait),$0
    )
})
}
    
open func waitForSubscription(wait: Bool) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_wait_for_subscription(self.uniffiClonePointer(),
        FfiConverterBool.lower(wait),$0
    )
})
}
    

}

public struct FfiConverterTypeOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Options

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Options {
        return Options(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Options) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Options {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Options, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> Options {
    return try FfiConverterTypeOptions.lift(pointer)
}

public func FfiConverterTypeOptions_lower(_ value: Options) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOptions.lower(value)
}




public protocol ProfileProtocol : AnyObject {
    
    /**
     * Get profile metadata
     */
    func metadata()  -> Metadata
    
    /**
     * Get profile name
     *
     * Steps (go to next step if field is `None` or `empty`):
     * * Check `display_name` field
     * * Check `name` field
     * * Return cutted public key (ex. `00000000:00000002`)
     */
    func name()  -> String
    
    /**
     * Get profile public key
     */
    func publicKey()  -> PublicKey
    
}

open class Profile:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    ProfileProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_profile(self.pointer, $0) }
    }
    /**
     * Compose new profile
     */
public convenience init(publicKey: PublicKey, metadata: Metadata) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_profile_new(
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterTypeMetadata_lower(metadata),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_profile(pointer, $0) }
    }

    

    
    /**
     * Get profile metadata
     */
open func metadata() -> Metadata {
    return try!  FfiConverterTypeMetadata_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_metadata(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get profile name
     *
     * Steps (go to next step if field is `None` or `empty`):
     * * Check `display_name` field
     * * Check `name` field
     * * Return cutted public key (ex. `00000000:00000002`)
     */
open func name() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_name(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get profile public key
     */
open func publicKey() -> PublicKey {
    return try!  FfiConverterTypePublicKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Profile, other: Profile) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeProfile.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeProfile: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Profile

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Profile {
        return Profile(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Profile) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Profile {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Profile, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeProfile_lift(_ pointer: UnsafeMutableRawPointer) throws -> Profile {
    return try FfiConverterTypeProfile.lift(pointer)
}

public func FfiConverterTypeProfile_lower(_ value: Profile) -> UnsafeMutableRawPointer {
    return FfiConverterTypeProfile.lower(value)
}




/**
 * Proxy
 */
public protocol ProxyProtocol : AnyObject {
    
    /**
     * Set proxy target (default: all)
     */
    func target(target: ProxyTarget)  -> Proxy
    
}

/**
 * Proxy
 */
open class Proxy:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    ProxyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_proxy(self.pointer, $0) }
    }
    /**
     * Compose proxy (ex. `127.0.0.1:9050`)
     */
public convenience init(addr: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_proxy_new(
        FfiConverterString.lower(addr),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_proxy(pointer, $0) }
    }

    

    
    /**
     * Set proxy target (default: all)
     */
open func target(target: ProxyTarget) -> Proxy {
    return try!  FfiConverterTypeProxy.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_proxy_target(self.uniffiClonePointer(),
        FfiConverterTypeProxyTarget.lower(target),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_proxy_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Proxy, other: Proxy) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_proxy_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeProxy.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_proxy_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeProxy: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Proxy

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Proxy {
        return Proxy(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Proxy) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Proxy {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Proxy, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeProxy_lift(_ pointer: UnsafeMutableRawPointer) throws -> Proxy {
    return try FfiConverterTypeProxy.lift(pointer)
}

public func FfiConverterTypeProxy_lower(_ value: Proxy) -> UnsafeMutableRawPointer {
    return FfiConverterTypeProxy.lower(value)
}




public protocol RelayProtocol : AnyObject {
    
    /**
     * Send multiple `Event` at once
     */
    func batchEvent(events: [Event], opts: RelaySendOptions) async throws 
    
    /**
     * Send multiple `ClientMessage` at once
     */
    func batchMsg(msgs: [ClientMessage], opts: RelaySendOptions) async throws 
    
    /**
     * Get blacklist
     */
    func blacklist()  -> RelayBlacklist
    
    /**
     * Connect to relay and keep alive connection
     */
    func connect(connectionTimeout: TimeInterval?) async 
    
    /**
     * Count events of filters
     */
    func countEventsOf(filters: [Filter], timeout: TimeInterval) async throws  -> UInt64
    
    func document() async  -> RelayInformationDocument
    
    /**
     * Get events of filters
     *
     * Get events from local database and relay
     */
    func getEventsOf(filters: [Filter], timeout: TimeInterval) async throws  -> [Event]
    
    /**
     * Check if `Relay` is connected
     */
    func isConnected() async  -> Bool
    
    func opts()  -> RelayOptions
    
    /**
     * Get proxy
     */
    func proxy()  -> String?
    
    /**
     * Get number of messages in queue
     */
    func queue()  -> UInt64
    
    /**
     * Negentropy reconciliation
     *
     * Use events stored in database
     */
    func reconcile(filter: Filter, opts: NegentropyOptions) async throws 
    
    /**
     * Negentropy reconciliation with custom items
     */
    func reconcileWithItems(filter: Filter, items: [NegentropyItem], opts: NegentropyOptions) async throws 
    
    /**
     * Send event and wait for `OK` relay msg
     */
    func sendEvent(event: Event, opts: RelaySendOptions) async throws  -> EventId
    
    /**
     * Send msg to relay
     */
    func sendMsg(msg: ClientMessage, opts: RelaySendOptions) async throws 
    
    func stats()  -> RelayConnectionStats
    
    /**
     * Get relay status
     */
    func status() async  -> RelayStatus
    
    /**
     * Disconnect from relay and set status to 'Stopped'
     */
    func stop() async throws 
    
    /**
     * Subscribe to filters
     *
     * Internally generate a new random subscription ID. Check `subscribe_with_id` method to use a custom subscription ID.
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
    func subscribe(filters: [Filter], opts: SubscribeOptions) async throws  -> String
    
    /**
     * Subscribe with custom subscription ID
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
    func subscribeWithId(id: String, filters: [Filter], opts: SubscribeOptions) async throws 
    
    /**
     * Get filters by subscription ID
     */
    func subscription(id: String) async  -> [Filter]?
    
    func subscriptions() async  -> [String: [Filter]]
    
    /**
     * Check if relay support negentropy protocol
     */
    func supportNegentropy() async throws  -> Bool
    
    /**
     * Disconnect from relay and set status to 'Terminated'
     */
    func terminate() async throws 
    
    /**
     * Unsubscribe
     */
    func unsubscribe(id: String, opts: RelaySendOptions) async throws 
    
    /**
     * Unsubscribe from all subscriptions
     */
    func unsubscribeAll(opts: RelaySendOptions) async throws 
    
    /**
     * Get relay url
     */
    func url()  -> String
    
}

open class Relay:
    RelayProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relay(self.pointer, $0) }
    }
    /**
     * Create new `Relay` with **default** `options` and `in-memory database`
     */
public convenience init(url: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_relay_new(
        FfiConverterString.lower(url),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relay(pointer, $0) }
    }

    
    /**
     * Create new `Relay` with **custom** `options` and/or `database`
     */
public static func custom(url: String, database: NostrDatabase, blacklist: RelayBlacklist, opts: RelayOptions)throws  -> Relay {
    return try  FfiConverterTypeRelay.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_relay_custom(
        FfiConverterString.lower(url),
        FfiConverterTypeNostrDatabase.lower(database),
        FfiConverterTypeRelayBlacklist.lower(blacklist),
        FfiConverterTypeRelayOptions.lower(opts),$0
    )
})
}
    
    /**
     * Create new `Relay` with default `in-memory database` and custom `options`
     */
public static func withOpts(url: String, opts: RelayOptions)throws  -> Relay {
    return try  FfiConverterTypeRelay.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_relay_with_opts(
        FfiConverterString.lower(url),
        FfiConverterTypeRelayOptions.lower(opts),$0
    )
})
}
    

    
    /**
     * Send multiple `Event` at once
     */
open func batchEvent(events: [Event], opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_batch_event(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeEvent.lower(events),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send multiple `ClientMessage` at once
     */
open func batchMsg(msgs: [ClientMessage], opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_batch_msg(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeClientMessage.lower(msgs),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get blacklist
     */
open func blacklist() -> RelayBlacklist {
    return try!  FfiConverterTypeRelayBlacklist.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_blacklist(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Connect to relay and keep alive connection
     */
open func connect(connectionTimeout: TimeInterval?)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_connect(
                    self.uniffiClonePointer(),
                    FfiConverterOptionDuration.lower(connectionTimeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Count events of filters
     */
open func countEventsOf(filters: [Filter], timeout: TimeInterval)async throws  -> UInt64 {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_count_events_of(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func document()async  -> RelayInformationDocument {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_document(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRelayInformationDocument_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get events of filters
     *
     * Get events from local database and relay
     */
open func getEventsOf(filters: [Filter], timeout: TimeInterval)async throws  -> [Event] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_get_events_of(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Check if `Relay` is connected
     */
open func isConnected()async  -> Bool {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_is_connected(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
open func opts() -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_opts(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get proxy
     */
open func proxy() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_proxy(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get number of messages in queue
     */
open func queue() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_queue(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Negentropy reconciliation
     *
     * Use events stored in database
     */
open func reconcile(filter: Filter, opts: NegentropyOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_reconcile(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterTypeNegentropyOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Negentropy reconciliation with custom items
     */
open func reconcileWithItems(filter: Filter, items: [NegentropyItem], opts: NegentropyOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_reconcile_with_items(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterSequenceTypeNegentropyItem.lower(items),FfiConverterTypeNegentropyOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send event and wait for `OK` relay msg
     */
open func sendEvent(event: Event, opts: RelaySendOptions)async throws  -> EventId {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_send_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send msg to relay
     */
open func sendMsg(msg: ClientMessage, opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_send_msg(
                    self.uniffiClonePointer(),
                    FfiConverterTypeClientMessage_lower(msg),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func stats() -> RelayConnectionStats {
    return try!  FfiConverterTypeRelayConnectionStats.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_stats(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get relay status
     */
open func status()async  -> RelayStatus {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_status(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRelayStatus.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Disconnect from relay and set status to 'Stopped'
     */
open func stop()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_stop(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Subscribe to filters
     *
     * Internally generate a new random subscription ID. Check `subscribe_with_id` method to use a custom subscription ID.
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
open func subscribe(filters: [Filter], opts: SubscribeOptions)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_subscribe(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters),FfiConverterTypeSubscribeOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Subscribe with custom subscription ID
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
open func subscribeWithId(id: String, filters: [Filter], opts: SubscribeOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_subscribe_with_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterTypeSubscribeOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get filters by subscription ID
     */
open func subscription(id: String)async  -> [Filter]? {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_subscription(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
open func subscriptions()async  -> [String: [Filter]] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_subscriptions(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Check if relay support negentropy protocol
     */
open func supportNegentropy()async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_support_negentropy(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Disconnect from relay and set status to 'Terminated'
     */
open func terminate()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_terminate(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Unsubscribe
     */
open func unsubscribe(id: String, opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Unsubscribe from all subscriptions
     */
open func unsubscribeAll(opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe_all(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get relay url
     */
open func url() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_url(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeRelay: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Relay

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Relay {
        return Relay(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Relay) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Relay {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Relay, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelay_lift(_ pointer: UnsafeMutableRawPointer) throws -> Relay {
    return try FfiConverterTypeRelay.lift(pointer)
}

public func FfiConverterTypeRelay_lower(_ value: Relay) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelay.lower(value)
}




public protocol RelayBlacklistProtocol : AnyObject {
    
    /**
     * Add event IDs to blacklist
     */
    func addIds(ids: [EventId]) async 
    
    /**
     * Add public keys to blacklist
     */
    func addPublicKeys(publicKeys: [PublicKey]) async 
    
    /**
     * Remove everything
     */
    func clear() async 
    
    /**
     * Check if blacklist contains event ID
     */
    func hasId(id: EventId) async  -> Bool
    
    /**
     * Check if blacklist contains public key
     */
    func hasPublicKey(publicKey: PublicKey) async  -> Bool
    
    /**
     * Remove event ID from blacklist
     */
    func removeId(id: EventId) async 
    
    /**
     * Remove event IDs from blacklist
     */
    func removeIds(ids: [EventId]) async 
    
    /**
     * Remove public key from blacklist
     */
    func removePublicKey(publicKey: PublicKey) async 
    
    /**
     * Remove event IDs from blacklist
     */
    func removePublicKeys(ids: [PublicKey]) async 
    
}

open class RelayBlacklist:
    RelayBlacklistProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relayblacklist(self.pointer, $0) }
    }
public convenience init(ids: [EventId] = [], publicKeys: [PublicKey] = []) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relayblacklist_new(
        FfiConverterSequenceTypeEventId.lower(ids),
        FfiConverterSequenceTypePublicKey.lower(publicKeys),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relayblacklist(pointer, $0) }
    }

    
    /**
     * construct new empty blacklist
     */
public static func empty() -> RelayBlacklist {
    return try!  FfiConverterTypeRelayBlacklist.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relayblacklist_empty($0
    )
})
}
    

    
    /**
     * Add event IDs to blacklist
     */
open func addIds(ids: [EventId])async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayblacklist_add_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeEventId.lower(ids)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Add public keys to blacklist
     */
open func addPublicKeys(publicKeys: [PublicKey])async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayblacklist_add_public_keys(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypePublicKey.lower(publicKeys)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Remove everything
     */
open func clear()async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayblacklist_clear(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Check if blacklist contains event ID
     */
open func hasId(id: EventId)async  -> Bool {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayblacklist_has_id(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(id)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Check if blacklist contains public key
     */
open func hasPublicKey(publicKey: PublicKey)async  -> Bool {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayblacklist_has_public_key(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Remove event ID from blacklist
     */
open func removeId(id: EventId)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayblacklist_remove_id(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(id)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Remove event IDs from blacklist
     */
open func removeIds(ids: [EventId])async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayblacklist_remove_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeEventId.lower(ids)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Remove public key from blacklist
     */
open func removePublicKey(publicKey: PublicKey)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayblacklist_remove_public_key(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Remove event IDs from blacklist
     */
open func removePublicKeys(ids: [PublicKey])async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayblacklist_remove_public_keys(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypePublicKey.lower(ids)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}

public struct FfiConverterTypeRelayBlacklist: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayBlacklist

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayBlacklist {
        return RelayBlacklist(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayBlacklist) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayBlacklist {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayBlacklist, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayBlacklist_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayBlacklist {
    return try FfiConverterTypeRelayBlacklist.lift(pointer)
}

public func FfiConverterTypeRelayBlacklist_lower(_ value: RelayBlacklist) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayBlacklist.lower(value)
}




public protocol RelayConnectionStatsProtocol : AnyObject {
    
    /**
     * The number of times a connection has been attempted
     */
    func attempts()  -> UInt64
    
    /**
     * Bytes received
     */
    func bytesReceived()  -> UInt64
    
    /**
     * Bytes sent
     */
    func bytesSent()  -> UInt64
    
    /**
     * Get UNIX timestamp of the last connection
     */
    func connectedAt()  -> Timestamp
    
    /**
     * Get UNIX timestamp of the first connection
     */
    func firstConnectionTimestamp()  -> Timestamp
    
    func latency() async  -> TimeInterval?
    
    /**
     * The number of times a connection has been successfully established
     */
    func success()  -> UInt64
    
    /**
     * Uptime
     */
    func uptime()  -> Double
    
}

open class RelayConnectionStats:
    RelayConnectionStatsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relayconnectionstats(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relayconnectionstats(pointer, $0) }
    }

    

    
    /**
     * The number of times a connection has been attempted
     */
open func attempts() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_attempts(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Bytes received
     */
open func bytesReceived() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_received(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Bytes sent
     */
open func bytesSent() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_sent(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get UNIX timestamp of the last connection
     */
open func connectedAt() -> Timestamp {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_connected_at(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get UNIX timestamp of the first connection
     */
open func firstConnectionTimestamp() -> Timestamp {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_first_connection_timestamp(self.uniffiClonePointer(),$0
    )
})
}
    
open func latency()async  -> TimeInterval? {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_latency(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionDuration.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * The number of times a connection has been successfully established
     */
open func success() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_success(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Uptime
     */
open func uptime() -> Double {
    return try!  FfiConverterDouble.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_uptime(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeRelayConnectionStats: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayConnectionStats

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayConnectionStats {
        return RelayConnectionStats(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayConnectionStats) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayConnectionStats {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayConnectionStats, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayConnectionStats_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayConnectionStats {
    return try FfiConverterTypeRelayConnectionStats.lift(pointer)
}

public func FfiConverterTypeRelayConnectionStats_lower(_ value: RelayConnectionStats) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayConnectionStats.lower(value)
}




/**
 * Relay Limits
 */
public protocol RelayLimitsProtocol : AnyObject {
    
    /**
     * Maximum number of tags allowed (default: 2_000)
     */
    func eventMaxNumTags(maxNumTags: UInt16?)  -> RelayLimits
    
    /**
     * Maximum number of tags allowed per kind
     */
    func eventMaxNumTagsPerKind(kind: Kind, maxNumTags: UInt16?)  -> RelayLimits
    
    /**
     * Maximum size of normalised JSON, in bytes (default: 70_000)
     */
    func eventMaxSize(maxSize: UInt32?)  -> RelayLimits
    
    /**
     * Maximum size per kind of normalised JSON, in bytes.
     */
    func eventMaxSizePerKind(kind: Kind, maxSize: UInt32?)  -> RelayLimits
    
    /**
     * Maximum size of normalised JSON, in bytes (default: 5_250_000)
     */
    func messageMaxSize(maxSize: UInt32?)  -> RelayLimits
    
}

/**
 * Relay Limits
 */
open class RelayLimits:
    CustomDebugStringConvertible,
    Equatable,
    RelayLimitsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relaylimits(self.pointer, $0) }
    }
    /**
     * Construct with default limits
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relaylimits(pointer, $0) }
    }

    
    /**
     * Disable all limits
     */
public static func disable() -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_disable($0
    )
})
}
    

    
    /**
     * Maximum number of tags allowed (default: 2_000)
     */
open func eventMaxNumTags(maxNumTags: UInt16?) -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_num_tags(self.uniffiClonePointer(),
        FfiConverterOptionUInt16.lower(maxNumTags),$0
    )
})
}
    
    /**
     * Maximum number of tags allowed per kind
     */
open func eventMaxNumTagsPerKind(kind: Kind, maxNumTags: UInt16?) -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_num_tags_per_kind(self.uniffiClonePointer(),
        FfiConverterTypeKind_lower(kind),
        FfiConverterOptionUInt16.lower(maxNumTags),$0
    )
})
}
    
    /**
     * Maximum size of normalised JSON, in bytes (default: 70_000)
     */
open func eventMaxSize(maxSize: UInt32?) -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_size(self.uniffiClonePointer(),
        FfiConverterOptionUInt32.lower(maxSize),$0
    )
})
}
    
    /**
     * Maximum size per kind of normalised JSON, in bytes.
     */
open func eventMaxSizePerKind(kind: Kind, maxSize: UInt32?) -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_size_per_kind(self.uniffiClonePointer(),
        FfiConverterTypeKind_lower(kind),
        FfiConverterOptionUInt32.lower(maxSize),$0
    )
})
}
    
    /**
     * Maximum size of normalised JSON, in bytes (default: 5_250_000)
     */
open func messageMaxSize(maxSize: UInt32?) -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_message_max_size(self.uniffiClonePointer(),
        FfiConverterOptionUInt32.lower(maxSize),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: RelayLimits, other: RelayLimits) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeRelayLimits.lower(other),$0
    )
}
        )
    }

}

public struct FfiConverterTypeRelayLimits: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayLimits

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayLimits {
        return RelayLimits(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayLimits) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayLimits {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayLimits, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayLimits_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayLimits {
    return try FfiConverterTypeRelayLimits.lift(pointer)
}

public func FfiConverterTypeRelayLimits_lower(_ value: RelayLimits) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayLimits.lower(value)
}




/**
 * `Relay` options
 */
public protocol RelayOptionsProtocol : AnyObject {
    
    /**
     * Automatically adjust retry seconds based on success/attempts (default: true)
     */
    func adjustRetrySec(adjustRetrySec: Bool)  -> RelayOptions
    
    /**
     * Set custom limits
     */
    func limits(limits: RelayLimits)  -> RelayOptions
    
    /**
     * Set ping flag
     */
    func ping(ping: Bool)  -> RelayOptions
    
    /**
     * Minimum POW for received events (default: 0)
     */
    func pow(difficulty: UInt8)  -> RelayOptions
    
    /**
     * Set proxy
     */
    func proxy(proxy: String?) throws  -> RelayOptions
    
    /**
     * Set read flag
     */
    func read(read: Bool)  -> RelayOptions
    
    /**
     * Enable/disable auto reconnection (default: true)
     */
    func reconnect(reconnect: Bool)  -> RelayOptions
    
    /**
     * Retry connection time (default: 10 sec)
     *
     * Are allowed values `>=` 5 secs
     */
    func retrySec(retrySec: UInt64)  -> RelayOptions
    
    /**
     * Set adjust_retry_sec option
     */
    func updateAdjustRetrySec(adjustRetrySec: Bool) 
    
    /**
     * Update `pow` option
     */
    func updatePowDifficulty(difficulty: UInt8) 
    
    /**
     * Update `reconnect` option
     */
    func updateReconnect(reconnect: Bool) 
    
    /**
     * Set retry_sec option
     */
    func updateRetrySec(retrySec: UInt64) 
    
    /**
     * Set write flag
     */
    func write(write: Bool)  -> RelayOptions
    
}

/**
 * `Relay` options
 */
open class RelayOptions:
    RelayOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relayoptions(self.pointer, $0) }
    }
    /**
     * New default relay options
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relayoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relayoptions(pointer, $0) }
    }

    

    
    /**
     * Automatically adjust retry seconds based on success/attempts (default: true)
     */
open func adjustRetrySec(adjustRetrySec: Bool) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_adjust_retry_sec(self.uniffiClonePointer(),
        FfiConverterBool.lower(adjustRetrySec),$0
    )
})
}
    
    /**
     * Set custom limits
     */
open func limits(limits: RelayLimits) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_limits(self.uniffiClonePointer(),
        FfiConverterTypeRelayLimits.lower(limits),$0
    )
})
}
    
    /**
     * Set ping flag
     */
open func ping(ping: Bool) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_ping(self.uniffiClonePointer(),
        FfiConverterBool.lower(ping),$0
    )
})
}
    
    /**
     * Minimum POW for received events (default: 0)
     */
open func pow(difficulty: UInt8) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_pow(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
})
}
    
    /**
     * Set proxy
     */
open func proxy(proxy: String?)throws  -> RelayOptions {
    return try  FfiConverterTypeRelayOptions.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_proxy(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(proxy),$0
    )
})
}
    
    /**
     * Set read flag
     */
open func read(read: Bool) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_read(self.uniffiClonePointer(),
        FfiConverterBool.lower(read),$0
    )
})
}
    
    /**
     * Enable/disable auto reconnection (default: true)
     */
open func reconnect(reconnect: Bool) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_reconnect(self.uniffiClonePointer(),
        FfiConverterBool.lower(reconnect),$0
    )
})
}
    
    /**
     * Retry connection time (default: 10 sec)
     *
     * Are allowed values `>=` 5 secs
     */
open func retrySec(retrySec: UInt64) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_retry_sec(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(retrySec),$0
    )
})
}
    
    /**
     * Set adjust_retry_sec option
     */
open func updateAdjustRetrySec(adjustRetrySec: Bool) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_update_adjust_retry_sec(self.uniffiClonePointer(),
        FfiConverterBool.lower(adjustRetrySec),$0
    )
}
}
    
    /**
     * Update `pow` option
     */
open func updatePowDifficulty(difficulty: UInt8) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_update_pow_difficulty(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
}
}
    
    /**
     * Update `reconnect` option
     */
open func updateReconnect(reconnect: Bool) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_update_reconnect(self.uniffiClonePointer(),
        FfiConverterBool.lower(reconnect),$0
    )
}
}
    
    /**
     * Set retry_sec option
     */
open func updateRetrySec(retrySec: UInt64) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_update_retry_sec(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(retrySec),$0
    )
}
}
    
    /**
     * Set write flag
     */
open func write(write: Bool) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_write(self.uniffiClonePointer(),
        FfiConverterBool.lower(write),$0
    )
})
}
    

}

public struct FfiConverterTypeRelayOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayOptions {
        return RelayOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayOptions {
    return try FfiConverterTypeRelayOptions.lift(pointer)
}

public func FfiConverterTypeRelayOptions_lower(_ value: RelayOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayOptions.lower(value)
}




public protocol RelayPoolProtocol : AnyObject {
    
    func addRelay(url: String, opts: RelayOptions) async throws  -> Bool
    
    /**
     * Send multiple `Event` at once to **all connected relays** and wait for `OK` message
     */
    func batchEvent(events: [Event], opts: RelaySendOptions) async throws 
    
    /**
     * Send multiple events at once to **specific relays** and wait for `OK` message
     */
    func batchEventTo(urls: [String], events: [Event], opts: RelaySendOptions) async throws 
    
    /**
     * Send multiple client messages at once to all connected relays
     */
    func batchMsg(msgs: [ClientMessage], opts: RelaySendOptions) async throws 
    
    /**
     * Send multiple client messages at once to specific relays
     *
     * Note: **the relays must already be added!**
     */
    func batchMsgTo(urls: [String], msgs: [ClientMessage], opts: RelaySendOptions) async throws 
    
    /**
     * Get blacklist
     */
    func blacklist()  -> RelayBlacklist
    
    /**
     * Connect to all added relays and keep connection alive
     */
    func connect(connectionTimeout: TimeInterval?) async 
    
    /**
     * Connect to relay
     */
    func connectRelay(url: String, connectionTimeout: TimeInterval?) async throws 
    
    /**
     * Get database
     */
    func database()  -> NostrDatabase
    
    /**
     * Disconnect from all relays
     */
    func disconnect() async throws 
    
    /**
     * Get events of filters from **specific relays**
     *
     * Get events both from **local database** and **relays**
     */
    func getEventsFrom(urls: [String], filters: [Filter], timeout: TimeInterval, opts: FilterOptions) async throws  -> [Event]
    
    /**
     * Get events of filters
     *
     * Get events both from **local database** and **relays**
     */
    func getEventsOf(filters: [Filter], timeout: TimeInterval, opts: FilterOptions) async throws  -> [Event]
    
    /**
     * Handle relay pool notifications
     *
     * <div class="warning">Python bindings needs to call `uniffi_set_event_loop(asyncio.get_running_loop())` before this method!</div>
     */
    func handleNotifications(handler: HandleNotification) throws 
    
    /**
     * Negentropy reconciliation
     *
     * Use events stored in database
     */
    func reconcile(filter: Filter, opts: NegentropyOptions) async throws 
    
    /**
     * Negentropy reconciliation with custom items
     */
    func reconcileWithItems(filter: Filter, items: [NegentropyItem], opts: NegentropyOptions) async throws 
    
    /**
     * Get relay
     */
    func relay(url: String) async throws  -> Relay
    
    /**
     * Get relays
     */
    func relays() async  -> [String: Relay]
    
    func removeAllRelay() async throws 
    
    func removeRelay(url: String) async throws 
    
    /**
     * Send event to **all connected relays** and wait for `OK` message
     */
    func sendEvent(event: Event, opts: RelaySendOptions) async throws  -> EventId
    
    /**
     * Send event to **specific relays** and wait for `OK` message
     */
    func sendEventTo(urls: [String], event: Event, opts: RelaySendOptions) async throws  -> EventId
    
    /**
     * Send client message to all connected relays
     */
    func sendMsg(msg: ClientMessage, opts: RelaySendOptions) async throws 
    
    /**
     * Send client message to specific relays
     *
     * Note: **the relays must already be added!**
     */
    func sendMsgTo(urls: [String], msg: ClientMessage, opts: RelaySendOptions) async throws 
    
    /**
     * Completely shutdown pool
     */
    func shutdown() async throws 
    
    /**
     * Start
     *
     * Internally call `connect` without wait for connection.
     */
    func start() async 
    
    /**
     * Stop
     *
     * Call `connect` to re-start relays connections
     */
    func stop() async throws 
    
    /**
     * Subscribe to filters to all connected relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
    func subscribe(filters: [Filter], opts: SubscribeOptions) async  -> String
    
    /**
     * Subscribe to filters to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     */
    func subscribeTo(urls: [String], filters: [Filter], opts: SubscribeOptions) async throws  -> String
    
    /**
     * Subscribe with custom subscription ID to all connected relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
    func subscribeWithId(id: String, filters: [Filter], opts: SubscribeOptions) async 
    
    /**
     * Subscribe to filters with custom subscription ID to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     */
    func subscribeWithIdTo(urls: [String], id: String, filters: [Filter], opts: SubscribeOptions) async throws 
    
    /**
     * Get filters by subscription ID
     */
    func subscription(id: String) async  -> [Filter]?
    
    /**
     * Get subscriptions
     */
    func subscriptions() async  -> [String: [Filter]]
    
    /**
     * Unsubscribe
     */
    func unsubscribe(id: String, opts: RelaySendOptions) async 
    
    /**
     * Unsubscribe from all subscriptions
     */
    func unsubscribeAll(opts: RelaySendOptions) async 
    
}

open class RelayPool:
    RelayPoolProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relaypool(self.pointer, $0) }
    }
    /**
     * Create new `RelayPool` with `in-memory` database
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaypool_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relaypool(pointer, $0) }
    }

    
    /**
     * Create new `RelayPool` with `custom` database
     */
public static func withDatabase(database: NostrDatabase) -> RelayPool {
    return try!  FfiConverterTypeRelayPool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaypool_with_database(
        FfiConverterTypeNostrDatabase.lower(database),$0
    )
})
}
    

    
open func addRelay(url: String, opts: RelayOptions)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_add_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterTypeRelayOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send multiple `Event` at once to **all connected relays** and wait for `OK` message
     */
open func batchEvent(events: [Event], opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_batch_event(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeEvent.lower(events),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send multiple events at once to **specific relays** and wait for `OK` message
     */
open func batchEventTo(urls: [String], events: [Event], opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_batch_event_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterSequenceTypeEvent.lower(events),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send multiple client messages at once to all connected relays
     */
open func batchMsg(msgs: [ClientMessage], opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_batch_msg(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeClientMessage.lower(msgs),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send multiple client messages at once to specific relays
     *
     * Note: **the relays must already be added!**
     */
open func batchMsgTo(urls: [String], msgs: [ClientMessage], opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_batch_msg_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterSequenceTypeClientMessage.lower(msgs),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get blacklist
     */
open func blacklist() -> RelayBlacklist {
    return try!  FfiConverterTypeRelayBlacklist.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_blacklist(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Connect to all added relays and keep connection alive
     */
open func connect(connectionTimeout: TimeInterval?)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_connect(
                    self.uniffiClonePointer(),
                    FfiConverterOptionDuration.lower(connectionTimeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Connect to relay
     */
open func connectRelay(url: String, connectionTimeout: TimeInterval?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_connect_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterOptionDuration.lower(connectionTimeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get database
     */
open func database() -> NostrDatabase {
    return try!  FfiConverterTypeNostrDatabase.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_database(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Disconnect from all relays
     */
open func disconnect()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_disconnect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get events of filters from **specific relays**
     *
     * Get events both from **local database** and **relays**
     */
open func getEventsFrom(urls: [String], filters: [Filter], timeout: TimeInterval, opts: FilterOptions)async throws  -> [Event] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_get_events_from(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterDuration.lower(timeout),FfiConverterTypeFilterOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get events of filters
     *
     * Get events both from **local database** and **relays**
     */
open func getEventsOf(filters: [Filter], timeout: TimeInterval, opts: FilterOptions)async throws  -> [Event] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_get_events_of(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters),FfiConverterDuration.lower(timeout),FfiConverterTypeFilterOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Handle relay pool notifications
     *
     * <div class="warning">Python bindings needs to call `uniffi_set_event_loop(asyncio.get_running_loop())` before this method!</div>
     */
open func handleNotifications(handler: HandleNotification)throws  {try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_handle_notifications(self.uniffiClonePointer(),
        FfiConverterTypeHandleNotification.lower(handler),$0
    )
}
}
    
    /**
     * Negentropy reconciliation
     *
     * Use events stored in database
     */
open func reconcile(filter: Filter, opts: NegentropyOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_reconcile(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterTypeNegentropyOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Negentropy reconciliation with custom items
     */
open func reconcileWithItems(filter: Filter, items: [NegentropyItem], opts: NegentropyOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_reconcile_with_items(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterSequenceTypeNegentropyItem.lower(items),FfiConverterTypeNegentropyOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get relay
     */
open func relay(url: String)async throws  -> Relay {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRelay.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get relays
     */
open func relays()async  -> [String: Relay] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_relays(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringTypeRelay.lift,
            errorHandler: nil
            
        )
}
    
open func removeAllRelay()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_remove_all_relay(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func removeRelay(url: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_remove_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send event to **all connected relays** and wait for `OK` message
     */
open func sendEvent(event: Event, opts: RelaySendOptions)async throws  -> EventId {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_send_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send event to **specific relays** and wait for `OK` message
     */
open func sendEventTo(urls: [String], event: Event, opts: RelaySendOptions)async throws  -> EventId {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_send_event_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterTypeEvent_lower(event),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send client message to all connected relays
     */
open func sendMsg(msg: ClientMessage, opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_send_msg(
                    self.uniffiClonePointer(),
                    FfiConverterTypeClientMessage_lower(msg),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send client message to specific relays
     *
     * Note: **the relays must already be added!**
     */
open func sendMsgTo(urls: [String], msg: ClientMessage, opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_send_msg_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterTypeClientMessage_lower(msg),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Completely shutdown pool
     */
open func shutdown()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_shutdown(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Start
     *
     * Internally call `connect` without wait for connection.
     */
open func start()async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_start(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Stop
     *
     * Call `connect` to re-start relays connections
     */
open func stop()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_stop(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Subscribe to filters to all connected relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
open func subscribe(filters: [Filter], opts: SubscribeOptions)async  -> String {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_subscribe(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters),FfiConverterTypeSubscribeOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Subscribe to filters to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     */
open func subscribeTo(urls: [String], filters: [Filter], opts: SubscribeOptions)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_subscribe_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterTypeSubscribeOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Subscribe with custom subscription ID to all connected relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
open func subscribeWithId(id: String, filters: [Filter], opts: SubscribeOptions)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_subscribe_with_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterTypeSubscribeOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Subscribe to filters with custom subscription ID to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     */
open func subscribeWithIdTo(urls: [String], id: String, filters: [Filter], opts: SubscribeOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_subscribe_with_id_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterString.lower(id),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterTypeSubscribeOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get filters by subscription ID
     */
open func subscription(id: String)async  -> [Filter]? {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_subscription(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get subscriptions
     */
open func subscriptions()async  -> [String: [Filter]] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_subscriptions(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Unsubscribe
     */
open func unsubscribe(id: String, opts: RelaySendOptions)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_unsubscribe(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Unsubscribe from all subscriptions
     */
open func unsubscribeAll(opts: RelaySendOptions)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_unsubscribe_all(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}

public struct FfiConverterTypeRelayPool: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayPool

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayPool {
        return RelayPool(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayPool) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayPool {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayPool, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayPool_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayPool {
    return try FfiConverterTypeRelayPool.lift(pointer)
}

public func FfiConverterTypeRelayPool_lower(_ value: RelayPool) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayPool.lower(value)
}




public protocol RelaySendOptionsProtocol : AnyObject {
    
    /**
     * Skip wait for disconnected relay (default: true)
     */
    func skipDisconnected(value: Bool)  -> RelaySendOptions
    
    /**
     * Skip wait for confirmation that message is sent (default: false)
     */
    func skipSendConfirmation(value: Bool)  -> RelaySendOptions
    
    /**
     * Timeout for sending event (default: 20 secs)
     *
     * If `None`, the default timeout will be used
     */
    func timeout(timeout: TimeInterval?)  -> RelaySendOptions
    
}

open class RelaySendOptions:
    RelaySendOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relaysendoptions(self.pointer, $0) }
    }
    /**
     * New default `RelaySendOptions`
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaysendoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relaysendoptions(pointer, $0) }
    }

    

    
    /**
     * Skip wait for disconnected relay (default: true)
     */
open func skipDisconnected(value: Bool) -> RelaySendOptions {
    return try!  FfiConverterTypeRelaySendOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaysendoptions_skip_disconnected(self.uniffiClonePointer(),
        FfiConverterBool.lower(value),$0
    )
})
}
    
    /**
     * Skip wait for confirmation that message is sent (default: false)
     */
open func skipSendConfirmation(value: Bool) -> RelaySendOptions {
    return try!  FfiConverterTypeRelaySendOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaysendoptions_skip_send_confirmation(self.uniffiClonePointer(),
        FfiConverterBool.lower(value),$0
    )
})
}
    
    /**
     * Timeout for sending event (default: 20 secs)
     *
     * If `None`, the default timeout will be used
     */
open func timeout(timeout: TimeInterval?) -> RelaySendOptions {
    return try!  FfiConverterTypeRelaySendOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaysendoptions_timeout(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    

}

public struct FfiConverterTypeRelaySendOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelaySendOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelaySendOptions {
        return RelaySendOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelaySendOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelaySendOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelaySendOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelaySendOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelaySendOptions {
    return try FfiConverterTypeRelaySendOptions.lift(pointer)
}

public func FfiConverterTypeRelaySendOptions_lower(_ value: RelaySendOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelaySendOptions.lower(value)
}




/**
 * Auto-closing subscribe options
 */
public protocol SubscribeAutoCloseOptionsProtocol : AnyObject {
    
    /**
     * Close subscription when `FilterOptions` is satisfied
     */
    func filter(filter: FilterOptions)  -> SubscribeAutoCloseOptions
    
    /**
     * Automatically close subscription after `Duration`
     */
    func timeout(timeout: TimeInterval?)  -> SubscribeAutoCloseOptions
    
}

/**
 * Auto-closing subscribe options
 */
open class SubscribeAutoCloseOptions:
    SubscribeAutoCloseOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_subscribeautocloseoptions(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_subscribeautocloseoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_subscribeautocloseoptions(pointer, $0) }
    }

    

    
    /**
     * Close subscription when `FilterOptions` is satisfied
     */
open func filter(filter: FilterOptions) -> SubscribeAutoCloseOptions {
    return try!  FfiConverterTypeSubscribeAutoCloseOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_filter(self.uniffiClonePointer(),
        FfiConverterTypeFilterOptions.lower(filter),$0
    )
})
}
    
    /**
     * Automatically close subscription after `Duration`
     */
open func timeout(timeout: TimeInterval?) -> SubscribeAutoCloseOptions {
    return try!  FfiConverterTypeSubscribeAutoCloseOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_timeout(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    

}

public struct FfiConverterTypeSubscribeAutoCloseOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SubscribeAutoCloseOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeAutoCloseOptions {
        return SubscribeAutoCloseOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SubscribeAutoCloseOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubscribeAutoCloseOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SubscribeAutoCloseOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSubscribeAutoCloseOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeAutoCloseOptions {
    return try FfiConverterTypeSubscribeAutoCloseOptions.lift(pointer)
}

public func FfiConverterTypeSubscribeAutoCloseOptions_lower(_ value: SubscribeAutoCloseOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSubscribeAutoCloseOptions.lower(value)
}




/**
 * Subscribe options
 */
public protocol SubscribeOptionsProtocol : AnyObject {
    
    /**
     * Set auto-close conditions
     */
    func closeOn(opts: SubscribeAutoCloseOptions?)  -> SubscribeOptions
    
    /**
     * Set [RelaySendOptions]
     */
    func sendOpts(opts: RelaySendOptions)  -> SubscribeOptions
    
}

/**
 * Subscribe options
 */
open class SubscribeOptions:
    SubscribeOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_subscribeoptions(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_subscribeoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_subscribeoptions(pointer, $0) }
    }

    

    
    /**
     * Set auto-close conditions
     */
open func closeOn(opts: SubscribeAutoCloseOptions?) -> SubscribeOptions {
    return try!  FfiConverterTypeSubscribeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeoptions_close_on(self.uniffiClonePointer(),
        FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts),$0
    )
})
}
    
    /**
     * Set [RelaySendOptions]
     */
open func sendOpts(opts: RelaySendOptions) -> SubscribeOptions {
    return try!  FfiConverterTypeSubscribeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeoptions_send_opts(self.uniffiClonePointer(),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
})
}
    

}

public struct FfiConverterTypeSubscribeOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SubscribeOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeOptions {
        return SubscribeOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SubscribeOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubscribeOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SubscribeOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSubscribeOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeOptions {
    return try FfiConverterTypeSubscribeOptions.lift(pointer)
}

public func FfiConverterTypeSubscribeOptions_lower(_ value: SubscribeOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSubscribeOptions.lower(value)
}




/**
 * Zap Details
 */
public protocol ZapDetailsProtocol : AnyObject {
    
    /**
     * Add message
     */
    func message(message: String)  -> ZapDetails
    
}

/**
 * Zap Details
 */
open class ZapDetails:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    ZapDetailsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_zapdetails(self.pointer, $0) }
    }
    /**
     * Create new Zap Details
     *
     * **Note: `private` zaps are not currently supported here!**
     */
public convenience init(zapType: ZapType) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_zapdetails_new(
        FfiConverterTypeZapType_lower(zapType),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_zapdetails(pointer, $0) }
    }

    

    
    /**
     * Add message
     */
open func message(message: String) -> ZapDetails {
    return try!  FfiConverterTypeZapDetails.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapdetails_message(self.uniffiClonePointer(),
        FfiConverterString.lower(message),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapdetails_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: ZapDetails, other: ZapDetails) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapdetails_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeZapDetails.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapdetails_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeZapDetails: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZapDetails

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapDetails {
        return ZapDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZapDetails) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZapDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZapDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeZapDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapDetails {
    return try FfiConverterTypeZapDetails.lift(pointer)
}

public func FfiConverterTypeZapDetails_lower(_ value: ZapDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZapDetails.lower(value)
}




/**
 * Zap entity
 */
public protocol ZapEntityProtocol : AnyObject {
    
}

/**
 * Zap entity
 */
open class ZapEntity:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    ZapEntityProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_zapentity(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_zapentity(pointer, $0) }
    }

    
public static func event(eventId: EventId) -> ZapEntity {
    return try!  FfiConverterTypeZapEntity.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_zapentity_event(
        FfiConverterTypeEventId_lower(eventId),$0
    )
})
}
    
public static func publicKey(publicKey: PublicKey) -> ZapEntity {
    return try!  FfiConverterTypeZapEntity.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_zapentity_public_key(
        FfiConverterTypePublicKey_lower(publicKey),$0
    )
})
}
    

    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapentity_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: ZapEntity, other: ZapEntity) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapentity_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeZapEntity.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapentity_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeZapEntity: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZapEntity

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapEntity {
        return ZapEntity(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZapEntity) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZapEntity {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZapEntity, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeZapEntity_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapEntity {
    return try FfiConverterTypeZapEntity.lift(pointer)
}

public func FfiConverterTypeZapEntity_lower(_ value: ZapEntity) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZapEntity.lower(value)
}


public struct NegentropyItem {
    public var id: EventId
    public var timestamp: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: EventId, timestamp: Timestamp) {
        self.id = id
        self.timestamp = timestamp
    }
}



public struct FfiConverterTypeNegentropyItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NegentropyItem {
        return
            try NegentropyItem(
                id: FfiConverterTypeEventId.read(from: &buf), 
                timestamp: FfiConverterTypeTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: NegentropyItem, into buf: inout [UInt8]) {
        FfiConverterTypeEventId.write(value.id, into: &buf)
        FfiConverterTypeTimestamp.write(value.timestamp, into: &buf)
    }
}


public func FfiConverterTypeNegentropyItem_lift(_ buf: RustBuffer) throws -> NegentropyItem {
    return try FfiConverterTypeNegentropyItem.lift(buf)
}

public func FfiConverterTypeNegentropyItem_lower(_ value: NegentropyItem) -> RustBuffer {
    return FfiConverterTypeNegentropyItem.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Filter options
 */

public enum FilterOptions {
    
    /**
     * Exit on EOSE
     */
    case exitOnEose
    /**
     * After EOSE is received, keep listening for N more events that match the filter, then return
     */
    case waitForEventsAfterEose(num: UInt16
    )
    /**
     * After EOSE is received, keep listening for matching events for `Duration` more time, then return
     */
    case waitDurationAfterEose(duration: TimeInterval
    )
}


public struct FfiConverterTypeFilterOptions: FfiConverterRustBuffer {
    typealias SwiftType = FilterOptions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FilterOptions {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .exitOnEose
        
        case 2: return .waitForEventsAfterEose(num: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 3: return .waitDurationAfterEose(duration: try FfiConverterDuration.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FilterOptions, into buf: inout [UInt8]) {
        switch value {
        
        
        case .exitOnEose:
            writeInt(&buf, Int32(1))
        
        
        case let .waitForEventsAfterEose(num):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(num, into: &buf)
            
        
        case let .waitDurationAfterEose(duration):
            writeInt(&buf, Int32(3))
            FfiConverterDuration.write(duration, into: &buf)
            
        }
    }
}


public func FfiConverterTypeFilterOptions_lift(_ buf: RustBuffer) throws -> FilterOptions {
    return try FfiConverterTypeFilterOptions.lift(buf)
}

public func FfiConverterTypeFilterOptions_lower(_ value: FilterOptions) -> RustBuffer {
    return FfiConverterTypeFilterOptions.lower(value)
}



extension FilterOptions: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogLevel {
    
    case error
    case warn
    case info
    case debug
    case trace
}


public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .error
        
        case 2: return .warn
        
        case 3: return .info
        
        case 4: return .debug
        
        case 5: return .trace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .error:
            writeInt(&buf, Int32(1))
        
        
        case .warn:
            writeInt(&buf, Int32(2))
        
        
        case .info:
            writeInt(&buf, Int32(3))
        
        
        case .debug:
            writeInt(&buf, Int32(4))
        
        
        case .trace:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}



extension LogLevel: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NegentropyDirection {
    
    case up
    case down
    case both
}


public struct FfiConverterTypeNegentropyDirection: FfiConverterRustBuffer {
    typealias SwiftType = NegentropyDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NegentropyDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .up
        
        case 2: return .down
        
        case 3: return .both
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NegentropyDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .up:
            writeInt(&buf, Int32(1))
        
        
        case .down:
            writeInt(&buf, Int32(2))
        
        
        case .both:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeNegentropyDirection_lift(_ buf: RustBuffer) throws -> NegentropyDirection {
    return try FfiConverterTypeNegentropyDirection.lift(buf)
}

public func FfiConverterTypeNegentropyDirection_lower(_ value: NegentropyDirection) -> RustBuffer {
    return FfiConverterTypeNegentropyDirection.lower(value)
}



extension NegentropyDirection: Equatable, Hashable {}




public enum NostrSdkError {

    
    
    case Generic(message: String)
    
}


public struct FfiConverterTypeNostrSdkError: FfiConverterRustBuffer {
    typealias SwiftType = NostrSdkError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrSdkError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NostrSdkError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


extension NostrSdkError: Equatable, Hashable {}

extension NostrSdkError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Proxy target
 */

public enum ProxyTarget {
    
    /**
     * Use proxy for all relays
     */
    case all
    /**
     * Use proxy only for `.onion` relays
     */
    case onion
}


public struct FfiConverterTypeProxyTarget: FfiConverterRustBuffer {
    typealias SwiftType = ProxyTarget

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProxyTarget {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .all
        
        case 2: return .onion
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProxyTarget, into buf: inout [UInt8]) {
        switch value {
        
        
        case .all:
            writeInt(&buf, Int32(1))
        
        
        case .onion:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeProxyTarget_lift(_ buf: RustBuffer) throws -> ProxyTarget {
    return try FfiConverterTypeProxyTarget.lift(buf)
}

public func FfiConverterTypeProxyTarget_lower(_ value: ProxyTarget) -> RustBuffer {
    return FfiConverterTypeProxyTarget.lower(value)
}



extension ProxyTarget: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RelayStatus {
    
    /**
     * Relay initialized
     */
    case initialized
    /**
     * Pending
     */
    case pending
    /**
     * Connecting
     */
    case connecting
    /**
     * Relay connected
     */
    case connected
    /**
     * Relay disconnected, will retry to connect again
     */
    case disconnected
    /**
     * Stop
     */
    case stopped
    /**
     * Relay completely disconnected
     */
    case terminated
}


public struct FfiConverterTypeRelayStatus: FfiConverterRustBuffer {
    typealias SwiftType = RelayStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initialized
        
        case 2: return .pending
        
        case 3: return .connecting
        
        case 4: return .connected
        
        case 5: return .disconnected
        
        case 6: return .stopped
        
        case 7: return .terminated
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RelayStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .initialized:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case .connecting:
            writeInt(&buf, Int32(3))
        
        
        case .connected:
            writeInt(&buf, Int32(4))
        
        
        case .disconnected:
            writeInt(&buf, Int32(5))
        
        
        case .stopped:
            writeInt(&buf, Int32(6))
        
        
        case .terminated:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeRelayStatus_lift(_ buf: RustBuffer) throws -> RelayStatus {
    return try FfiConverterTypeRelayStatus.lift(buf)
}

public func FfiConverterTypeRelayStatus_lower(_ value: RelayStatus) -> RustBuffer {
    return FfiConverterTypeRelayStatus.lower(value)
}



extension RelayStatus: Equatable, Hashable {}



fileprivate struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDuration.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDuration.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeNostrSigner: FfiConverterRustBuffer {
    typealias SwiftType = NostrSigner?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNostrSigner.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNostrSigner.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRelayOptions: FfiConverterRustBuffer {
    typealias SwiftType = RelayOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRelayOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRelayOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSubscribeAutoCloseOptions: FfiConverterRustBuffer {
    typealias SwiftType = SubscribeAutoCloseOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSubscribeAutoCloseOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSubscribeAutoCloseOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeZapDetails: FfiConverterRustBuffer {
    typealias SwiftType = ZapDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZapDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZapDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = [Filter]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFilter.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFilter.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventId: FfiConverterRustBuffer {
    typealias SwiftType = EventId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Timestamp?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTimestamp.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTimestamp.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNegentropyItem: FfiConverterRustBuffer {
    typealias SwiftType = [NegentropyItem]

    public static func write(_ value: [NegentropyItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNegentropyItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NegentropyItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [NegentropyItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNegentropyItem.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeClientMessage: FfiConverterRustBuffer {
    typealias SwiftType = [ClientMessage]

    public static func write(_ value: [ClientMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeClientMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ClientMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [ClientMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeClientMessage.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = [Event]

    public static func write(_ value: [Event], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEvent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Event] {
        let len: Int32 = try readInt(&buf)
        var seq = [Event]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEvent.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeEventId: FfiConverterRustBuffer {
    typealias SwiftType = [EventId]

    public static func write(_ value: [EventId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEventId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EventId] {
        let len: Int32 = try readInt(&buf)
        var seq = [EventId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEventId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = [Filter]

    public static func write(_ value: [Filter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Filter] {
        let len: Int32 = try readInt(&buf)
        var seq = [Filter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFilter.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLookupInvoiceResponseResult: FfiConverterRustBuffer {
    typealias SwiftType = [LookupInvoiceResponseResult]

    public static func write(_ value: [LookupInvoiceResponseResult], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLookupInvoiceResponseResult.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LookupInvoiceResponseResult] {
        let len: Int32 = try readInt(&buf)
        var seq = [LookupInvoiceResponseResult]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLookupInvoiceResponseResult.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    public static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringTypeRelay: FfiConverterRustBuffer {
    public static func write(_ value: [String: Relay], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeRelay.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Relay] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Relay]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeRelay.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceTypeFilter: FfiConverterRustBuffer {
    public static func write(_ value: [String: [Filter]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeFilter.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [Filter]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [Filter]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeFilter.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
























































private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountNostrSdkFfi() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
public func initLogger(level: LogLevel) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_func_init_logger(
        FfiConverterTypeLogLevel.lower(level),$0
    )
}
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_nostr_sdk_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_init_logger() != 38847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_aborthandle_abort() != 2978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_aborthandle_is_aborted() != 57233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_add_relay() != 58887) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_add_relay_with_opts() != 36241) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_add_relays() != 46859) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_blacklist() != 3155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_connect() != 30312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_connect_relay() != 31242) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_connect_with_timeout() != 16188) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_database() != 35722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_disconnect() != 21461) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_disconnect_relay() != 63825) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_dislike() != 45018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_file_metadata() != 184) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_get_events_from() != 26170) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_get_events_of() != 65200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap() != 2702) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_handle_notifications() != 28993) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_like() != 15887) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_mute_ids() != 26708) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_mute_public_keys() != 39159) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_reaction() != 22977) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_reconcile() != 20435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_relay() != 53414) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_relays() != 25563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_remove_relay() != 5421) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_repost() != 40218) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_direct_msg() != 1848) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event() != 21572) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder() != 45356) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder_to() != 10153) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event_to() != 46323) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_msg() != 23270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_msg_to() != 33600) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_private_msg() != 36975) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_set_metadata() != 62641) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_shutdown() != 16786) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_sign_event_builder() != 47615) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_signer() != 31951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_start() != 56287) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_stop() != 5883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscribe() != 42253) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_to() != 52934) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id() != 40087) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id_to() != 23017) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscription() != 1946) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscriptions() != 20072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_unmute_ids() != 55190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_unmute_public_keys() != 32497) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe() != 16499) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe_all() != 37740) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_update_difficulty() != 12551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_update_min_pow_difficulty() != 58908) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_zap() != 33763) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_build() != 61424) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_database() != 21061) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_opts() != 22620) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_signer() != 30905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_zapper() != 2114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_backend() != 43310) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_save_event() != 44808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_has_event_already_been_saved() != 31021) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_has_event_already_been_seen() != 60236) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_has_event_id_been_deleted() != 63072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_has_coordinate_been_deleted() != 45636) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_event_id_seen() != 22968) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_event_seen_on_relays() != 3595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_event_by_id() != 18741) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_count() != 39553) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_query() != 55160) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_delete() != 41600) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_wipe() != 8668) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle_msg() != 15446) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle() != 58660) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_get_balance() != 30742) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_get_info() != 13299) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_list_transactions() != 27417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_lookup_invoice() != 14000) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_make_invoice() != 26233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_invoice() != 28548) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_keysend() != 7487) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_negentropyoptions_direction() != 49635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_negentropyoptions_initial_timeout() != 40199) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip46signer_nostr_connect_uri() != 42112) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip46signer_relays() != 52111) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip46signer_signer_public_key() != 60994) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnectremotesigner_nostr_connect_uri() != 15397) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnectremotesigner_relays() != 20744) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnectremotesigner_serve() != 40586) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnectsigneractions_approve() != 33577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_count() != 63911) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_delete() != 19224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_event_by_id() != 15873) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_event_seen_on_relays() != 47905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_profile() != 30385) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_query() != 20702) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_save_event() != 62854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_wipe() != 58001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_decrypt() != 13688) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_encrypt() != 22096) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_decrypt() != 16401) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_encrypt() != 37397) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_public_key() != 58772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_sign_event() != 49886) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_sign_event_builder() != 4087) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_proxy() != 51105) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_timeout() != 18259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_automatic_authentication() != 33238) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_connection_timeout() != 57708) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_difficulty() != 20804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_min_pow() != 54102) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_proxy() != 35233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_relay_limits() != 11682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_req_filters_chunk_size() != 19808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_send_timeout() != 11614) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_skip_disconnected_relays() != 28418) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_timeout() != 10820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_wait_for_send() != 50702) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_wait_for_subscription() != 52599) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_profile_metadata() != 34875) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_profile_name() != 10929) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_profile_public_key() != 31716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_proxy_target() != 3274) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_batch_event() != 30109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_batch_msg() != 15403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_blacklist() != 35021) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_connect() != 15421) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_count_events_of() != 10925) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_document() != 55628) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_get_events_of() != 45379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_is_connected() != 50961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_opts() != 21198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_proxy() != 64699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_queue() != 23174) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_reconcile() != 28623) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_reconcile_with_items() != 36069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_send_event() != 20786) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_send_msg() != 20244) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_stats() != 58574) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_status() != 14630) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_stop() != 30140) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe() != 7870) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe_with_id() != 33573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscription() != 14346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscriptions() != 24939) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_support_negentropy() != 5020) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_terminate() != 14116) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe() != 20812) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe_all() != 32815) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_url() != 1351) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayblacklist_add_ids() != 56523) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayblacklist_add_public_keys() != 28791) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayblacklist_clear() != 40843) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayblacklist_has_id() != 25951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayblacklist_has_public_key() != 23755) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayblacklist_remove_id() != 32469) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayblacklist_remove_ids() != 19470) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayblacklist_remove_public_key() != 59175) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayblacklist_remove_public_keys() != 53857) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_attempts() != 52060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_received() != 157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_sent() != 64970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_connected_at() != 17598) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_first_connection_timestamp() != 30824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_latency() != 43153) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_success() != 52759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_uptime() != 29449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags() != 29781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags_per_kind() != 24819) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size() != 63930) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size_per_kind() != 61881) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_message_max_size() != 9957) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_adjust_retry_sec() != 36994) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_limits() != 10405) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_ping() != 51607) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_pow() != 37387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_proxy() != 35156) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_read() != 47081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_reconnect() != 48820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_retry_sec() != 58762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_update_adjust_retry_sec() != 1296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_update_pow_difficulty() != 44137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_update_reconnect() != 23173) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_update_retry_sec() != 43799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_write() != 45946) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_add_relay() != 60070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_batch_event() != 42567) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_batch_event_to() != 41056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_batch_msg() != 64663) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_batch_msg_to() != 28777) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_blacklist() != 51161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_connect() != 31806) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_connect_relay() != 36418) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_database() != 4532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_disconnect() != 51163) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_get_events_from() != 4190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_get_events_of() != 43124) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_handle_notifications() != 30926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_reconcile() != 23893) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_reconcile_with_items() != 24471) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_relay() != 11676) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_relays() != 54295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_remove_all_relay() != 16039) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_remove_relay() != 40859) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_send_event() != 42595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_send_event_to() != 2470) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_send_msg() != 42206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_send_msg_to() != 32868) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_shutdown() != 24603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_start() != 5721) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_stop() != 12232) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscribe() != 14801) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscribe_to() != 43114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscribe_with_id() != 64497) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscribe_with_id_to() != 64099) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscription() != 18304) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscriptions() != 34853) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_unsubscribe() != 28366) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_unsubscribe_all() != 15780) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaysendoptions_skip_disconnected() != 4190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaysendoptions_skip_send_confirmation() != 22060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaysendoptions_timeout() != 16256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_filter() != 17195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_timeout() != 36298) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeoptions_close_on() != 31672) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeoptions_send_opts() != 55685) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_zapdetails_message() != 43166) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_client_new() != 54751) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_client_with_opts() != 35054) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_clientbuilder_new() != 11332) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nwc_new() != 26100) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nwc_with_opts() != 18653) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_negentropyoptions_new() != 15449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip46signer_init() != 34524) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnectremotesigner_from_uri() != 28026) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnectremotesigner_init() != 6872) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_custom() != 2448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_ndb() != 25092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_sqlite() != 42455) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_keys() != 51910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_nip46() != 28927) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnectoptions_new() != 35456) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrzapper_nwc() != 65346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_options_new() != 30503) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_profile_new() != 65224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_proxy_new() != 51726) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relay_custom() != 17945) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relay_new() != 3279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relay_with_opts() != 9335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relayblacklist_empty() != 38614) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relayblacklist_new() != 62518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_disable() != 39641) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_new() != 1364) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relayoptions_new() != 32157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaypool_new() != 50786) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaypool_with_database() != 59953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaysendoptions_new() != 31427) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_subscribeautocloseoptions_new() != 39595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_subscribeoptions_new() != 56214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_zapdetails_new() != 18563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_zapentity_event() != 61043) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_zapentity_public_key() != 56616) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitHandleNotification()
    uniffiCallbackInitNostrConnectSignerActions()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all