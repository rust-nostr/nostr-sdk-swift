// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(nostr_sdkFFI)
import nostr_sdkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_nostr_sdk_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_nostr_sdk_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}


public protocol ActiveSubscriptionProtocol {
    func filters()   -> [Filter]
    func id()   -> String
    
}

public class ActiveSubscription: ActiveSubscriptionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_activesubscription(pointer, $0) }
    }

    

    
    

    public func filters()  -> [Filter] {
        return try!  FfiConverterSequenceTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_activesubscription_filters(self.pointer, $0
    )
}
        )
    }

    public func id()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_activesubscription_id(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeActiveSubscription: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ActiveSubscription

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ActiveSubscription {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ActiveSubscription, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ActiveSubscription {
        return ActiveSubscription(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ActiveSubscription) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeActiveSubscription_lift(_ pointer: UnsafeMutableRawPointer) throws -> ActiveSubscription {
    return try FfiConverterTypeActiveSubscription.lift(pointer)
}

public func FfiConverterTypeActiveSubscription_lower(_ value: ActiveSubscription) -> UnsafeMutableRawPointer {
    return FfiConverterTypeActiveSubscription.lower(value)
}


public protocol ClientProtocol {
    func addRelay(url: String, proxy: String?)  throws
    func clearAlreadySeenEvents()  
    func connect()  
    func connectRelay(url: String)  throws
    func disconnect()  throws
    func disconnectRelay(url: String)  throws
    func fileMetadata(description: String, metadata: FileMetadata)  throws -> EventId
    func getEventsOf(filters: [Filter], timeout: TimeInterval?)  throws -> [Event]
    func handleNotifications(handler: HandleNotification)  
    func isRunning()   -> Bool
    func keys()   -> Keys
    func relay(url: String)  throws -> Relay
    func relays()   -> [String: Relay]
    func removeRelay(url: String)  throws
    func reqEventsOf(filters: [Filter], timeout: TimeInterval?)  
    func sendDirectMsg(receiver: PublicKey, msg: String, reply: EventId?)  throws -> EventId
    func sendEvent(event: Event)  throws -> EventId
    func sendEventTo(url: String, event: Event)  throws -> EventId
    func sendMsg(msg: ClientMessage)  throws
    func sendMsgTo(url: String, msg: ClientMessage)  throws
    func setMetadata(metadata: Metadata)  throws -> EventId
    func shutdown()  throws
    func start()  
    func stop()  throws
    func subscribe(filters: [Filter])  
    func unsubscribe()  
    func updateDifficulty(difficulty: UInt8)  
    
}

public class Client: ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(keys: Keys)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_client_new(
        FfiConverterTypeKeys.lower(keys),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_client(pointer, $0) }
    }

    

    public static func withOpts(keys: Keys, opts: Options)  -> Client {
        return Client(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_client_with_opts(
        FfiConverterTypeKeys.lower(keys),
        FfiConverterTypeOptions.lower(opts),$0)
})
    }

    

    
    

    public func addRelay(url: String, proxy: String? = nil) throws {
        try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_add_relay(self.pointer, 
        FfiConverterString.lower(url),
        FfiConverterOptionString.lower(proxy),$0
    )
}
    }

    public func clearAlreadySeenEvents()  {
        try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_client_clear_already_seen_events(self.pointer, $0
    )
}
    }

    public func connect()  {
        try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_client_connect(self.pointer, $0
    )
}
    }

    public func connectRelay(url: String) throws {
        try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_connect_relay(self.pointer, 
        FfiConverterString.lower(url),$0
    )
}
    }

    public func disconnect() throws {
        try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_disconnect(self.pointer, $0
    )
}
    }

    public func disconnectRelay(url: String) throws {
        try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_disconnect_relay(self.pointer, 
        FfiConverterString.lower(url),$0
    )
}
    }

    public func fileMetadata(description: String, metadata: FileMetadata) throws -> EventId {
        return try  FfiConverterTypeEventId.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_file_metadata(self.pointer, 
        FfiConverterString.lower(description),
        FfiConverterTypeFileMetadata.lower(metadata),$0
    )
}
        )
    }

    public func getEventsOf(filters: [Filter], timeout: TimeInterval?) throws -> [Event] {
        return try  FfiConverterSequenceTypeEvent.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_get_events_of(self.pointer, 
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterOptionDuration.lower(timeout),$0
    )
}
        )
    }

    public func handleNotifications(handler: HandleNotification)  {
        try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_client_handle_notifications(self.pointer, 
        FfiConverterCallbackInterfaceHandleNotification.lower(handler),$0
    )
}
    }

    public func isRunning()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_client_is_running(self.pointer, $0
    )
}
        )
    }

    public func keys()  -> Keys {
        return try!  FfiConverterTypeKeys.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_client_keys(self.pointer, $0
    )
}
        )
    }

    public func relay(url: String) throws -> Relay {
        return try  FfiConverterTypeRelay.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_relay(self.pointer, 
        FfiConverterString.lower(url),$0
    )
}
        )
    }

    public func relays()  -> [String: Relay] {
        return try!  FfiConverterDictionaryStringTypeRelay.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_client_relays(self.pointer, $0
    )
}
        )
    }

    public func removeRelay(url: String) throws {
        try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_remove_relay(self.pointer, 
        FfiConverterString.lower(url),$0
    )
}
    }

    public func reqEventsOf(filters: [Filter], timeout: TimeInterval?)  {
        try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_client_req_events_of(self.pointer, 
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterOptionDuration.lower(timeout),$0
    )
}
    }

    public func sendDirectMsg(receiver: PublicKey, msg: String, reply: EventId?) throws -> EventId {
        return try  FfiConverterTypeEventId.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_send_direct_msg(self.pointer, 
        FfiConverterTypePublicKey.lower(receiver),
        FfiConverterString.lower(msg),
        FfiConverterOptionTypeEventId.lower(reply),$0
    )
}
        )
    }

    public func sendEvent(event: Event) throws -> EventId {
        return try  FfiConverterTypeEventId.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_send_event(self.pointer, 
        FfiConverterTypeEvent.lower(event),$0
    )
}
        )
    }

    public func sendEventTo(url: String, event: Event) throws -> EventId {
        return try  FfiConverterTypeEventId.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_send_event_to(self.pointer, 
        FfiConverterString.lower(url),
        FfiConverterTypeEvent.lower(event),$0
    )
}
        )
    }

    public func sendMsg(msg: ClientMessage) throws {
        try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_send_msg(self.pointer, 
        FfiConverterTypeClientMessage.lower(msg),$0
    )
}
    }

    public func sendMsgTo(url: String, msg: ClientMessage) throws {
        try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_send_msg_to(self.pointer, 
        FfiConverterString.lower(url),
        FfiConverterTypeClientMessage.lower(msg),$0
    )
}
    }

    public func setMetadata(metadata: Metadata) throws -> EventId {
        return try  FfiConverterTypeEventId.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_set_metadata(self.pointer, 
        FfiConverterTypeMetadata.lower(metadata),$0
    )
}
        )
    }

    public func shutdown() throws {
        try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_shutdown(self.pointer, $0
    )
}
    }

    public func start()  {
        try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_client_start(self.pointer, $0
    )
}
    }

    public func stop() throws {
        try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_client_stop(self.pointer, $0
    )
}
    }

    public func subscribe(filters: [Filter])  {
        try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_client_subscribe(self.pointer, 
        FfiConverterSequenceTypeFilter.lower(filters),$0
    )
}
    }

    public func unsubscribe()  {
        try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_client_unsubscribe(self.pointer, $0
    )
}
    }

    public func updateDifficulty(difficulty: UInt8)  {
        try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_client_update_difficulty(self.pointer, 
        FfiConverterUInt8.lower(difficulty),$0
    )
}
    }
}

public struct FfiConverterTypeClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}


public protocol ContactProtocol {
    func alias()   -> String?
    func publicKey()   -> PublicKey
    func relayUrl()   -> String?
    
}

public class Contact: ContactProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(pk: PublicKey, relayUrl: String? = nil, alias: String? = nil)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_contact_new(
        FfiConverterTypePublicKey.lower(pk),
        FfiConverterOptionString.lower(relayUrl),
        FfiConverterOptionString.lower(alias),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_contact(pointer, $0) }
    }

    

    
    

    public func alias()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_contact_alias(self.pointer, $0
    )
}
        )
    }

    public func publicKey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_contact_public_key(self.pointer, $0
    )
}
        )
    }

    public func relayUrl()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_contact_relay_url(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeContact: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Contact

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Contact {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Contact, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Contact {
        return Contact(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Contact) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeContact_lift(_ pointer: UnsafeMutableRawPointer) throws -> Contact {
    return try FfiConverterTypeContact.lift(pointer)
}

public func FfiConverterTypeContact_lower(_ value: Contact) -> UnsafeMutableRawPointer {
    return FfiConverterTypeContact.lower(value)
}


public protocol EventProtocol {
    func asJson()   -> String
    func content()   -> String
    func createdAt()   -> Timestamp
    func id()   -> EventId
    func kind()   -> UInt64
    func pubkey()   -> PublicKey
    func signature()   -> String
    func tags()   -> [Tag]
    func verify()   -> Bool
    
}

public class Event: EventProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_event(pointer, $0) }
    }

    

    public static func fromJson(json: String) throws -> Event {
        return Event(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_event_from_json(
        FfiConverterString.lower(json),$0)
})
    }

    

    
    

    public func asJson()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_event_as_json(self.pointer, $0
    )
}
        )
    }

    public func content()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_event_content(self.pointer, $0
    )
}
        )
    }

    public func createdAt()  -> Timestamp {
        return try!  FfiConverterTypeTimestamp.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_event_created_at(self.pointer, $0
    )
}
        )
    }

    public func id()  -> EventId {
        return try!  FfiConverterTypeEventId.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_event_id(self.pointer, $0
    )
}
        )
    }

    public func kind()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_event_kind(self.pointer, $0
    )
}
        )
    }

    public func pubkey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_event_pubkey(self.pointer, $0
    )
}
        )
    }

    public func signature()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_event_signature(self.pointer, $0
    )
}
        )
    }

    public func tags()  -> [Tag] {
        return try!  FfiConverterSequenceTypeTag.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_event_tags(self.pointer, $0
    )
}
        )
    }

    public func verify()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_event_verify(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeEvent: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Event

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Event, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Event {
        return Event(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Event) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeEvent_lift(_ pointer: UnsafeMutableRawPointer) throws -> Event {
    return try FfiConverterTypeEvent.lift(pointer)
}

public func FfiConverterTypeEvent_lower(_ value: Event) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEvent.lower(value)
}


public protocol EventBuilderProtocol {
    func toEvent(keys: Keys)  throws -> Event
    func toPowEvent(keys: Keys, difficulty: UInt8)  throws -> Event
    func toUnsignedEvent(publicKey: PublicKey)   -> UnsignedEvent
    func toUnsignedPowEvent(publicKey: PublicKey, difficulty: UInt8)   -> UnsignedEvent
    
}

public class EventBuilder: EventBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(kind: UInt64, content: String, tags: [Tag]) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_new(
        FfiConverterUInt64.lower(kind),
        FfiConverterString.lower(content),
        FfiConverterSequenceTypeTag.lower(tags),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_eventbuilder(pointer, $0) }
    }

    

    public static func addRecommendedRelay(url: String) throws -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_add_recommended_relay(
        FfiConverterString.lower(url),$0)
})
    }

    

    public static func auth(challenge: String, relayUrl: String) throws -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_auth(
        FfiConverterString.lower(challenge),
        FfiConverterString.lower(relayUrl),$0)
})
    }

    

    public static func delete(ids: [EventId], reason: String? = nil)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_delete(
        FfiConverterSequenceTypeEventId.lower(ids),
        FfiConverterOptionString.lower(reason),$0)
})
    }

    

    public static func fileMetadata(description: String, metadata: FileMetadata)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_file_metadata(
        FfiConverterString.lower(description),
        FfiConverterTypeFileMetadata.lower(metadata),$0)
})
    }

    

    public static func hideChannelMsg(messageId: EventId, reason: String?)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_hide_channel_msg(
        FfiConverterTypeEventId.lower(messageId),
        FfiConverterOptionString.lower(reason),$0)
})
    }

    

    public static func longFormTextNote(content: String, tags: [Tag]) throws -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_long_form_text_note(
        FfiConverterString.lower(content),
        FfiConverterSequenceTypeTag.lower(tags),$0)
})
    }

    

    public static func muteChannelUser(publicKey: PublicKey, reason: String?)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_mute_channel_user(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterOptionString.lower(reason),$0)
})
    }

    

    public static func newChannel(metadata: Metadata)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_new_channel(
        FfiConverterTypeMetadata.lower(metadata),$0)
})
    }

    

    public static func newChannelMsg(channelId: String, relayUrl: String, content: String) throws -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_new_channel_msg(
        FfiConverterString.lower(channelId),
        FfiConverterString.lower(relayUrl),
        FfiConverterString.lower(content),$0)
})
    }

    

    public static func newEncryptedDirectMsg(senderKeys: Keys, receiverPubkey: PublicKey, content: String, replyTo: EventId?) throws -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_new_encrypted_direct_msg(
        FfiConverterTypeKeys.lower(senderKeys),
        FfiConverterTypePublicKey.lower(receiverPubkey),
        FfiConverterString.lower(content),
        FfiConverterOptionTypeEventId.lower(replyTo),$0)
})
    }

    

    public static func newReaction(eventId: EventId, publicKey: PublicKey, content: String)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_new_reaction(
        FfiConverterTypeEventId.lower(eventId),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(content),$0)
})
    }

    

    public static func newTextNote(content: String, tags: [Tag]) throws -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_new_text_note(
        FfiConverterString.lower(content),
        FfiConverterSequenceTypeTag.lower(tags),$0)
})
    }

    

    public static func newZapReceipt(bolt11: String, preimage: String?, zapRequest: Event)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_new_zap_receipt(
        FfiConverterString.lower(bolt11),
        FfiConverterOptionString.lower(preimage),
        FfiConverterTypeEvent.lower(zapRequest),$0)
})
    }

    

    public static func newZapRequest(data: ZapRequestData)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_new_zap_request(
        FfiConverterTypeZapRequestData.lower(data),$0)
})
    }

    

    public static func report(tags: [Tag], content: String)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_report(
        FfiConverterSequenceTypeTag.lower(tags),
        FfiConverterString.lower(content),$0)
})
    }

    

    public static func repost(eventId: EventId, publicKey: PublicKey)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_repost(
        FfiConverterTypeEventId.lower(eventId),
        FfiConverterTypePublicKey.lower(publicKey),$0)
})
    }

    

    public static func setChannelMetadata(channelId: String, relayUrl: String?, metadata: Metadata) throws -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_set_channel_metadata(
        FfiConverterString.lower(channelId),
        FfiConverterOptionString.lower(relayUrl),
        FfiConverterTypeMetadata.lower(metadata),$0)
})
    }

    

    public static func setContactList(list: [Contact])  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_set_contact_list(
        FfiConverterSequenceTypeContact.lower(list),$0)
})
    }

    

    public static func setMetadata(metadata: Metadata)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_eventbuilder_set_metadata(
        FfiConverterTypeMetadata.lower(metadata),$0)
})
    }

    

    
    

    public func toEvent(keys: Keys) throws -> Event {
        return try  FfiConverterTypeEvent.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_method_eventbuilder_to_event(self.pointer, 
        FfiConverterTypeKeys.lower(keys),$0
    )
}
        )
    }

    public func toPowEvent(keys: Keys, difficulty: UInt8) throws -> Event {
        return try  FfiConverterTypeEvent.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_method_eventbuilder_to_pow_event(self.pointer, 
        FfiConverterTypeKeys.lower(keys),
        FfiConverterUInt8.lower(difficulty),$0
    )
}
        )
    }

    public func toUnsignedEvent(publicKey: PublicKey)  -> UnsignedEvent {
        return try!  FfiConverterTypeUnsignedEvent.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_eventbuilder_to_unsigned_event(self.pointer, 
        FfiConverterTypePublicKey.lower(publicKey),$0
    )
}
        )
    }

    public func toUnsignedPowEvent(publicKey: PublicKey, difficulty: UInt8)  -> UnsignedEvent {
        return try!  FfiConverterTypeUnsignedEvent.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_eventbuilder_to_unsigned_pow_event(self.pointer, 
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterUInt8.lower(difficulty),$0
    )
}
        )
    }
}

public struct FfiConverterTypeEventBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeEventBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBuilder {
    return try FfiConverterTypeEventBuilder.lift(pointer)
}

public func FfiConverterTypeEventBuilder_lower(_ value: EventBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventBuilder.lower(value)
}


public protocol EventIdProtocol {
    func asBytes()   -> [UInt8]
    func toBech32()  throws -> String
    func toHex()   -> String
    func toNostrUri()  throws -> String
    
}

public class EventId: EventIdProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(pubkey: PublicKey, createdAt: Timestamp, kind: UInt64, tags: [[String]], content: String) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_eventid_new(
        FfiConverterTypePublicKey.lower(pubkey),
        FfiConverterTypeTimestamp.lower(createdAt),
        FfiConverterUInt64.lower(kind),
        FfiConverterSequenceSequenceString.lower(tags),
        FfiConverterString.lower(content),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_eventid(pointer, $0) }
    }

    

    public static func fromBech32(id: String) throws -> EventId {
        return EventId(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_eventid_from_bech32(
        FfiConverterString.lower(id),$0)
})
    }

    

    public static func fromBytes(bytes: [UInt8]) throws -> EventId {
        return EventId(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_eventid_from_bytes(
        FfiConverterSequenceUInt8.lower(bytes),$0)
})
    }

    

    public static func fromHex(hex: String) throws -> EventId {
        return EventId(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_eventid_from_hex(
        FfiConverterString.lower(hex),$0)
})
    }

    

    public static func fromNostrUri(uri: String) throws -> EventId {
        return EventId(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_eventid_from_nostr_uri(
        FfiConverterString.lower(uri),$0)
})
    }

    

    
    

    public func asBytes()  -> [UInt8] {
        return try!  FfiConverterSequenceUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_eventid_as_bytes(self.pointer, $0
    )
}
        )
    }

    public func toBech32() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_method_eventid_to_bech32(self.pointer, $0
    )
}
        )
    }

    public func toHex()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_eventid_to_hex(self.pointer, $0
    )
}
        )
    }

    public func toNostrUri() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_method_eventid_to_nostr_uri(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeEventId: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventId {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventId, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventId {
        return EventId(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventId) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeEventId_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventId {
    return try FfiConverterTypeEventId.lift(pointer)
}

public func FfiConverterTypeEventId_lower(_ value: EventId) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventId.lower(value)
}


public protocol FileMetadataProtocol {
    func aes256Gcm(key: String, iv: String)   -> FileMetadata
    func blurhash(blurhash: String)   -> FileMetadata
    func dimensions(dim: ImageDimensions)   -> FileMetadata
    func magnet(magnet: String)   -> FileMetadata
    func size(size: UInt64)   -> FileMetadata
    
}

public class FileMetadata: FileMetadataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(url: String, mimeType: String, hash: String) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_filemetadata_new(
        FfiConverterString.lower(url),
        FfiConverterString.lower(mimeType),
        FfiConverterString.lower(hash),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_filemetadata(pointer, $0) }
    }

    

    
    

    public func aes256Gcm(key: String, iv: String)  -> FileMetadata {
        return try!  FfiConverterTypeFileMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filemetadata_aes_256_gcm(self.pointer, 
        FfiConverterString.lower(key),
        FfiConverterString.lower(iv),$0
    )
}
        )
    }

    public func blurhash(blurhash: String)  -> FileMetadata {
        return try!  FfiConverterTypeFileMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filemetadata_blurhash(self.pointer, 
        FfiConverterString.lower(blurhash),$0
    )
}
        )
    }

    public func dimensions(dim: ImageDimensions)  -> FileMetadata {
        return try!  FfiConverterTypeFileMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filemetadata_dimensions(self.pointer, 
        FfiConverterTypeImageDimensions.lower(dim),$0
    )
}
        )
    }

    public func magnet(magnet: String)  -> FileMetadata {
        return try!  FfiConverterTypeFileMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filemetadata_magnet(self.pointer, 
        FfiConverterString.lower(magnet),$0
    )
}
        )
    }

    public func size(size: UInt64)  -> FileMetadata {
        return try!  FfiConverterTypeFileMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filemetadata_size(self.pointer, 
        FfiConverterUInt64.lower(size),$0
    )
}
        )
    }
}

public struct FfiConverterTypeFileMetadata: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FileMetadata

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FileMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FileMetadata {
        return FileMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FileMetadata) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeFileMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> FileMetadata {
    return try FfiConverterTypeFileMetadata.lift(pointer)
}

public func FfiConverterTypeFileMetadata_lower(_ value: FileMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFileMetadata.lower(value)
}


public protocol FilterProtocol {
    func asJson()   -> String
    func author(author: String)   -> Filter
    func authors(authors: [String])   -> Filter
    func customTag(tag: Alphabet, content: [String])   -> Filter
    func event(eventId: EventId)   -> Filter
    func events(ids: [EventId])   -> Filter
    func id(id: String)   -> Filter
    func identifier(identifier: String)   -> Filter
    func ids(ids: [String])   -> Filter
    func kind(kind: UInt64)   -> Filter
    func kinds(kinds: [UInt64])   -> Filter
    func limit(limit: UInt64)   -> Filter
    func pubkey(pubkey: PublicKey)   -> Filter
    func pubkeys(pubkeys: [PublicKey])   -> Filter
    func search(text: String)   -> Filter
    func since(timestamp: Timestamp)   -> Filter
    func until(timestamp: Timestamp)   -> Filter
    
}

public class Filter: FilterProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_filter_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_filter(pointer, $0) }
    }

    

    public static func fromJson(json: String) throws -> Filter {
        return Filter(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_filter_from_json(
        FfiConverterString.lower(json),$0)
})
    }

    

    
    

    public func asJson()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_as_json(self.pointer, $0
    )
}
        )
    }

    public func author(author: String)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_author(self.pointer, 
        FfiConverterString.lower(author),$0
    )
}
        )
    }

    public func authors(authors: [String])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_authors(self.pointer, 
        FfiConverterSequenceString.lower(authors),$0
    )
}
        )
    }

    public func customTag(tag: Alphabet, content: [String])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_custom_tag(self.pointer, 
        FfiConverterTypeAlphabet.lower(tag),
        FfiConverterSequenceString.lower(content),$0
    )
}
        )
    }

    public func event(eventId: EventId)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_event(self.pointer, 
        FfiConverterTypeEventId.lower(eventId),$0
    )
}
        )
    }

    public func events(ids: [EventId])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_events(self.pointer, 
        FfiConverterSequenceTypeEventId.lower(ids),$0
    )
}
        )
    }

    public func id(id: String)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_id(self.pointer, 
        FfiConverterString.lower(id),$0
    )
}
        )
    }

    public func identifier(identifier: String)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_identifier(self.pointer, 
        FfiConverterString.lower(identifier),$0
    )
}
        )
    }

    public func ids(ids: [String])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_ids(self.pointer, 
        FfiConverterSequenceString.lower(ids),$0
    )
}
        )
    }

    public func kind(kind: UInt64)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_kind(self.pointer, 
        FfiConverterUInt64.lower(kind),$0
    )
}
        )
    }

    public func kinds(kinds: [UInt64])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_kinds(self.pointer, 
        FfiConverterSequenceUInt64.lower(kinds),$0
    )
}
        )
    }

    public func limit(limit: UInt64)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_limit(self.pointer, 
        FfiConverterUInt64.lower(limit),$0
    )
}
        )
    }

    public func pubkey(pubkey: PublicKey)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_pubkey(self.pointer, 
        FfiConverterTypePublicKey.lower(pubkey),$0
    )
}
        )
    }

    public func pubkeys(pubkeys: [PublicKey])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_pubkeys(self.pointer, 
        FfiConverterSequenceTypePublicKey.lower(pubkeys),$0
    )
}
        )
    }

    public func search(text: String)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_search(self.pointer, 
        FfiConverterString.lower(text),$0
    )
}
        )
    }

    public func since(timestamp: Timestamp)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_since(self.pointer, 
        FfiConverterTypeTimestamp.lower(timestamp),$0
    )
}
        )
    }

    public func until(timestamp: Timestamp)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_filter_until(self.pointer, 
        FfiConverterTypeTimestamp.lower(timestamp),$0
    )
}
        )
    }
}

public struct FfiConverterTypeFilter: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Filter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Filter {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Filter, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Filter {
        return Filter(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Filter) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeFilter_lift(_ pointer: UnsafeMutableRawPointer) throws -> Filter {
    return try FfiConverterTypeFilter.lift(pointer)
}

public func FfiConverterTypeFilter_lower(_ value: Filter) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFilter.lower(value)
}


public protocol ImageDimensionsProtocol {
    func height()   -> UInt64
    func width()   -> UInt64
    
}

public class ImageDimensions: ImageDimensionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(width: UInt64, height: UInt64)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_imagedimensions_new(
        FfiConverterUInt64.lower(width),
        FfiConverterUInt64.lower(height),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_imagedimensions(pointer, $0) }
    }

    

    
    

    public func height()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_imagedimensions_height(self.pointer, $0
    )
}
        )
    }

    public func width()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_imagedimensions_width(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeImageDimensions: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ImageDimensions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageDimensions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ImageDimensions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ImageDimensions {
        return ImageDimensions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ImageDimensions) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeImageDimensions_lift(_ pointer: UnsafeMutableRawPointer) throws -> ImageDimensions {
    return try FfiConverterTypeImageDimensions.lift(pointer)
}

public func FfiConverterTypeImageDimensions_lower(_ value: ImageDimensions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeImageDimensions.lower(value)
}


public protocol KeysProtocol {
    func publicKey()   -> PublicKey
    func secretKey()  throws -> SecretKey
    
}

public class Keys: KeysProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(sk: SecretKey)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_keys_new(
        FfiConverterTypeSecretKey.lower(sk),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_keys(pointer, $0) }
    }

    

    public static func fromMnemonic(mnemonic: String, passphrase: String? = nil) throws -> Keys {
        return Keys(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_keys_from_mnemonic(
        FfiConverterString.lower(mnemonic),
        FfiConverterOptionString.lower(passphrase),$0)
})
    }

    

    public static func fromPkStr(pk: String) throws -> Keys {
        return Keys(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_keys_from_pk_str(
        FfiConverterString.lower(pk),$0)
})
    }

    

    public static func fromPublicKey(pk: PublicKey)  -> Keys {
        return Keys(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_keys_from_public_key(
        FfiConverterTypePublicKey.lower(pk),$0)
})
    }

    

    public static func fromSkStr(sk: String) throws -> Keys {
        return Keys(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_keys_from_sk_str(
        FfiConverterString.lower(sk),$0)
})
    }

    

    public static func generate()  -> Keys {
        return Keys(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_keys_generate($0)
})
    }

    

    public static func vanity(prefixes: [String], bech32: Bool, numCores: UInt8) throws -> Keys {
        return Keys(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_keys_vanity(
        FfiConverterSequenceString.lower(prefixes),
        FfiConverterBool.lower(bech32),
        FfiConverterUInt8.lower(numCores),$0)
})
    }

    

    
    

    public func publicKey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_keys_public_key(self.pointer, $0
    )
}
        )
    }

    public func secretKey() throws -> SecretKey {
        return try  FfiConverterTypeSecretKey.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_method_keys_secret_key(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeKeys: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Keys

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Keys {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Keys, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Keys {
        return Keys(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Keys) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeKeys_lift(_ pointer: UnsafeMutableRawPointer) throws -> Keys {
    return try FfiConverterTypeKeys.lift(pointer)
}

public func FfiConverterTypeKeys_lower(_ value: Keys) -> UnsafeMutableRawPointer {
    return FfiConverterTypeKeys.lower(value)
}


public protocol MetadataProtocol {
    func asJson()   -> String
    func getAbout()   -> String?
    func getBanner()   -> String?
    func getDisplayName()   -> String?
    func getLud06()   -> String?
    func getLud16()   -> String?
    func getName()   -> String?
    func getNip05()   -> String?
    func getPicture()   -> String?
    func getWebsite()   -> String?
    func setAbout(about: String)   -> Metadata
    func setBanner(banner: String)  throws -> Metadata
    func setDisplayName(displayName: String)   -> Metadata
    func setLud06(lud06: String)   -> Metadata
    func setLud16(lud16: String)   -> Metadata
    func setName(name: String)   -> Metadata
    func setNip05(nip05: String)   -> Metadata
    func setPicture(picture: String)  throws -> Metadata
    func setWebsite(website: String)  throws -> Metadata
    
}

public class Metadata: MetadataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_metadata_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_metadata(pointer, $0) }
    }

    

    public static func fromJson(json: String) throws -> Metadata {
        return Metadata(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_metadata_from_json(
        FfiConverterString.lower(json),$0)
})
    }

    

    
    

    public func asJson()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_as_json(self.pointer, $0
    )
}
        )
    }

    public func getAbout()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_get_about(self.pointer, $0
    )
}
        )
    }

    public func getBanner()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_get_banner(self.pointer, $0
    )
}
        )
    }

    public func getDisplayName()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_get_display_name(self.pointer, $0
    )
}
        )
    }

    public func getLud06()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_get_lud06(self.pointer, $0
    )
}
        )
    }

    public func getLud16()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_get_lud16(self.pointer, $0
    )
}
        )
    }

    public func getName()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_get_name(self.pointer, $0
    )
}
        )
    }

    public func getNip05()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_get_nip05(self.pointer, $0
    )
}
        )
    }

    public func getPicture()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_get_picture(self.pointer, $0
    )
}
        )
    }

    public func getWebsite()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_get_website(self.pointer, $0
    )
}
        )
    }

    public func setAbout(about: String)  -> Metadata {
        return try!  FfiConverterTypeMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_set_about(self.pointer, 
        FfiConverterString.lower(about),$0
    )
}
        )
    }

    public func setBanner(banner: String) throws -> Metadata {
        return try  FfiConverterTypeMetadata.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_method_metadata_set_banner(self.pointer, 
        FfiConverterString.lower(banner),$0
    )
}
        )
    }

    public func setDisplayName(displayName: String)  -> Metadata {
        return try!  FfiConverterTypeMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_set_display_name(self.pointer, 
        FfiConverterString.lower(displayName),$0
    )
}
        )
    }

    public func setLud06(lud06: String)  -> Metadata {
        return try!  FfiConverterTypeMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_set_lud06(self.pointer, 
        FfiConverterString.lower(lud06),$0
    )
}
        )
    }

    public func setLud16(lud16: String)  -> Metadata {
        return try!  FfiConverterTypeMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_set_lud16(self.pointer, 
        FfiConverterString.lower(lud16),$0
    )
}
        )
    }

    public func setName(name: String)  -> Metadata {
        return try!  FfiConverterTypeMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_set_name(self.pointer, 
        FfiConverterString.lower(name),$0
    )
}
        )
    }

    public func setNip05(nip05: String)  -> Metadata {
        return try!  FfiConverterTypeMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_metadata_set_nip05(self.pointer, 
        FfiConverterString.lower(nip05),$0
    )
}
        )
    }

    public func setPicture(picture: String) throws -> Metadata {
        return try  FfiConverterTypeMetadata.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_method_metadata_set_picture(self.pointer, 
        FfiConverterString.lower(picture),$0
    )
}
        )
    }

    public func setWebsite(website: String) throws -> Metadata {
        return try  FfiConverterTypeMetadata.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_method_metadata_set_website(self.pointer, 
        FfiConverterString.lower(website),$0
    )
}
        )
    }
}

public struct FfiConverterTypeMetadata: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Metadata

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Metadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Metadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Metadata {
        return Metadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Metadata) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> Metadata {
    return try FfiConverterTypeMetadata.lift(pointer)
}

public func FfiConverterTypeMetadata_lower(_ value: Metadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMetadata.lower(value)
}


public protocol NostrConnectURIProtocol {
    func description()   -> String?
    func name()   -> String
    func publicKey()   -> PublicKey
    func relayUrl()   -> String
    func url()   -> String?
    
}

public class NostrConnectUri: NostrConnectURIProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_nostrconnecturi(pointer, $0) }
    }

    

    public static func fromString(uri: String) throws -> NostrConnectUri {
        return NostrConnectUri(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_nostrconnecturi_from_string(
        FfiConverterString.lower(uri),$0)
})
    }

    

    
    

    public func description()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_nostrconnecturi_description(self.pointer, $0
    )
}
        )
    }

    public func name()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_nostrconnecturi_name(self.pointer, $0
    )
}
        )
    }

    public func publicKey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_nostrconnecturi_public_key(self.pointer, $0
    )
}
        )
    }

    public func relayUrl()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_nostrconnecturi_relay_url(self.pointer, $0
    )
}
        )
    }

    public func url()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_nostrconnecturi_url(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeNostrConnectURI: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrConnectUri

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectUri {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrConnectUri, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectUri {
        return NostrConnectUri(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrConnectUri) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeNostrConnectURI_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectUri {
    return try FfiConverterTypeNostrConnectURI.lift(pointer)
}

public func FfiConverterTypeNostrConnectURI_lower(_ value: NostrConnectUri) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrConnectURI.lower(value)
}


public protocol OptionsProtocol {
    func difficulty(difficulty: UInt8)   -> Options
    func nip46Timeout(nip46Timeout: TimeInterval?)   -> Options
    func reqFiltersChunkSize(reqFiltersChunkSize: UInt8)   -> Options
    func sendTimeout(sendTimeout: TimeInterval?)   -> Options
    func skipDisconnectedRelays(skip: Bool)   -> Options
    func timeout(timeout: TimeInterval)   -> Options
    func waitForConnection(wait: Bool)   -> Options
    func waitForSend(wait: Bool)   -> Options
    func waitForSubscription(wait: Bool)   -> Options
    
}

public class Options: OptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_options_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_options(pointer, $0) }
    }

    

    
    

    public func difficulty(difficulty: UInt8)  -> Options {
        return try!  FfiConverterTypeOptions.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_options_difficulty(self.pointer, 
        FfiConverterUInt8.lower(difficulty),$0
    )
}
        )
    }

    public func nip46Timeout(nip46Timeout: TimeInterval?)  -> Options {
        return try!  FfiConverterTypeOptions.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_options_nip46_timeout(self.pointer, 
        FfiConverterOptionDuration.lower(nip46Timeout),$0
    )
}
        )
    }

    public func reqFiltersChunkSize(reqFiltersChunkSize: UInt8)  -> Options {
        return try!  FfiConverterTypeOptions.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_options_req_filters_chunk_size(self.pointer, 
        FfiConverterUInt8.lower(reqFiltersChunkSize),$0
    )
}
        )
    }

    public func sendTimeout(sendTimeout: TimeInterval?)  -> Options {
        return try!  FfiConverterTypeOptions.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_options_send_timeout(self.pointer, 
        FfiConverterOptionDuration.lower(sendTimeout),$0
    )
}
        )
    }

    public func skipDisconnectedRelays(skip: Bool)  -> Options {
        return try!  FfiConverterTypeOptions.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_options_skip_disconnected_relays(self.pointer, 
        FfiConverterBool.lower(skip),$0
    )
}
        )
    }

    public func timeout(timeout: TimeInterval)  -> Options {
        return try!  FfiConverterTypeOptions.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_options_timeout(self.pointer, 
        FfiConverterDuration.lower(timeout),$0
    )
}
        )
    }

    public func waitForConnection(wait: Bool)  -> Options {
        return try!  FfiConverterTypeOptions.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_options_wait_for_connection(self.pointer, 
        FfiConverterBool.lower(wait),$0
    )
}
        )
    }

    public func waitForSend(wait: Bool)  -> Options {
        return try!  FfiConverterTypeOptions.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_options_wait_for_send(self.pointer, 
        FfiConverterBool.lower(wait),$0
    )
}
        )
    }

    public func waitForSubscription(wait: Bool)  -> Options {
        return try!  FfiConverterTypeOptions.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_options_wait_for_subscription(self.pointer, 
        FfiConverterBool.lower(wait),$0
    )
}
        )
    }
}

public struct FfiConverterTypeOptions: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Options

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Options {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Options, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Options {
        return Options(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Options) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> Options {
    return try FfiConverterTypeOptions.lift(pointer)
}

public func FfiConverterTypeOptions_lower(_ value: Options) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOptions.lower(value)
}


public protocol ProfileProtocol {
    func publicKey()   -> PublicKey
    func relays()   -> [String]
    func toBech32()  throws -> String
    func toNostrUri()  throws -> String
    
}

public class Profile: ProfileProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(publicKey: PublicKey, relays: [String])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_profile_new(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterSequenceString.lower(relays),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_profile(pointer, $0) }
    }

    

    public static func fromBech32(bech32: String) throws -> Profile {
        return Profile(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_profile_from_bech32(
        FfiConverterString.lower(bech32),$0)
})
    }

    

    public static func fromNostrUri(uri: String) throws -> Profile {
        return Profile(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_profile_from_nostr_uri(
        FfiConverterString.lower(uri),$0)
})
    }

    

    
    

    public func publicKey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_profile_public_key(self.pointer, $0
    )
}
        )
    }

    public func relays()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_profile_relays(self.pointer, $0
    )
}
        )
    }

    public func toBech32() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_method_profile_to_bech32(self.pointer, $0
    )
}
        )
    }

    public func toNostrUri() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_method_profile_to_nostr_uri(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeProfile: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Profile

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Profile {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Profile, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Profile {
        return Profile(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Profile) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeProfile_lift(_ pointer: UnsafeMutableRawPointer) throws -> Profile {
    return try FfiConverterTypeProfile.lift(pointer)
}

public func FfiConverterTypeProfile_lower(_ value: Profile) -> UnsafeMutableRawPointer {
    return FfiConverterTypeProfile.lower(value)
}


public protocol PublicKeyProtocol {
    func toBech32()  throws -> String
    func toHex()   -> String
    func toNostrUri()  throws -> String
    
}

public class PublicKey: PublicKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_publickey(pointer, $0) }
    }

    

    public static func fromBech32(pk: String) throws -> PublicKey {
        return PublicKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_publickey_from_bech32(
        FfiConverterString.lower(pk),$0)
})
    }

    

    public static func fromBytes(pk: [UInt8]) throws -> PublicKey {
        return PublicKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_publickey_from_bytes(
        FfiConverterSequenceUInt8.lower(pk),$0)
})
    }

    

    public static func fromHex(hex: String) throws -> PublicKey {
        return PublicKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_publickey_from_hex(
        FfiConverterString.lower(hex),$0)
})
    }

    

    public static func fromNostrUri(uri: String) throws -> PublicKey {
        return PublicKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_publickey_from_nostr_uri(
        FfiConverterString.lower(uri),$0)
})
    }

    

    
    

    public func toBech32() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_method_publickey_to_bech32(self.pointer, $0
    )
}
        )
    }

    public func toHex()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_publickey_to_hex(self.pointer, $0
    )
}
        )
    }

    public func toNostrUri() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_method_publickey_to_nostr_uri(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypePublicKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PublicKey {
        return PublicKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PublicKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypePublicKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(pointer)
}

public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypePublicKey.lower(value)
}


public protocol RelayProtocol {
    func connect(waitForConnection: Bool)  
    func document()   -> RelayInformationDocument
    func getEventsOf(filters: [Filter], timeout: TimeInterval)  throws -> [Event]
    func isConnected()   -> Bool
    func proxy()   -> String?
    func queue()   -> UInt64
    func reqEventsOf(filters: [Filter], timeout: TimeInterval)  
    func sendMsg(msg: ClientMessage, wait: TimeInterval?)  throws
    func stats()   -> RelayConnectionStats
    func status()   -> RelayStatus
    func stop()  throws
    func subscribe(filters: [Filter], wait: TimeInterval?)  throws
    func subscriptions()   -> [String: ActiveSubscription]
    func terminate()  throws
    func unsubscribe(wait: TimeInterval?)  throws
    func updateSubscriptionFilters(internalId: String, filters: [Filter])  
    func url()   -> String
    
}

public class Relay: RelayProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_relay(pointer, $0) }
    }

    

    
    

    public func connect(waitForConnection: Bool)  {
        try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relay_connect(self.pointer, 
        FfiConverterBool.lower(waitForConnection),$0
    )
}
    }

    public func document()  -> RelayInformationDocument {
        return try!  FfiConverterTypeRelayInformationDocument.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relay_document(self.pointer, $0
    )
}
        )
    }

    public func getEventsOf(filters: [Filter], timeout: TimeInterval) throws -> [Event] {
        return try  FfiConverterSequenceTypeEvent.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_relay_get_events_of(self.pointer, 
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterDuration.lower(timeout),$0
    )
}
        )
    }

    public func isConnected()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relay_is_connected(self.pointer, $0
    )
}
        )
    }

    public func proxy()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relay_proxy(self.pointer, $0
    )
}
        )
    }

    public func queue()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relay_queue(self.pointer, $0
    )
}
        )
    }

    public func reqEventsOf(filters: [Filter], timeout: TimeInterval)  {
        try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relay_req_events_of(self.pointer, 
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterDuration.lower(timeout),$0
    )
}
    }

    public func sendMsg(msg: ClientMessage, wait: TimeInterval?) throws {
        try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_relay_send_msg(self.pointer, 
        FfiConverterTypeClientMessage.lower(msg),
        FfiConverterOptionDuration.lower(wait),$0
    )
}
    }

    public func stats()  -> RelayConnectionStats {
        return try!  FfiConverterTypeRelayConnectionStats.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relay_stats(self.pointer, $0
    )
}
        )
    }

    public func status()  -> RelayStatus {
        return try!  FfiConverterTypeRelayStatus.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relay_status(self.pointer, $0
    )
}
        )
    }

    public func stop() throws {
        try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_relay_stop(self.pointer, $0
    )
}
    }

    public func subscribe(filters: [Filter], wait: TimeInterval?) throws {
        try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_relay_subscribe(self.pointer, 
        FfiConverterSequenceTypeFilter.lower(filters),
        FfiConverterOptionDuration.lower(wait),$0
    )
}
    }

    public func subscriptions()  -> [String: ActiveSubscription] {
        return try!  FfiConverterDictionaryStringTypeActiveSubscription.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relay_subscriptions(self.pointer, $0
    )
}
        )
    }

    public func terminate() throws {
        try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_relay_terminate(self.pointer, $0
    )
}
    }

    public func unsubscribe(wait: TimeInterval?) throws {
        try 
    rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_method_relay_unsubscribe(self.pointer, 
        FfiConverterOptionDuration.lower(wait),$0
    )
}
    }

    public func updateSubscriptionFilters(internalId: String, filters: [Filter])  {
        try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relay_update_subscription_filters(self.pointer, 
        FfiConverterString.lower(internalId),
        FfiConverterSequenceTypeFilter.lower(filters),$0
    )
}
    }

    public func url()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relay_url(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeRelay: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Relay

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Relay {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Relay, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Relay {
        return Relay(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Relay) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRelay_lift(_ pointer: UnsafeMutableRawPointer) throws -> Relay {
    return try FfiConverterTypeRelay.lift(pointer)
}

public func FfiConverterTypeRelay_lower(_ value: Relay) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelay.lower(value)
}


public protocol RelayConnectionStatsProtocol {
    func attempts()   -> UInt64
    func bytesReceived()   -> UInt64
    func bytesSent()   -> UInt64
    func connectedAt()   -> Timestamp
    func latency()   -> TimeInterval?
    func success()   -> UInt64
    
}

public class RelayConnectionStats: RelayConnectionStatsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_relayconnectionstats(pointer, $0) }
    }

    

    
    

    public func attempts()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relayconnectionstats_attempts(self.pointer, $0
    )
}
        )
    }

    public func bytesReceived()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relayconnectionstats_bytes_received(self.pointer, $0
    )
}
        )
    }

    public func bytesSent()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relayconnectionstats_bytes_sent(self.pointer, $0
    )
}
        )
    }

    public func connectedAt()  -> Timestamp {
        return try!  FfiConverterTypeTimestamp.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relayconnectionstats_connected_at(self.pointer, $0
    )
}
        )
    }

    public func latency()  -> TimeInterval? {
        return try!  FfiConverterOptionDuration.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relayconnectionstats_latency(self.pointer, $0
    )
}
        )
    }

    public func success()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relayconnectionstats_success(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeRelayConnectionStats: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayConnectionStats

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayConnectionStats {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayConnectionStats, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayConnectionStats {
        return RelayConnectionStats(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayConnectionStats) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRelayConnectionStats_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayConnectionStats {
    return try FfiConverterTypeRelayConnectionStats.lift(pointer)
}

public func FfiConverterTypeRelayConnectionStats_lower(_ value: RelayConnectionStats) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayConnectionStats.lower(value)
}


public protocol RelayInformationDocumentProtocol {
    func contact()   -> String?
    func description()   -> String?
    func name()   -> String?
    func pubkey()   -> String?
    func software()   -> String?
    func supportedNips()   -> [UInt16]?
    func version()   -> String?
    
}

public class RelayInformationDocument: RelayInformationDocumentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_relayinformationdocument(pointer, $0) }
    }

    

    public static func get(url: String, proxy: String?) throws -> RelayInformationDocument {
        return RelayInformationDocument(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_relayinformationdocument_get(
        FfiConverterString.lower(url),
        FfiConverterOptionString.lower(proxy),$0)
})
    }

    

    
    

    public func contact()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relayinformationdocument_contact(self.pointer, $0
    )
}
        )
    }

    public func description()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relayinformationdocument_description(self.pointer, $0
    )
}
        )
    }

    public func name()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relayinformationdocument_name(self.pointer, $0
    )
}
        )
    }

    public func pubkey()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relayinformationdocument_pubkey(self.pointer, $0
    )
}
        )
    }

    public func software()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relayinformationdocument_software(self.pointer, $0
    )
}
        )
    }

    public func supportedNips()  -> [UInt16]? {
        return try!  FfiConverterOptionSequenceUInt16.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relayinformationdocument_supported_nips(self.pointer, $0
    )
}
        )
    }

    public func version()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_relayinformationdocument_version(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeRelayInformationDocument: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayInformationDocument

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayInformationDocument {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayInformationDocument, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayInformationDocument {
        return RelayInformationDocument(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayInformationDocument) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRelayInformationDocument_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayInformationDocument {
    return try FfiConverterTypeRelayInformationDocument.lift(pointer)
}

public func FfiConverterTypeRelayInformationDocument_lower(_ value: RelayInformationDocument) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayInformationDocument.lower(value)
}


public protocol SecretKeyProtocol {
    func toBech32()  throws -> String
    func toHex()   -> String
    
}

public class SecretKey: SecretKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_secretkey(pointer, $0) }
    }

    

    public static func fromBech32(sk: String) throws -> SecretKey {
        return SecretKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_secretkey_from_bech32(
        FfiConverterString.lower(sk),$0)
})
    }

    

    public static func fromBytes(sk: [UInt8]) throws -> SecretKey {
        return SecretKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_secretkey_from_bytes(
        FfiConverterSequenceUInt8.lower(sk),$0)
})
    }

    

    public static func fromHex(hex: String) throws -> SecretKey {
        return SecretKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_secretkey_from_hex(
        FfiConverterString.lower(hex),$0)
})
    }

    

    
    

    public func toBech32() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_method_secretkey_to_bech32(self.pointer, $0
    )
}
        )
    }

    public func toHex()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_secretkey_to_hex(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeSecretKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SecretKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecretKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SecretKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SecretKey {
        return SecretKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SecretKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSecretKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> SecretKey {
    return try FfiConverterTypeSecretKey.lift(pointer)
}

public func FfiConverterTypeSecretKey_lower(_ value: SecretKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSecretKey.lower(value)
}


public protocol TagProtocol {
    func asEnum()   -> TagEnum
    func asVec()   -> [String]
    func kind()   -> TagKind
    
}

public class Tag: TagProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_tag(pointer, $0) }
    }

    

    public static func fromEnum(e: TagEnum) throws -> Tag {
        return Tag(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_tag_from_enum(
        FfiConverterTypeTagEnum.lower(e),$0)
})
    }

    

    public static func parse(data: [String]) throws -> Tag {
        return Tag(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_tag_parse(
        FfiConverterSequenceString.lower(data),$0)
})
    }

    

    
    

    public func asEnum()  -> TagEnum {
        return try!  FfiConverterTypeTagEnum.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_tag_as_enum(self.pointer, $0
    )
}
        )
    }

    public func asVec()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_tag_as_vec(self.pointer, $0
    )
}
        )
    }

    public func kind()  -> TagKind {
        return try!  FfiConverterTypeTagKind.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_tag_kind(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeTag: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Tag

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tag {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Tag, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Tag {
        return Tag(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Tag) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTag_lift(_ pointer: UnsafeMutableRawPointer) throws -> Tag {
    return try FfiConverterTypeTag.lift(pointer)
}

public func FfiConverterTypeTag_lower(_ value: Tag) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTag.lower(value)
}


public protocol TimestampProtocol {
    func asSecs()   -> UInt64
    func toHumanDatetime()   -> String
    
}

public class Timestamp: TimestampProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_timestamp(pointer, $0) }
    }

    

    public static func fromSecs(secs: UInt64)  -> Timestamp {
        return Timestamp(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_timestamp_from_secs(
        FfiConverterUInt64.lower(secs),$0)
})
    }

    

    public static func now()  -> Timestamp {
        return Timestamp(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_timestamp_now($0)
})
    }

    

    
    

    public func asSecs()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_timestamp_as_secs(self.pointer, $0
    )
}
        )
    }

    public func toHumanDatetime()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_timestamp_to_human_datetime(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeTimestamp: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Timestamp

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Timestamp {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Timestamp, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Timestamp {
        return Timestamp(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Timestamp) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTimestamp_lift(_ pointer: UnsafeMutableRawPointer) throws -> Timestamp {
    return try FfiConverterTypeTimestamp.lift(pointer)
}

public func FfiConverterTypeTimestamp_lower(_ value: Timestamp) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimestamp.lower(value)
}


public protocol UnsignedEventProtocol {
    func addSignature(sig: String)  throws -> Event
    func asJson()   -> String
    func content()   -> String
    func createdAt()   -> Timestamp
    func id()   -> EventId
    func kind()   -> UInt64
    func pubkey()   -> PublicKey
    func sign(keys: Keys)  throws -> Event
    func tags()   -> [Tag]
    
}

public class UnsignedEvent: UnsignedEventProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_unsignedevent(pointer, $0) }
    }

    

    public static func fromJson(json: String) throws -> UnsignedEvent {
        return UnsignedEvent(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_constructor_unsignedevent_from_json(
        FfiConverterString.lower(json),$0)
})
    }

    

    
    

    public func addSignature(sig: String) throws -> Event {
        return try  FfiConverterTypeEvent.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_method_unsignedevent_add_signature(self.pointer, 
        FfiConverterString.lower(sig),$0
    )
}
        )
    }

    public func asJson()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_unsignedevent_as_json(self.pointer, $0
    )
}
        )
    }

    public func content()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_unsignedevent_content(self.pointer, $0
    )
}
        )
    }

    public func createdAt()  -> Timestamp {
        return try!  FfiConverterTypeTimestamp.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_unsignedevent_created_at(self.pointer, $0
    )
}
        )
    }

    public func id()  -> EventId {
        return try!  FfiConverterTypeEventId.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_unsignedevent_id(self.pointer, $0
    )
}
        )
    }

    public func kind()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_unsignedevent_kind(self.pointer, $0
    )
}
        )
    }

    public func pubkey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_unsignedevent_pubkey(self.pointer, $0
    )
}
        )
    }

    public func sign(keys: Keys) throws -> Event {
        return try  FfiConverterTypeEvent.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_method_unsignedevent_sign(self.pointer, 
        FfiConverterTypeKeys.lower(keys),$0
    )
}
        )
    }

    public func tags()  -> [Tag] {
        return try!  FfiConverterSequenceTypeTag.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_unsignedevent_tags(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeUnsignedEvent: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnsignedEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsignedEvent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnsignedEvent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsignedEvent {
        return UnsignedEvent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnsignedEvent) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeUnsignedEvent_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsignedEvent {
    return try FfiConverterTypeUnsignedEvent.lift(pointer)
}

public func FfiConverterTypeUnsignedEvent_lower(_ value: UnsignedEvent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnsignedEvent.lower(value)
}


public protocol ZapRequestDataProtocol {
    func amount(amount: UInt64)   -> ZapRequestData
    func eventId(eventId: EventId)   -> ZapRequestData
    func lnurl(lnurl: String)   -> ZapRequestData
    
}

public class ZapRequestData: ZapRequestDataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(publicKey: PublicKey, relays: [String])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_sdk_fn_constructor_zaprequestdata_new(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterSequenceString.lower(relays),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_sdk_fn_free_zaprequestdata(pointer, $0) }
    }

    

    
    

    public func amount(amount: UInt64)  -> ZapRequestData {
        return try!  FfiConverterTypeZapRequestData.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_zaprequestdata_amount(self.pointer, 
        FfiConverterUInt64.lower(amount),$0
    )
}
        )
    }

    public func eventId(eventId: EventId)  -> ZapRequestData {
        return try!  FfiConverterTypeZapRequestData.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_zaprequestdata_event_id(self.pointer, 
        FfiConverterTypeEventId.lower(eventId),$0
    )
}
        )
    }

    public func lnurl(lnurl: String)  -> ZapRequestData {
        return try!  FfiConverterTypeZapRequestData.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_sdk_fn_method_zaprequestdata_lnurl(self.pointer, 
        FfiConverterString.lower(lnurl),$0
    )
}
        )
    }
}

public struct FfiConverterTypeZapRequestData: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZapRequestData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZapRequestData {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZapRequestData, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapRequestData {
        return ZapRequestData(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZapRequestData) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeZapRequestData_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapRequestData {
    return try FfiConverterTypeZapRequestData.lift(pointer)
}

public func FfiConverterTypeZapRequestData_lower(_ value: ZapRequestData) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZapRequestData.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Alphabet {
    
    case a
    case b
    case c
    case d
    case e
    case f
    case g
    case h
    case i
    case j
    case k
    case l
    case m
    case n
    case o
    case p
    case q
    case r
    case s
    case t
    case u
    case v
    case w
    case x
    case y
    case z
}

public struct FfiConverterTypeAlphabet: FfiConverterRustBuffer {
    typealias SwiftType = Alphabet

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Alphabet {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .a
        
        case 2: return .b
        
        case 3: return .c
        
        case 4: return .d
        
        case 5: return .e
        
        case 6: return .f
        
        case 7: return .g
        
        case 8: return .h
        
        case 9: return .i
        
        case 10: return .j
        
        case 11: return .k
        
        case 12: return .l
        
        case 13: return .m
        
        case 14: return .n
        
        case 15: return .o
        
        case 16: return .p
        
        case 17: return .q
        
        case 18: return .r
        
        case 19: return .s
        
        case 20: return .t
        
        case 21: return .u
        
        case 22: return .v
        
        case 23: return .w
        
        case 24: return .x
        
        case 25: return .y
        
        case 26: return .z
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Alphabet, into buf: inout [UInt8]) {
        switch value {
        
        
        case .a:
            writeInt(&buf, Int32(1))
        
        
        case .b:
            writeInt(&buf, Int32(2))
        
        
        case .c:
            writeInt(&buf, Int32(3))
        
        
        case .d:
            writeInt(&buf, Int32(4))
        
        
        case .e:
            writeInt(&buf, Int32(5))
        
        
        case .f:
            writeInt(&buf, Int32(6))
        
        
        case .g:
            writeInt(&buf, Int32(7))
        
        
        case .h:
            writeInt(&buf, Int32(8))
        
        
        case .i:
            writeInt(&buf, Int32(9))
        
        
        case .j:
            writeInt(&buf, Int32(10))
        
        
        case .k:
            writeInt(&buf, Int32(11))
        
        
        case .l:
            writeInt(&buf, Int32(12))
        
        
        case .m:
            writeInt(&buf, Int32(13))
        
        
        case .n:
            writeInt(&buf, Int32(14))
        
        
        case .o:
            writeInt(&buf, Int32(15))
        
        
        case .p:
            writeInt(&buf, Int32(16))
        
        
        case .q:
            writeInt(&buf, Int32(17))
        
        
        case .r:
            writeInt(&buf, Int32(18))
        
        
        case .s:
            writeInt(&buf, Int32(19))
        
        
        case .t:
            writeInt(&buf, Int32(20))
        
        
        case .u:
            writeInt(&buf, Int32(21))
        
        
        case .v:
            writeInt(&buf, Int32(22))
        
        
        case .w:
            writeInt(&buf, Int32(23))
        
        
        case .x:
            writeInt(&buf, Int32(24))
        
        
        case .y:
            writeInt(&buf, Int32(25))
        
        
        case .z:
            writeInt(&buf, Int32(26))
        
        }
    }
}


public func FfiConverterTypeAlphabet_lift(_ buf: RustBuffer) throws -> Alphabet {
    return try FfiConverterTypeAlphabet.lift(buf)
}

public func FfiConverterTypeAlphabet_lower(_ value: Alphabet) -> RustBuffer {
    return FfiConverterTypeAlphabet.lower(value)
}


extension Alphabet: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ClientMessage {
    
    case ev(event: String)
    case req(subscriptionId: String, filters: [String])
    case count(subscriptionId: String, filters: [String])
    case close(subscriptionId: String)
    case auth(event: String)
}

public struct FfiConverterTypeClientMessage: FfiConverterRustBuffer {
    typealias SwiftType = ClientMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ev(
            event: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .req(
            subscriptionId: try FfiConverterString.read(from: &buf), 
            filters: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 3: return .count(
            subscriptionId: try FfiConverterString.read(from: &buf), 
            filters: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 4: return .close(
            subscriptionId: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .auth(
            event: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .ev(event):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(event, into: &buf)
            
        
        case let .req(subscriptionId,filters):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterSequenceString.write(filters, into: &buf)
            
        
        case let .count(subscriptionId,filters):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterSequenceString.write(filters, into: &buf)
            
        
        case let .close(subscriptionId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(subscriptionId, into: &buf)
            
        
        case let .auth(event):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(event, into: &buf)
            
        }
    }
}


public func FfiConverterTypeClientMessage_lift(_ buf: RustBuffer) throws -> ClientMessage {
    return try FfiConverterTypeClientMessage.lift(buf)
}

public func FfiConverterTypeClientMessage_lower(_ value: ClientMessage) -> RustBuffer {
    return FfiConverterTypeClientMessage.lower(value)
}


extension ClientMessage: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LogLevel {
    
    case error
    case warn
    case info
    case debug
    case trace
}

public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .error
        
        case 2: return .warn
        
        case 3: return .info
        
        case 4: return .debug
        
        case 5: return .trace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .error:
            writeInt(&buf, Int32(1))
        
        
        case .warn:
            writeInt(&buf, Int32(2))
        
        
        case .info:
            writeInt(&buf, Int32(3))
        
        
        case .debug:
            writeInt(&buf, Int32(4))
        
        
        case .trace:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}


extension LogLevel: Equatable, Hashable {}



public enum NostrError {

    
    
    case Generic(err: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeNostrError.lift(error)
    }
}


public struct FfiConverterTypeNostrError: FfiConverterRustBuffer {
    typealias SwiftType = NostrError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            err: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NostrError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(err):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(err, into: &buf)
            
        }
    }
}


extension NostrError: Equatable, Hashable {}

extension NostrError: Error { }

public enum NostrSdkError {

    
    
    case Generic(err: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeNostrSdkError.lift(error)
    }
}


public struct FfiConverterTypeNostrSdkError: FfiConverterRustBuffer {
    typealias SwiftType = NostrSdkError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrSdkError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            err: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NostrSdkError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(err):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(err, into: &buf)
            
        }
    }
}


extension NostrSdkError: Equatable, Hashable {}

extension NostrSdkError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RelayMessage {
    
    case ev(subscriptionId: String, event: String)
    case notice(message: String)
    case endOfStoredEvents(subscriptionId: String)
    case ok(eventId: String, status: Bool, message: String)
    case auth(challenge: String)
    case count(subscriptionId: String, count: UInt64)
    case negMsg(subscriptionId: String, message: String)
    case negErr(subscriptionId: String, code: String)
}

public struct FfiConverterTypeRelayMessage: FfiConverterRustBuffer {
    typealias SwiftType = RelayMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ev(
            subscriptionId: try FfiConverterString.read(from: &buf), 
            event: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .notice(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .endOfStoredEvents(
            subscriptionId: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .ok(
            eventId: try FfiConverterString.read(from: &buf), 
            status: try FfiConverterBool.read(from: &buf), 
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .auth(
            challenge: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .count(
            subscriptionId: try FfiConverterString.read(from: &buf), 
            count: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 7: return .negMsg(
            subscriptionId: try FfiConverterString.read(from: &buf), 
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .negErr(
            subscriptionId: try FfiConverterString.read(from: &buf), 
            code: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RelayMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .ev(subscriptionId,event):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterString.write(event, into: &buf)
            
        
        case let .notice(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .endOfStoredEvents(subscriptionId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(subscriptionId, into: &buf)
            
        
        case let .ok(eventId,status,message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(eventId, into: &buf)
            FfiConverterBool.write(status, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .auth(challenge):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(challenge, into: &buf)
            
        
        case let .count(subscriptionId,count):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterUInt64.write(count, into: &buf)
            
        
        case let .negMsg(subscriptionId,message):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .negErr(subscriptionId,code):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterString.write(code, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRelayMessage_lift(_ buf: RustBuffer) throws -> RelayMessage {
    return try FfiConverterTypeRelayMessage.lift(buf)
}

public func FfiConverterTypeRelayMessage_lower(_ value: RelayMessage) -> RustBuffer {
    return FfiConverterTypeRelayMessage.lower(value)
}


extension RelayMessage: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RelayStatus {
    
    case initialized
    case connected
    case connecting
    case disconnected
    case stopped
    case terminated
}

public struct FfiConverterTypeRelayStatus: FfiConverterRustBuffer {
    typealias SwiftType = RelayStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initialized
        
        case 2: return .connected
        
        case 3: return .connecting
        
        case 4: return .disconnected
        
        case 5: return .stopped
        
        case 6: return .terminated
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RelayStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .initialized:
            writeInt(&buf, Int32(1))
        
        
        case .connected:
            writeInt(&buf, Int32(2))
        
        
        case .connecting:
            writeInt(&buf, Int32(3))
        
        
        case .disconnected:
            writeInt(&buf, Int32(4))
        
        
        case .stopped:
            writeInt(&buf, Int32(5))
        
        
        case .terminated:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypeRelayStatus_lift(_ buf: RustBuffer) throws -> RelayStatus {
    return try FfiConverterTypeRelayStatus.lift(buf)
}

public func FfiConverterTypeRelayStatus_lower(_ value: RelayStatus) -> RustBuffer {
    return FfiConverterTypeRelayStatus.lower(value)
}


extension RelayStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TagEnum {
    
    case unknown(kind: TagKind, data: [String])
    case e(eventId: String, relayUrl: String?, marker: String?)
    case pubKey(publicKey: String, relayUrl: String?)
    case eventReport(eventId: String, report: String)
    case pubKeyReport(publicKey: String, report: String)
    case pubKeyLiveEvent(pk: String, relayUrl: String?, marker: String, proof: String?)
    case reference(reference: String)
    case relayMetadata(relayUrl: String, rw: String?)
    case hashtag(hashtag: String)
    case geohash(geohash: String)
    case identifier(identifier: String)
    case externalIdentity(identity: String, proof: String)
    case a(kind: UInt64, publicKey: String, identifier: String, relayUrl: String?)
    case relayUrl(relayUrl: String)
    case contactList(pk: String, relayUrl: String?, alias: String?)
    case pow(nonce: String, difficulty: UInt8)
    case delegation(delegatorPk: String, conditions: String, sig: String)
    case contentWarning(reason: String?)
    case expiration(timestamp: UInt64)
    case subject(subject: String)
    case challenge(challenge: String)
    case title(title: String)
    case image(url: String, dimensions: String?)
    case thumb(url: String, dimensions: String?)
    case summary(summary: String)
    case description(desc: String)
    case bolt11(bolt11: String)
    case preimage(preimage: String)
    case relays(urls: [String])
    case amount(amount: UInt64)
    case lnurl(lnurl: String)
    case name(name: String)
    case publishedAt(timestamp: UInt64)
    case url(url: String)
    case mimeType(mime: String)
    case aes256Gcm(key: String, iv: String)
    case sha256(hash: String)
    case size(size: UInt64)
    case dim(dimensions: String)
    case magnet(uri: String)
    case blurhash(blurhash: String)
    case streaming(url: String)
    case recording(url: String)
    case starts(timestamp: UInt64)
    case ends(timestamp: UInt64)
    case status(status: String)
    case currentParticipants(num: UInt64)
    case totalParticipants(num: UInt64)
    case absoluteUrl(url: String)
    case method(method: String)
    case payload(hash: String)
    case anon(msg: String?)
    case proxy(id: String, `protocol`: String)
}

public struct FfiConverterTypeTagEnum: FfiConverterRustBuffer {
    typealias SwiftType = TagEnum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TagEnum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown(
            kind: try FfiConverterTypeTagKind.read(from: &buf), 
            data: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 2: return .e(
            eventId: try FfiConverterString.read(from: &buf), 
            relayUrl: try FfiConverterOptionString.read(from: &buf), 
            marker: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 3: return .pubKey(
            publicKey: try FfiConverterString.read(from: &buf), 
            relayUrl: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 4: return .eventReport(
            eventId: try FfiConverterString.read(from: &buf), 
            report: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .pubKeyReport(
            publicKey: try FfiConverterString.read(from: &buf), 
            report: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .pubKeyLiveEvent(
            pk: try FfiConverterString.read(from: &buf), 
            relayUrl: try FfiConverterOptionString.read(from: &buf), 
            marker: try FfiConverterString.read(from: &buf), 
            proof: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 7: return .reference(
            reference: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .relayMetadata(
            relayUrl: try FfiConverterString.read(from: &buf), 
            rw: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 9: return .hashtag(
            hashtag: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .geohash(
            geohash: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .identifier(
            identifier: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .externalIdentity(
            identity: try FfiConverterString.read(from: &buf), 
            proof: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .a(
            kind: try FfiConverterUInt64.read(from: &buf), 
            publicKey: try FfiConverterString.read(from: &buf), 
            identifier: try FfiConverterString.read(from: &buf), 
            relayUrl: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 14: return .relayUrl(
            relayUrl: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .contactList(
            pk: try FfiConverterString.read(from: &buf), 
            relayUrl: try FfiConverterOptionString.read(from: &buf), 
            alias: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 16: return .pow(
            nonce: try FfiConverterString.read(from: &buf), 
            difficulty: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 17: return .delegation(
            delegatorPk: try FfiConverterString.read(from: &buf), 
            conditions: try FfiConverterString.read(from: &buf), 
            sig: try FfiConverterString.read(from: &buf)
        )
        
        case 18: return .contentWarning(
            reason: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 19: return .expiration(
            timestamp: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 20: return .subject(
            subject: try FfiConverterString.read(from: &buf)
        )
        
        case 21: return .challenge(
            challenge: try FfiConverterString.read(from: &buf)
        )
        
        case 22: return .title(
            title: try FfiConverterString.read(from: &buf)
        )
        
        case 23: return .image(
            url: try FfiConverterString.read(from: &buf), 
            dimensions: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 24: return .thumb(
            url: try FfiConverterString.read(from: &buf), 
            dimensions: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 25: return .summary(
            summary: try FfiConverterString.read(from: &buf)
        )
        
        case 26: return .description(
            desc: try FfiConverterString.read(from: &buf)
        )
        
        case 27: return .bolt11(
            bolt11: try FfiConverterString.read(from: &buf)
        )
        
        case 28: return .preimage(
            preimage: try FfiConverterString.read(from: &buf)
        )
        
        case 29: return .relays(
            urls: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 30: return .amount(
            amount: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 31: return .lnurl(
            lnurl: try FfiConverterString.read(from: &buf)
        )
        
        case 32: return .name(
            name: try FfiConverterString.read(from: &buf)
        )
        
        case 33: return .publishedAt(
            timestamp: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 34: return .url(
            url: try FfiConverterString.read(from: &buf)
        )
        
        case 35: return .mimeType(
            mime: try FfiConverterString.read(from: &buf)
        )
        
        case 36: return .aes256Gcm(
            key: try FfiConverterString.read(from: &buf), 
            iv: try FfiConverterString.read(from: &buf)
        )
        
        case 37: return .sha256(
            hash: try FfiConverterString.read(from: &buf)
        )
        
        case 38: return .size(
            size: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 39: return .dim(
            dimensions: try FfiConverterString.read(from: &buf)
        )
        
        case 40: return .magnet(
            uri: try FfiConverterString.read(from: &buf)
        )
        
        case 41: return .blurhash(
            blurhash: try FfiConverterString.read(from: &buf)
        )
        
        case 42: return .streaming(
            url: try FfiConverterString.read(from: &buf)
        )
        
        case 43: return .recording(
            url: try FfiConverterString.read(from: &buf)
        )
        
        case 44: return .starts(
            timestamp: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 45: return .ends(
            timestamp: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 46: return .status(
            status: try FfiConverterString.read(from: &buf)
        )
        
        case 47: return .currentParticipants(
            num: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 48: return .totalParticipants(
            num: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 49: return .absoluteUrl(
            url: try FfiConverterString.read(from: &buf)
        )
        
        case 50: return .method(
            method: try FfiConverterString.read(from: &buf)
        )
        
        case 51: return .payload(
            hash: try FfiConverterString.read(from: &buf)
        )
        
        case 52: return .anon(
            msg: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 53: return .proxy(
            id: try FfiConverterString.read(from: &buf), 
            protocol: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TagEnum, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .unknown(kind,data):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTagKind.write(kind, into: &buf)
            FfiConverterSequenceString.write(data, into: &buf)
            
        
        case let .e(eventId,relayUrl,marker):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(eventId, into: &buf)
            FfiConverterOptionString.write(relayUrl, into: &buf)
            FfiConverterOptionString.write(marker, into: &buf)
            
        
        case let .pubKey(publicKey,relayUrl):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(publicKey, into: &buf)
            FfiConverterOptionString.write(relayUrl, into: &buf)
            
        
        case let .eventReport(eventId,report):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(eventId, into: &buf)
            FfiConverterString.write(report, into: &buf)
            
        
        case let .pubKeyReport(publicKey,report):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(publicKey, into: &buf)
            FfiConverterString.write(report, into: &buf)
            
        
        case let .pubKeyLiveEvent(pk,relayUrl,marker,proof):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(pk, into: &buf)
            FfiConverterOptionString.write(relayUrl, into: &buf)
            FfiConverterString.write(marker, into: &buf)
            FfiConverterOptionString.write(proof, into: &buf)
            
        
        case let .reference(reference):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(reference, into: &buf)
            
        
        case let .relayMetadata(relayUrl,rw):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(relayUrl, into: &buf)
            FfiConverterOptionString.write(rw, into: &buf)
            
        
        case let .hashtag(hashtag):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(hashtag, into: &buf)
            
        
        case let .geohash(geohash):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(geohash, into: &buf)
            
        
        case let .identifier(identifier):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(identifier, into: &buf)
            
        
        case let .externalIdentity(identity,proof):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(identity, into: &buf)
            FfiConverterString.write(proof, into: &buf)
            
        
        case let .a(kind,publicKey,identifier,relayUrl):
            writeInt(&buf, Int32(13))
            FfiConverterUInt64.write(kind, into: &buf)
            FfiConverterString.write(publicKey, into: &buf)
            FfiConverterString.write(identifier, into: &buf)
            FfiConverterOptionString.write(relayUrl, into: &buf)
            
        
        case let .relayUrl(relayUrl):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(relayUrl, into: &buf)
            
        
        case let .contactList(pk,relayUrl,alias):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(pk, into: &buf)
            FfiConverterOptionString.write(relayUrl, into: &buf)
            FfiConverterOptionString.write(alias, into: &buf)
            
        
        case let .pow(nonce,difficulty):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(nonce, into: &buf)
            FfiConverterUInt8.write(difficulty, into: &buf)
            
        
        case let .delegation(delegatorPk,conditions,sig):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(delegatorPk, into: &buf)
            FfiConverterString.write(conditions, into: &buf)
            FfiConverterString.write(sig, into: &buf)
            
        
        case let .contentWarning(reason):
            writeInt(&buf, Int32(18))
            FfiConverterOptionString.write(reason, into: &buf)
            
        
        case let .expiration(timestamp):
            writeInt(&buf, Int32(19))
            FfiConverterUInt64.write(timestamp, into: &buf)
            
        
        case let .subject(subject):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(subject, into: &buf)
            
        
        case let .challenge(challenge):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(challenge, into: &buf)
            
        
        case let .title(title):
            writeInt(&buf, Int32(22))
            FfiConverterString.write(title, into: &buf)
            
        
        case let .image(url,dimensions):
            writeInt(&buf, Int32(23))
            FfiConverterString.write(url, into: &buf)
            FfiConverterOptionString.write(dimensions, into: &buf)
            
        
        case let .thumb(url,dimensions):
            writeInt(&buf, Int32(24))
            FfiConverterString.write(url, into: &buf)
            FfiConverterOptionString.write(dimensions, into: &buf)
            
        
        case let .summary(summary):
            writeInt(&buf, Int32(25))
            FfiConverterString.write(summary, into: &buf)
            
        
        case let .description(desc):
            writeInt(&buf, Int32(26))
            FfiConverterString.write(desc, into: &buf)
            
        
        case let .bolt11(bolt11):
            writeInt(&buf, Int32(27))
            FfiConverterString.write(bolt11, into: &buf)
            
        
        case let .preimage(preimage):
            writeInt(&buf, Int32(28))
            FfiConverterString.write(preimage, into: &buf)
            
        
        case let .relays(urls):
            writeInt(&buf, Int32(29))
            FfiConverterSequenceString.write(urls, into: &buf)
            
        
        case let .amount(amount):
            writeInt(&buf, Int32(30))
            FfiConverterUInt64.write(amount, into: &buf)
            
        
        case let .lnurl(lnurl):
            writeInt(&buf, Int32(31))
            FfiConverterString.write(lnurl, into: &buf)
            
        
        case let .name(name):
            writeInt(&buf, Int32(32))
            FfiConverterString.write(name, into: &buf)
            
        
        case let .publishedAt(timestamp):
            writeInt(&buf, Int32(33))
            FfiConverterUInt64.write(timestamp, into: &buf)
            
        
        case let .url(url):
            writeInt(&buf, Int32(34))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .mimeType(mime):
            writeInt(&buf, Int32(35))
            FfiConverterString.write(mime, into: &buf)
            
        
        case let .aes256Gcm(key,iv):
            writeInt(&buf, Int32(36))
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(iv, into: &buf)
            
        
        case let .sha256(hash):
            writeInt(&buf, Int32(37))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .size(size):
            writeInt(&buf, Int32(38))
            FfiConverterUInt64.write(size, into: &buf)
            
        
        case let .dim(dimensions):
            writeInt(&buf, Int32(39))
            FfiConverterString.write(dimensions, into: &buf)
            
        
        case let .magnet(uri):
            writeInt(&buf, Int32(40))
            FfiConverterString.write(uri, into: &buf)
            
        
        case let .blurhash(blurhash):
            writeInt(&buf, Int32(41))
            FfiConverterString.write(blurhash, into: &buf)
            
        
        case let .streaming(url):
            writeInt(&buf, Int32(42))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .recording(url):
            writeInt(&buf, Int32(43))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .starts(timestamp):
            writeInt(&buf, Int32(44))
            FfiConverterUInt64.write(timestamp, into: &buf)
            
        
        case let .ends(timestamp):
            writeInt(&buf, Int32(45))
            FfiConverterUInt64.write(timestamp, into: &buf)
            
        
        case let .status(status):
            writeInt(&buf, Int32(46))
            FfiConverterString.write(status, into: &buf)
            
        
        case let .currentParticipants(num):
            writeInt(&buf, Int32(47))
            FfiConverterUInt64.write(num, into: &buf)
            
        
        case let .totalParticipants(num):
            writeInt(&buf, Int32(48))
            FfiConverterUInt64.write(num, into: &buf)
            
        
        case let .absoluteUrl(url):
            writeInt(&buf, Int32(49))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .method(method):
            writeInt(&buf, Int32(50))
            FfiConverterString.write(method, into: &buf)
            
        
        case let .payload(hash):
            writeInt(&buf, Int32(51))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .anon(msg):
            writeInt(&buf, Int32(52))
            FfiConverterOptionString.write(msg, into: &buf)
            
        
        case let .proxy(id,`protocol`):
            writeInt(&buf, Int32(53))
            FfiConverterString.write(id, into: &buf)
            FfiConverterString.write(`protocol`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTagEnum_lift(_ buf: RustBuffer) throws -> TagEnum {
    return try FfiConverterTypeTagEnum.lift(buf)
}

public func FfiConverterTypeTagEnum_lower(_ value: TagEnum) -> RustBuffer {
    return FfiConverterTypeTagEnum.lower(value)
}


extension TagEnum: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TagKind {
    
    case known(known: TagKindKnown)
    case unknown(unknown: String)
}

public struct FfiConverterTypeTagKind: FfiConverterRustBuffer {
    typealias SwiftType = TagKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TagKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .known(
            known: try FfiConverterTypeTagKindKnown.read(from: &buf)
        )
        
        case 2: return .unknown(
            unknown: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TagKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .known(known):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTagKindKnown.write(known, into: &buf)
            
        
        case let .unknown(unknown):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(unknown, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTagKind_lift(_ buf: RustBuffer) throws -> TagKind {
    return try FfiConverterTypeTagKind.lift(buf)
}

public func FfiConverterTypeTagKind_lower(_ value: TagKind) -> RustBuffer {
    return FfiConverterTypeTagKind.lower(value)
}


extension TagKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TagKindKnown {
    
    case p
    case e
    case r
    case t
    case g
    case d
    case a
    case i
    case m
    case u
    case x
    case relayUrl
    case nonce
    case delegation
    case contentWarning
    case expiration
    case subject
    case challenge
    case title
    case image
    case thumb
    case summary
    case publishedAt
    case description
    case bolt11
    case preimage
    case relays
    case amount
    case lnurl
    case name
    case url
    case aes256Gcm
    case size
    case dim
    case magnet
    case blurhash
    case streaming
    case recording
    case starts
    case ends
    case status
    case currentParticipants
    case totalParticipants
    case method
    case payload
    case anon
    case proxy
}

public struct FfiConverterTypeTagKindKnown: FfiConverterRustBuffer {
    typealias SwiftType = TagKindKnown

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TagKindKnown {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .p
        
        case 2: return .e
        
        case 3: return .r
        
        case 4: return .t
        
        case 5: return .g
        
        case 6: return .d
        
        case 7: return .a
        
        case 8: return .i
        
        case 9: return .m
        
        case 10: return .u
        
        case 11: return .x
        
        case 12: return .relayUrl
        
        case 13: return .nonce
        
        case 14: return .delegation
        
        case 15: return .contentWarning
        
        case 16: return .expiration
        
        case 17: return .subject
        
        case 18: return .challenge
        
        case 19: return .title
        
        case 20: return .image
        
        case 21: return .thumb
        
        case 22: return .summary
        
        case 23: return .publishedAt
        
        case 24: return .description
        
        case 25: return .bolt11
        
        case 26: return .preimage
        
        case 27: return .relays
        
        case 28: return .amount
        
        case 29: return .lnurl
        
        case 30: return .name
        
        case 31: return .url
        
        case 32: return .aes256Gcm
        
        case 33: return .size
        
        case 34: return .dim
        
        case 35: return .magnet
        
        case 36: return .blurhash
        
        case 37: return .streaming
        
        case 38: return .recording
        
        case 39: return .starts
        
        case 40: return .ends
        
        case 41: return .status
        
        case 42: return .currentParticipants
        
        case 43: return .totalParticipants
        
        case 44: return .method
        
        case 45: return .payload
        
        case 46: return .anon
        
        case 47: return .proxy
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TagKindKnown, into buf: inout [UInt8]) {
        switch value {
        
        
        case .p:
            writeInt(&buf, Int32(1))
        
        
        case .e:
            writeInt(&buf, Int32(2))
        
        
        case .r:
            writeInt(&buf, Int32(3))
        
        
        case .t:
            writeInt(&buf, Int32(4))
        
        
        case .g:
            writeInt(&buf, Int32(5))
        
        
        case .d:
            writeInt(&buf, Int32(6))
        
        
        case .a:
            writeInt(&buf, Int32(7))
        
        
        case .i:
            writeInt(&buf, Int32(8))
        
        
        case .m:
            writeInt(&buf, Int32(9))
        
        
        case .u:
            writeInt(&buf, Int32(10))
        
        
        case .x:
            writeInt(&buf, Int32(11))
        
        
        case .relayUrl:
            writeInt(&buf, Int32(12))
        
        
        case .nonce:
            writeInt(&buf, Int32(13))
        
        
        case .delegation:
            writeInt(&buf, Int32(14))
        
        
        case .contentWarning:
            writeInt(&buf, Int32(15))
        
        
        case .expiration:
            writeInt(&buf, Int32(16))
        
        
        case .subject:
            writeInt(&buf, Int32(17))
        
        
        case .challenge:
            writeInt(&buf, Int32(18))
        
        
        case .title:
            writeInt(&buf, Int32(19))
        
        
        case .image:
            writeInt(&buf, Int32(20))
        
        
        case .thumb:
            writeInt(&buf, Int32(21))
        
        
        case .summary:
            writeInt(&buf, Int32(22))
        
        
        case .publishedAt:
            writeInt(&buf, Int32(23))
        
        
        case .description:
            writeInt(&buf, Int32(24))
        
        
        case .bolt11:
            writeInt(&buf, Int32(25))
        
        
        case .preimage:
            writeInt(&buf, Int32(26))
        
        
        case .relays:
            writeInt(&buf, Int32(27))
        
        
        case .amount:
            writeInt(&buf, Int32(28))
        
        
        case .lnurl:
            writeInt(&buf, Int32(29))
        
        
        case .name:
            writeInt(&buf, Int32(30))
        
        
        case .url:
            writeInt(&buf, Int32(31))
        
        
        case .aes256Gcm:
            writeInt(&buf, Int32(32))
        
        
        case .size:
            writeInt(&buf, Int32(33))
        
        
        case .dim:
            writeInt(&buf, Int32(34))
        
        
        case .magnet:
            writeInt(&buf, Int32(35))
        
        
        case .blurhash:
            writeInt(&buf, Int32(36))
        
        
        case .streaming:
            writeInt(&buf, Int32(37))
        
        
        case .recording:
            writeInt(&buf, Int32(38))
        
        
        case .starts:
            writeInt(&buf, Int32(39))
        
        
        case .ends:
            writeInt(&buf, Int32(40))
        
        
        case .status:
            writeInt(&buf, Int32(41))
        
        
        case .currentParticipants:
            writeInt(&buf, Int32(42))
        
        
        case .totalParticipants:
            writeInt(&buf, Int32(43))
        
        
        case .method:
            writeInt(&buf, Int32(44))
        
        
        case .payload:
            writeInt(&buf, Int32(45))
        
        
        case .anon:
            writeInt(&buf, Int32(46))
        
        
        case .proxy:
            writeInt(&buf, Int32(47))
        
        }
    }
}


public func FfiConverterTypeTagKindKnown_lift(_ buf: RustBuffer) throws -> TagKindKnown {
    return try FfiConverterTypeTagKindKnown.lift(buf)
}

public func FfiConverterTypeTagKindKnown_lower(_ value: TagKindKnown) -> RustBuffer {
    return FfiConverterTypeTagKindKnown.lower(value)
}


extension TagKindKnown: Equatable, Hashable {}



fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for HandleNotification Callback Interface

public protocol HandleNotification : AnyObject {
    func handleMsg(relayUrl: String, msg: RelayMessage) 
    func handle(relayUrl: String, event: Event) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceHandleNotification : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeHandleMsg(_ swiftCallbackInterface: HandleNotification, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.handleMsg(
                    relayUrl:  try FfiConverterString.read(from: &reader), 
                    msg:  try FfiConverterTypeRelayMessage.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeHandle(_ swiftCallbackInterface: HandleNotification, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.handle(
                    relayUrl:  try FfiConverterString.read(from: &reader), 
                    event:  try FfiConverterTypeEvent.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceHandleNotification.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: HandleNotification
            do {
                cb = try FfiConverterCallbackInterfaceHandleNotification.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("HandleNotification: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeHandleMsg(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: HandleNotification
            do {
                cb = try FfiConverterCallbackInterfaceHandleNotification.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("HandleNotification: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeHandle(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceHandleNotification {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_nostr_sdk_fn_init_callback_handlenotification(foreignCallbackCallbackInterfaceHandleNotification, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<HandleNotification>()
}

extension FfiConverterCallbackInterfaceHandleNotification : FfiConverter {
    typealias SwiftType = HandleNotification
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDuration.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDuration.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventId: FfiConverterRustBuffer {
    typealias SwiftType = EventId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceUInt16: FfiConverterRustBuffer {
    typealias SwiftType = [UInt16]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceUInt16: FfiConverterRustBuffer {
    typealias SwiftType = [UInt16]

    public static func write(_ value: [UInt16], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt16.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt16] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt16]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt16.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeContact: FfiConverterRustBuffer {
    typealias SwiftType = [Contact]

    public static func write(_ value: [Contact], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeContact.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Contact] {
        let len: Int32 = try readInt(&buf)
        var seq = [Contact]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeContact.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = [Event]

    public static func write(_ value: [Event], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEvent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Event] {
        let len: Int32 = try readInt(&buf)
        var seq = [Event]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEvent.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeEventId: FfiConverterRustBuffer {
    typealias SwiftType = [EventId]

    public static func write(_ value: [EventId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEventId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EventId] {
        let len: Int32 = try readInt(&buf)
        var seq = [EventId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEventId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = [Filter]

    public static func write(_ value: [Filter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Filter] {
        let len: Int32 = try readInt(&buf)
        var seq = [Filter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFilter.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    public static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTag: FfiConverterRustBuffer {
    typealias SwiftType = [Tag]

    public static func write(_ value: [Tag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Tag] {
        let len: Int32 = try readInt(&buf)
        var seq = [Tag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTag.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]

    public static func write(_ value: [[String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[String]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[String]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringTypeActiveSubscription: FfiConverterRustBuffer {
    public static func write(_ value: [String: ActiveSubscription], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeActiveSubscription.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: ActiveSubscription] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: ActiveSubscription]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeActiveSubscription.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeRelay: FfiConverterRustBuffer {
    public static func write(_ value: [String: Relay], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeRelay.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Relay] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Relay]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeRelay.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

public func generateSharedKey(secretKey: SecretKey, publicKey: PublicKey) throws -> [UInt8] {
    return try  FfiConverterSequenceUInt8.lift(
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_func_generate_shared_key(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypePublicKey.lower(publicKey),$0)
}
    )
}

public func getNip05Profile(nip05: String, proxy: String?) throws -> Profile {
    return try  FfiConverterTypeProfile.lift(
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_func_get_nip05_profile(
        FfiConverterString.lower(nip05),
        FfiConverterOptionString.lower(proxy),$0)
}
    )
}

public func initLogger(level: LogLevel) throws {
    try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_fn_func_init_logger(
        FfiConverterTypeLogLevel.lower(level),$0)
}
}



public func nip04Decrypt(secretKey: SecretKey, publicKey: PublicKey, encryptedContent: String) throws -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_func_nip04_decrypt(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(encryptedContent),$0)
}
    )
}

public func nip04Encrypt(secretKey: SecretKey, publicKey: PublicKey, content: String) throws -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_func_nip04_encrypt(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(content),$0)
}
    )
}

public func verifyNip05(publicKey: PublicKey, nip05: String, proxy: String?) throws {
    try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_sdk_fn_func_verify_nip05(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(nip05),
        FfiConverterOptionString.lower(proxy),$0)
}
}



private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 23
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_nostr_sdk_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_nostr_sdk_checksum_func_generate_shared_key() != 47145) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_func_get_nip05_profile() != 9660) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_func_init_logger() != 53695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_func_nip04_decrypt() != 11951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_func_nip04_encrypt() != 50703) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_func_verify_nip05() != 42566) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_activesubscription_filters() != 19322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_activesubscription_id() != 383) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_add_relay() != 43262) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_clear_already_seen_events() != 34213) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_connect() != 4782) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_connect_relay() != 55271) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_disconnect() != 38823) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_disconnect_relay() != 38378) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_file_metadata() != 49114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_get_events_of() != 43781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_handle_notifications() != 61754) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_is_running() != 2394) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_keys() != 58592) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_relay() != 35154) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_relays() != 36250) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_remove_relay() != 65531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_req_events_of() != 6818) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_send_direct_msg() != 14159) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_send_event() != 6446) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_send_event_to() != 2871) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_send_msg() != 46631) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_send_msg_to() != 36533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_set_metadata() != 45457) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_shutdown() != 10680) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_start() != 3454) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_stop() != 55960) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_subscribe() != 47545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_unsubscribe() != 17245) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_client_update_difficulty() != 63620) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_contact_alias() != 45450) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_contact_public_key() != 38603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_contact_relay_url() != 33739) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_event_as_json() != 27244) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_event_content() != 15708) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_event_created_at() != 50842) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_event_id() != 18715) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_event_kind() != 10572) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_event_pubkey() != 47828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_event_signature() != 33225) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_event_tags() != 21259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_event_verify() != 15159) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_eventbuilder_to_event() != 43560) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_eventbuilder_to_pow_event() != 2712) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_eventbuilder_to_unsigned_event() != 6114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_eventbuilder_to_unsigned_pow_event() != 21920) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_eventid_as_bytes() != 63839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_eventid_to_bech32() != 23428) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_eventid_to_hex() != 47287) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_eventid_to_nostr_uri() != 11366) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filemetadata_aes_256_gcm() != 53837) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filemetadata_blurhash() != 25718) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filemetadata_dimensions() != 374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filemetadata_magnet() != 55248) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filemetadata_size() != 12937) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_as_json() != 43723) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_author() != 21507) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_authors() != 1086) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_custom_tag() != 14971) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_event() != 21102) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_events() != 53359) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_id() != 46827) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_identifier() != 14188) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_ids() != 38090) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_kind() != 47478) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_kinds() != 31533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_limit() != 43274) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_pubkey() != 63494) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_pubkeys() != 29064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_search() != 46852) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_since() != 19109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_filter_until() != 47684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_imagedimensions_height() != 21282) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_imagedimensions_width() != 42051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_keys_public_key() != 13057) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_keys_secret_key() != 35488) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_as_json() != 54041) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_get_about() != 46433) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_get_banner() != 55138) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_get_display_name() != 609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_get_lud06() != 19572) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_get_lud16() != 32540) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_get_name() != 57713) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_get_nip05() != 46486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_get_picture() != 51580) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_get_website() != 61243) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_set_about() != 50843) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_set_banner() != 59633) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_set_display_name() != 41035) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_set_lud06() != 40524) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_set_lud16() != 10472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_set_name() != 54513) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_set_nip05() != 58855) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_set_picture() != 53891) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_metadata_set_website() != 45184) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_nostrconnecturi_description() != 2785) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_nostrconnecturi_name() != 54969) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_nostrconnecturi_public_key() != 22018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_nostrconnecturi_relay_url() != 35561) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_nostrconnecturi_url() != 10388) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_options_difficulty() != 62014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_options_nip46_timeout() != 36970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_options_req_filters_chunk_size() != 28630) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_options_send_timeout() != 46670) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_options_skip_disconnected_relays() != 10932) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_options_timeout() != 31695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_options_wait_for_connection() != 20410) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_options_wait_for_send() != 6906) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_options_wait_for_subscription() != 42430) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_profile_public_key() != 49157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_profile_relays() != 64533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_profile_to_bech32() != 21319) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_profile_to_nostr_uri() != 8282) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_publickey_to_bech32() != 33919) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_publickey_to_hex() != 29316) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_publickey_to_nostr_uri() != 43332) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_connect() != 13856) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_document() != 17603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_get_events_of() != 62980) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_is_connected() != 62689) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_proxy() != 40033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_queue() != 12643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_req_events_of() != 62052) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_send_msg() != 45256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_stats() != 32225) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_status() != 25758) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_stop() != 8562) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_subscribe() != 58450) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_subscriptions() != 46410) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_terminate() != 51031) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_unsubscribe() != 6404) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_update_subscription_filters() != 45793) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relay_url() != 48169) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relayconnectionstats_attempts() != 56764) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relayconnectionstats_bytes_received() != 54009) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relayconnectionstats_bytes_sent() != 9079) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relayconnectionstats_connected_at() != 28659) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relayconnectionstats_latency() != 25342) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relayconnectionstats_success() != 38538) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relayinformationdocument_contact() != 31013) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relayinformationdocument_description() != 62938) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relayinformationdocument_name() != 14438) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relayinformationdocument_pubkey() != 9393) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relayinformationdocument_software() != 11948) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relayinformationdocument_supported_nips() != 17796) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_relayinformationdocument_version() != 55568) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_secretkey_to_bech32() != 59993) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_secretkey_to_hex() != 28675) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_tag_as_enum() != 25306) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_tag_as_vec() != 61602) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_tag_kind() != 27825) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_timestamp_as_secs() != 5603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_timestamp_to_human_datetime() != 10584) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_unsignedevent_add_signature() != 45009) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_unsignedevent_as_json() != 3195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_unsignedevent_content() != 47764) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_unsignedevent_created_at() != 24542) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_unsignedevent_id() != 28308) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_unsignedevent_kind() != 52236) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_unsignedevent_pubkey() != 50542) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_unsignedevent_sign() != 26628) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_unsignedevent_tags() != 25085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_zaprequestdata_amount() != 61892) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_zaprequestdata_event_id() != 50159) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_zaprequestdata_lnurl() != 18795) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_client_new() != 7546) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_client_with_opts() != 6519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_contact_new() != 25304) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_event_from_json() != 1263) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_add_recommended_relay() != 3296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_auth() != 38004) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_delete() != 13131) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_file_metadata() != 3694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_hide_channel_msg() != 1863) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_long_form_text_note() != 37444) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_mute_channel_user() != 16578) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_new() != 23750) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_channel() != 58046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_channel_msg() != 40254) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_encrypted_direct_msg() != 18140) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_reaction() != 58121) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_text_note() != 32633) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_zap_receipt() != 12040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_new_zap_request() != 53535) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_report() != 4664) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_repost() != 21237) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_set_channel_metadata() != 27440) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_set_contact_list() != 44638) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventbuilder_set_metadata() != 53610) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventid_from_bech32() != 29645) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventid_from_bytes() != 51838) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventid_from_hex() != 12198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventid_from_nostr_uri() != 35802) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_eventid_new() != 30886) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_filemetadata_new() != 42757) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_filter_from_json() != 65200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_filter_new() != 63667) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_imagedimensions_new() != 64564) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_keys_from_mnemonic() != 50615) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_keys_from_pk_str() != 45484) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_keys_from_public_key() != 27655) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_keys_from_sk_str() != 61833) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_keys_generate() != 13660) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_keys_new() != 50806) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_keys_vanity() != 16628) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_metadata_from_json() != 38921) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_metadata_new() != 20882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_nostrconnecturi_from_string() != 36187) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_options_new() != 51438) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_profile_from_bech32() != 29526) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_profile_from_nostr_uri() != 30948) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_profile_new() != 47057) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_publickey_from_bech32() != 37962) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_publickey_from_bytes() != 27563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_publickey_from_hex() != 62816) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_publickey_from_nostr_uri() != 37347) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_relayinformationdocument_get() != 837) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_secretkey_from_bech32() != 8161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_secretkey_from_bytes() != 7850) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_secretkey_from_hex() != 45953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_tag_from_enum() != 62896) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_tag_parse() != 31797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_timestamp_from_secs() != 55991) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_timestamp_now() != 52567) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_unsignedevent_from_json() != 38935) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_constructor_zaprequestdata_new() != 35285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_handlenotification_handle_msg() != 20088) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_checksum_method_handlenotification_handle() != 1610) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}