// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(nostr_sdk_ffiFFI)
import nostr_sdk_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_nostr_sdk_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_nostr_sdk_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}




public protocol ClientProtocol : AnyObject {
    
    /**
     * Add discovery relay
     *
     * If relay already exists, this method automatically add the `DISCOVERY` flag to it and return `false`.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/65.md>
     */
    func addDiscoveryRelay(url: String) async throws  -> Bool
    
    /**
     * Add read relay
     *
     * If relay already exists, this method add the `READ` flag to it and return `false`.
     *
     * If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
     * to avoid to set pool subscriptions.
     */
    func addReadRelay(url: String) async throws  -> Bool
    
    /**
     * Add new relay
     *
     * Relays added with this method will have both `READ` and `WRITE` flags enabled
     *
     * If the relay already exists, the flags will be updated and `false` returned.
     *
     * If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
     * to avoid to set pool subscriptions.
     *
     * This method use previously set or default `Options` to configure the `Relay` (ex. set proxy, set min POW, set relay limits, ...).
     * To use custom `RelayOptions` use `add_relay` method on `RelayPool`.
     *
     * Connection is **NOT** automatically started with relay, remember to call `connect` method!
     */
    func addRelay(url: String) async throws  -> Bool
    
    /**
     * Add write relay
     *
     * If relay already exists, this method add the `WRITE` flag to it and return `false`.
     */
    func addWriteRelay(url: String) async throws  -> Bool
    
    /**
     * Auto authenticate to relays (default: true)
     *
     * <https://github.com/nostr-protocol/nips/blob/master/42.md>
     */
    func automaticAuthentication(enable: Bool) 
    
    /**
     * Connect to all added relays
     */
    func connect() async 
    
    /**
     * Connect to a previously added relay
     */
    func connectRelay(url: String) async throws 
    
    /**
     * Connect to all added relays
     *
     * Try to connect to the relays and wait for them to be connected at most for the specified `timeout`.
     * The code continues if the `timeout` is reached or if all relays connect.
     */
    func connectWithTimeout(timeout: TimeInterval) async 
    
    func database()  -> NostrDatabase
    
    func disconnect() async throws 
    
    func disconnectRelay(url: String) async throws 
    
    /**
     * Disike event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
    func dislike(event: Event) async throws  -> SendEventOutput
    
    /**
     * Fetch the newest public key metadata from database and connected relays.
     *
     * If you only want to consult cached data,
     * consider `client.database().profile(PUBKEY)`.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func fetchMetadata(publicKey: PublicKey, timeout: TimeInterval?) async throws  -> Metadata
    
    func fileMetadata(description: String, metadata: FileMetadata) async throws  -> SendEventOutput
    
    /**
     * Get filtering
     */
    func filtering()  -> RelayFiltering
    
    /**
     * Get events of filters from specific relays
     */
    func getEventsFrom(urls: [String], filters: [Filter], timeout: TimeInterval?) async throws  -> [Event]
    
    /**
     * Get events of filters
     *
     * The returned events are sorted by newest first, if there is a limit only the newest are returned.
     *
     * If `gossip` is enabled (see `Options]) the events will be requested also to
     * NIP-65 relays (automatically discovered) of public keys included in filters (if any).
     */
    func getEventsOf(filters: [Filter], source: EventSource) async throws  -> [Event]
    
    /**
     * Construct Gift Wrap and send to all relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
    func giftWrap(receiver: PublicKey, rumor: EventBuilder, expiration: Timestamp?) async throws  -> SendEventOutput
    
    /**
     * Construct Gift Wrap and send to specific relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
    func giftWrapTo(urls: [String], receiver: PublicKey, rumor: EventBuilder, expiration: Timestamp?) async throws  -> SendEventOutput
    
    /**
     * Handle notifications
     */
    func handleNotifications(handler: HandleNotification) async throws 
    
    /**
     * Like event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
    func like(event: Event) async throws  -> SendEventOutput
    
    /**
     * Get relay pool
     */
    func pool()  -> RelayPool
    
    /**
     * React to an [`Event`]
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
    func reaction(event: Event, reaction: String) async throws  -> SendEventOutput
    
    func reconcile(filter: Filter, opts: NegentropyOptions) async throws  -> ReconciliationOutput
    
    func relay(url: String) async throws  -> Relay
    
    /**
     * Get relays with `READ` or `WRITE` flags
     */
    func relays() async  -> [String: Relay]
    
    func removeRelay(url: String) async throws 
    
    /**
     * Repost
     */
    func repost(event: Event, relayUrl: String?) async throws  -> SendEventOutput
    
    /**
     * Send event
     *
     * Send event to all relays with `WRITE` flag.
     * If `gossip` is enabled (see `Options`) the event will be sent also to NIP-65 relays (automatically discovered).
     */
    func sendEvent(event: Event) async throws  -> SendEventOutput
    
    /**
     * Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to relays (check `send_event` method for more details)
     *
     * Rise an error if the `NostrSigner` is not set.
     */
    func sendEventBuilder(builder: EventBuilder) async throws  -> SendEventOutput
    
    /**
     * Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to specific relays.
     *
     * Rise an error if the `NostrSigner` is not set.
     */
    func sendEventBuilderTo(urls: [String], builder: EventBuilder) async throws  -> SendEventOutput
    
    /**
     * Send event to specific relays.
     */
    func sendEventTo(urls: [String], event: Event) async throws  -> SendEventOutput
    
    func sendMsgTo(urls: [String], msg: ClientMessage) async throws  -> Output
    
    /**
     * Send private direct message to all relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/17.md>
     */
    func sendPrivateMsg(receiver: PublicKey, message: String, replyTo: EventId?) async throws  -> SendEventOutput
    
    /**
     * Send private direct message to specific relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/17.md>
     */
    func sendPrivateMsgTo(urls: [String], receiver: PublicKey, message: String, replyTo: EventId?) async throws  -> SendEventOutput
    
    func setMetadata(metadata: Metadata) async throws  -> SendEventOutput
    
    func shutdown() async throws 
    
    /**
     * Signs the `EventBuilder` into an `Event` using the `NostrSigner`
     */
    func signEventBuilder(builder: EventBuilder) async throws  -> Event
    
    func signer() async throws  -> NostrSigner
    
    /**
     * Subscribe to filters
     *
     * If `gossip` is enabled (see `Options]) the events will be requested also to
     * NIP-65 relays (automatically discovered) of public keys included in filters (if any).
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
    func subscribe(filters: [Filter], opts: SubscribeAutoCloseOptions?) async throws  -> SubscribeOutput
    
    /**
     * Subscribe to filters to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
    func subscribeTo(urls: [String], filters: [Filter], opts: SubscribeAutoCloseOptions?) async throws  -> SubscribeOutput
    
    /**
     * Subscribe to filters with custom subscription ID
     *
     * If `gossip` is enabled (see `Options]) the events will be requested also to
     * NIP-65 relays (automatically discovered) of public keys included in filters (if any).
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
    func subscribeWithId(id: String, filters: [Filter], opts: SubscribeAutoCloseOptions?) async throws  -> Output
    
    /**
     * Subscribe to filters with custom subscription ID to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
    func subscribeWithIdTo(urls: [String], id: String, filters: [Filter], opts: SubscribeAutoCloseOptions?) async throws  -> Output
    
    func subscription(id: String) async  -> [Filter]?
    
    func subscriptions() async  -> [String: [Filter]]
    
    func unsubscribe(subscriptionId: String) async 
    
    func unsubscribeAll() async 
    
    /**
     * Unwrap Gift Wrap event
     *
     * Internally verify the `seal` event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
    func unwrapGiftWrap(giftWrap: Event) async throws  -> UnwrappedGift
    
    /**
     * Update default difficulty for new `Event`
     */
    func updateDifficulty(difficulty: UInt8) 
    
    /**
     * Update minimum POW difficulty for received events
     *
     * Events with a POW lower than the current value will be ignored to prevent resources exhaustion.
     */
    func updateMinPowDifficulty(difficulty: UInt8) 
    
    /**
     * Send a Zap!
     */
    func zap(to: ZapEntity, satoshi: UInt64, details: ZapDetails?) async throws 
    
}

open class Client:
    ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_client(self.pointer, $0) }
    }
public convenience init(signer: NostrSigner? = nil) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_client_new(
        FfiConverterOptionTypeNostrSigner.lower(signer),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_client(pointer, $0) }
    }

    
public static func withOpts(signer: NostrSigner?, opts: Options) -> Client {
    return try!  FfiConverterTypeClient.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_client_with_opts(
        FfiConverterOptionTypeNostrSigner.lower(signer),
        FfiConverterTypeOptions.lower(opts),$0
    )
})
}
    

    
    /**
     * Add discovery relay
     *
     * If relay already exists, this method automatically add the `DISCOVERY` flag to it and return `false`.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/65.md>
     */
open func addDiscoveryRelay(url: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_add_discovery_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Add read relay
     *
     * If relay already exists, this method add the `READ` flag to it and return `false`.
     *
     * If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
     * to avoid to set pool subscriptions.
     */
open func addReadRelay(url: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_add_read_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Add new relay
     *
     * Relays added with this method will have both `READ` and `WRITE` flags enabled
     *
     * If the relay already exists, the flags will be updated and `false` returned.
     *
     * If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
     * to avoid to set pool subscriptions.
     *
     * This method use previously set or default `Options` to configure the `Relay` (ex. set proxy, set min POW, set relay limits, ...).
     * To use custom `RelayOptions` use `add_relay` method on `RelayPool`.
     *
     * Connection is **NOT** automatically started with relay, remember to call `connect` method!
     */
open func addRelay(url: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_add_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Add write relay
     *
     * If relay already exists, this method add the `WRITE` flag to it and return `false`.
     */
open func addWriteRelay(url: String)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_add_write_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Auto authenticate to relays (default: true)
     *
     * <https://github.com/nostr-protocol/nips/blob/master/42.md>
     */
open func automaticAuthentication(enable: Bool) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_automatic_authentication(self.uniffiClonePointer(),
        FfiConverterBool.lower(enable),$0
    )
}
}
    
    /**
     * Connect to all added relays
     */
open func connect()async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_connect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Connect to a previously added relay
     */
open func connectRelay(url: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_connect_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Connect to all added relays
     *
     * Try to connect to the relays and wait for them to be connected at most for the specified `timeout`.
     * The code continues if the `timeout` is reached or if all relays connect.
     */
open func connectWithTimeout(timeout: TimeInterval)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_connect_with_timeout(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func database() -> NostrDatabase {
    return try!  FfiConverterTypeNostrDatabase.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_database(self.uniffiClonePointer(),$0
    )
})
}
    
open func disconnect()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_disconnect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func disconnectRelay(url: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_disconnect_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Disike event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
open func dislike(event: Event)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_dislike(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Fetch the newest public key metadata from database and connected relays.
     *
     * If you only want to consult cached data,
     * consider `client.database().profile(PUBKEY)`.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
open func fetchMetadata(publicKey: PublicKey, timeout: TimeInterval? = nil)async throws  -> Metadata {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_fetch_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterOptionDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeMetadata_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func fileMetadata(description: String, metadata: FileMetadata)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_file_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(description),FfiConverterTypeFileMetadata_lower(metadata)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get filtering
     */
open func filtering() -> RelayFiltering {
    return try!  FfiConverterTypeRelayFiltering.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_filtering(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get events of filters from specific relays
     */
open func getEventsFrom(urls: [String], filters: [Filter], timeout: TimeInterval?)async throws  -> [Event] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_get_events_from(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterOptionDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get events of filters
     *
     * The returned events are sorted by newest first, if there is a limit only the newest are returned.
     *
     * If `gossip` is enabled (see `Options]) the events will be requested also to
     * NIP-65 relays (automatically discovered) of public keys included in filters (if any).
     */
open func getEventsOf(filters: [Filter], source: EventSource)async throws  -> [Event] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_get_events_of(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters),FfiConverterTypeEventSource.lower(source)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Construct Gift Wrap and send to all relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
open func giftWrap(receiver: PublicKey, rumor: EventBuilder, expiration: Timestamp?)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_gift_wrap(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(receiver),FfiConverterTypeEventBuilder_lower(rumor),FfiConverterOptionTypeTimestamp.lower(expiration)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Construct Gift Wrap and send to specific relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
open func giftWrapTo(urls: [String], receiver: PublicKey, rumor: EventBuilder, expiration: Timestamp?)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_gift_wrap_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterTypePublicKey_lower(receiver),FfiConverterTypeEventBuilder_lower(rumor),FfiConverterOptionTypeTimestamp.lower(expiration)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Handle notifications
     */
open func handleNotifications(handler: HandleNotification)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_handle_notifications(
                    self.uniffiClonePointer(),
                    FfiConverterTypeHandleNotification.lower(handler)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Like event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
open func like(event: Event)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_like(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get relay pool
     */
open func pool() -> RelayPool {
    return try!  FfiConverterTypeRelayPool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_pool(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * React to an [`Event`]
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
open func reaction(event: Event, reaction: String)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_reaction(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event),FfiConverterString.lower(reaction)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func reconcile(filter: Filter, opts: NegentropyOptions)async throws  -> ReconciliationOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_reconcile(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterTypeNegentropyOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeReconciliationOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func relay(url: String)async throws  -> Relay {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRelay.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get relays with `READ` or `WRITE` flags
     */
open func relays()async  -> [String: Relay] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_relays(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringTypeRelay.lift,
            errorHandler: nil
            
        )
}
    
open func removeRelay(url: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_remove_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Repost
     */
open func repost(event: Event, relayUrl: String?)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_repost(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event),FfiConverterOptionString.lower(relayUrl)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send event
     *
     * Send event to all relays with `WRITE` flag.
     * If `gossip` is enabled (see `Options`) the event will be sent also to NIP-65 relays (automatically discovered).
     */
open func sendEvent(event: Event)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to relays (check `send_event` method for more details)
     *
     * Rise an error if the `NostrSigner` is not set.
     */
open func sendEventBuilder(builder: EventBuilder)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventBuilder_lower(builder)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to specific relays.
     *
     * Rise an error if the `NostrSigner` is not set.
     */
open func sendEventBuilderTo(urls: [String], builder: EventBuilder)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterTypeEventBuilder_lower(builder)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send event to specific relays.
     */
open func sendEventTo(urls: [String], event: Event)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_event_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func sendMsgTo(urls: [String], msg: ClientMessage)async throws  -> Output {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_msg_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterTypeClientMessage_lower(msg)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send private direct message to all relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/17.md>
     */
open func sendPrivateMsg(receiver: PublicKey, message: String, replyTo: EventId? = nil)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_private_msg(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(receiver),FfiConverterString.lower(message),FfiConverterOptionTypeEventId.lower(replyTo)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send private direct message to specific relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/17.md>
     */
open func sendPrivateMsgTo(urls: [String], receiver: PublicKey, message: String, replyTo: EventId? = nil)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_private_msg_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterTypePublicKey_lower(receiver),FfiConverterString.lower(message),FfiConverterOptionTypeEventId.lower(replyTo)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func setMetadata(metadata: Metadata)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_set_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMetadata_lower(metadata)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func shutdown()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_shutdown(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Signs the `EventBuilder` into an `Event` using the `NostrSigner`
     */
open func signEventBuilder(builder: EventBuilder)async throws  -> Event {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_sign_event_builder(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventBuilder_lower(builder)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvent_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func signer()async throws  -> NostrSigner {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_signer(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNostrSigner.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Subscribe to filters
     *
     * If `gossip` is enabled (see `Options]) the events will be requested also to
     * NIP-65 relays (automatically discovered) of public keys included in filters (if any).
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
open func subscribe(filters: [Filter], opts: SubscribeAutoCloseOptions? = nil)async throws  -> SubscribeOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscribe(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters),FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSubscribeOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Subscribe to filters to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
open func subscribeTo(urls: [String], filters: [Filter], opts: SubscribeAutoCloseOptions? = nil)async throws  -> SubscribeOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscribe_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSubscribeOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Subscribe to filters with custom subscription ID
     *
     * If `gossip` is enabled (see `Options]) the events will be requested also to
     * NIP-65 relays (automatically discovered) of public keys included in filters (if any).
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
open func subscribeWithId(id: String, filters: [Filter], opts: SubscribeAutoCloseOptions? = nil)async throws  -> Output {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscribe_with_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Subscribe to filters with custom subscription ID to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
open func subscribeWithIdTo(urls: [String], id: String, filters: [Filter], opts: SubscribeAutoCloseOptions? = nil)async throws  -> Output {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscribe_with_id_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterString.lower(id),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func subscription(id: String)async  -> [Filter]? {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscription(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
open func subscriptions()async  -> [String: [Filter]] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscriptions(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
open func unsubscribe(subscriptionId: String)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(subscriptionId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func unsubscribeAll()async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe_all(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Unwrap Gift Wrap event
     *
     * Internally verify the `seal` event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
open func unwrapGiftWrap(giftWrap: Event)async throws  -> UnwrappedGift {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_unwrap_gift_wrap(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(giftWrap)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeUnwrappedGift_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Update default difficulty for new `Event`
     */
open func updateDifficulty(difficulty: UInt8) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_update_difficulty(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
}
}
    
    /**
     * Update minimum POW difficulty for received events
     *
     * Events with a POW lower than the current value will be ignored to prevent resources exhaustion.
     */
open func updateMinPowDifficulty(difficulty: UInt8) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_update_min_pow_difficulty(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
}
}
    
    /**
     * Send a Zap!
     */
open func zap(to: ZapEntity, satoshi: UInt64, details: ZapDetails?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_zap(
                    self.uniffiClonePointer(),
                    FfiConverterTypeZapEntity.lower(to),FfiConverterUInt64.lower(satoshi),FfiConverterOptionTypeZapDetails.lower(details)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

}

public struct FfiConverterTypeClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}




public protocol ClientBuilderProtocol : AnyObject {
    
    /**
     * Build [`Client`]
     */
    func build()  -> Client
    
    func database(database: NostrDatabase)  -> ClientBuilder
    
    /**
     * Set opts
     */
    func opts(opts: Options)  -> ClientBuilder
    
    func signer(signer: NostrSigner)  -> ClientBuilder
    
    func zapper(zapper: NostrZapper)  -> ClientBuilder
    
}

open class ClientBuilder:
    ClientBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_clientbuilder(self.pointer, $0) }
    }
    /**
     * New client builder
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_clientbuilder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_clientbuilder(pointer, $0) }
    }

    

    
    /**
     * Build [`Client`]
     */
open func build() -> Client {
    return try!  FfiConverterTypeClient.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_build(self.uniffiClonePointer(),$0
    )
})
}
    
open func database(database: NostrDatabase) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_database(self.uniffiClonePointer(),
        FfiConverterTypeNostrDatabase.lower(database),$0
    )
})
}
    
    /**
     * Set opts
     */
open func opts(opts: Options) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_opts(self.uniffiClonePointer(),
        FfiConverterTypeOptions.lower(opts),$0
    )
})
}
    
open func signer(signer: NostrSigner) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_signer(self.uniffiClonePointer(),
        FfiConverterTypeNostrSigner.lower(signer),$0
    )
})
}
    
open func zapper(zapper: NostrZapper) -> ClientBuilder {
    return try!  FfiConverterTypeClientBuilder.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_zapper(self.uniffiClonePointer(),
        FfiConverterTypeNostrZapper.lower(zapper),$0
    )
})
}
    

}

public struct FfiConverterTypeClientBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
        return ClientBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
    return try FfiConverterTypeClientBuilder.lift(pointer)
}

public func FfiConverterTypeClientBuilder_lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientBuilder.lower(value)
}




/**
 * Connection
 */
public protocol ConnectionProtocol : AnyObject {
    
    /**
     * Set proxy (ex. `127.0.0.1:9050`)
     */
    func addr(addr: String) throws  -> Connection
    
    /**
     * Use embedded tor client
     */
    func embeddedTor(dataPath: String)  -> Connection
    
    /**
     * Set connection mode (default: direct)
     */
    func mode(mode: ConnectionMode) throws  -> Connection
    
    /**
     * Set connection target (default: all)
     */
    func target(target: ConnectionTarget)  -> Connection
    
}

/**
 * Connection
 */
open class Connection:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    ConnectionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_connection(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_connection_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_connection(pointer, $0) }
    }

    

    
    /**
     * Set proxy (ex. `127.0.0.1:9050`)
     */
open func addr(addr: String)throws  -> Connection {
    return try  FfiConverterTypeConnection.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_connection_addr(self.uniffiClonePointer(),
        FfiConverterString.lower(addr),$0
    )
})
}
    
    /**
     * Use embedded tor client
     */
open func embeddedTor(dataPath: String) -> Connection {
    return try!  FfiConverterTypeConnection.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_connection_embedded_tor(self.uniffiClonePointer(),
        FfiConverterString.lower(dataPath),$0
    )
})
}
    
    /**
     * Set connection mode (default: direct)
     */
open func mode(mode: ConnectionMode)throws  -> Connection {
    return try  FfiConverterTypeConnection.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_connection_mode(self.uniffiClonePointer(),
        FfiConverterTypeConnectionMode.lower(mode),$0
    )
})
}
    
    /**
     * Set connection target (default: all)
     */
open func target(target: ConnectionTarget) -> Connection {
    return try!  FfiConverterTypeConnection.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_connection_target(self.uniffiClonePointer(),
        FfiConverterTypeConnectionTarget.lower(target),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Connection, other: Connection) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeConnection.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeConnection: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Connection

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Connection {
        return Connection(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Connection) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Connection {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Connection, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeConnection_lift(_ pointer: UnsafeMutableRawPointer) throws -> Connection {
    return try FfiConverterTypeConnection.lift(pointer)
}

public func FfiConverterTypeConnection_lower(_ value: Connection) -> UnsafeMutableRawPointer {
    return FfiConverterTypeConnection.lower(value)
}




public protocol CustomNostrDatabase : AnyObject {
    
    /**
     * Name of backend
     */
    func backend()  -> String
    
    /**
     * Save [`Event`] into store
     *
     * Return `true` if event was successfully saved into database.
     *
     * **This method assume that [`Event`] was already verified**
     */
    func saveEvent(event: Event) async throws  -> Bool
    
    /**
     * Check event status by ID
     *
     * Check if the event is saved, deleted or not existent.
     */
    func checkId(eventId: EventId) async throws  -> DatabaseEventStatus
    
    /**
     * Check if event with [`Coordinate`] has been deleted before [`Timestamp`]
     */
    func hasCoordinateBeenDeleted(coordinate: Coordinate, timestamp: Timestamp) async throws  -> Bool
    
    /**
     * Set [`EventId`] as seen by relay
     *
     * Useful for NIP65 (aka gossip)
     */
    func eventIdSeen(eventId: EventId, relayUrl: String) async throws 
    
    /**
     * Get list of relays that have seen the [`EventId`]
     */
    func eventSeenOnRelays(eventId: EventId) async throws  -> [String]?
    
    /**
     * Get event by ID
     */
    func eventById(eventId: EventId) async throws  -> Event?
    
    /**
     * Count number of [`Event`] found by filters
     *
     * Use `Filter::new()` or `Filter::default()` to count all events.
     */
    func count(filters: [Filter]) async throws  -> UInt64
    
    /**
     * Query store with filters
     */
    func query(filters: [Filter]) async throws  -> [Event]
    
    /**
     * Delete all events that match the `Filter`
     */
    func delete(filter: Filter) async throws 
    
    /**
     * Wipe all data
     */
    func wipe() async throws 
    
}

open class CustomNostrDatabaseImpl:
    CustomNostrDatabase {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_customnostrdatabase(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_customnostrdatabase(pointer, $0) }
    }

    

    
    /**
     * Name of backend
     */
open func backend() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_backend(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Save [`Event`] into store
     *
     * Return `true` if event was successfully saved into database.
     *
     * **This method assume that [`Event`] was already verified**
     */
open func saveEvent(event: Event)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_save_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Check event status by ID
     *
     * Check if the event is saved, deleted or not existent.
     */
open func checkId(eventId: EventId)async throws  -> DatabaseEventStatus {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_check_id(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeDatabaseEventStatus.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Check if event with [`Coordinate`] has been deleted before [`Timestamp`]
     */
open func hasCoordinateBeenDeleted(coordinate: Coordinate, timestamp: Timestamp)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_has_coordinate_been_deleted(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCoordinate_lower(coordinate),FfiConverterTypeTimestamp_lower(timestamp)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Set [`EventId`] as seen by relay
     *
     * Useful for NIP65 (aka gossip)
     */
open func eventIdSeen(eventId: EventId, relayUrl: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_event_id_seen(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId),FfiConverterString.lower(relayUrl)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get list of relays that have seen the [`EventId`]
     */
open func eventSeenOnRelays(eventId: EventId)async throws  -> [String]? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_event_seen_on_relays(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get event by ID
     */
open func eventById(eventId: EventId)async throws  -> Event? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_event_by_id(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Count number of [`Event`] found by filters
     *
     * Use `Filter::new()` or `Filter::default()` to count all events.
     */
open func count(filters: [Filter])async throws  -> UInt64 {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_count(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Query store with filters
     */
open func query(filters: [Filter])async throws  -> [Event] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_query(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Delete all events that match the `Filter`
     */
open func delete(filter: Filter)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_delete(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Wipe all data
     */
open func wipe()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_wipe(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceCustomNostrDatabase {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceCustomNostrDatabase = UniffiVTableCallbackInterfaceCustomNostrDatabase(
        backend: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> String in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.backend(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        saveEvent: { (
            uniffiHandle: UInt64,
            event: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteI8,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Bool in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveEvent(
                     event: try FfiConverterTypeEvent_lift(event)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Bool) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructI8(
                        returnValue: FfiConverterBool.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructI8(
                        returnValue: 0,
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        checkId: { (
            uniffiHandle: UInt64,
            eventId: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> DatabaseEventStatus in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.checkId(
                     eventId: try FfiConverterTypeEventId_lift(eventId)
                )
            }

            let uniffiHandleSuccess = { (returnValue: DatabaseEventStatus) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeDatabaseEventStatus.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        hasCoordinateBeenDeleted: { (
            uniffiHandle: UInt64,
            coordinate: UnsafeMutableRawPointer,
            timestamp: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteI8,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Bool in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.hasCoordinateBeenDeleted(
                     coordinate: try FfiConverterTypeCoordinate_lift(coordinate),
                     timestamp: try FfiConverterTypeTimestamp_lift(timestamp)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Bool) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructI8(
                        returnValue: FfiConverterBool.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructI8(
                        returnValue: 0,
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        eventIdSeen: { (
            uniffiHandle: UInt64,
            eventId: UnsafeMutableRawPointer,
            relayUrl: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.eventIdSeen(
                     eventId: try FfiConverterTypeEventId_lift(eventId),
                     relayUrl: try FfiConverterString.lift(relayUrl)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        eventSeenOnRelays: { (
            uniffiHandle: UInt64,
            eventId: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [String]? in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.eventSeenOnRelays(
                     eventId: try FfiConverterTypeEventId_lift(eventId)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [String]?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionSequenceString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        eventById: { (
            uniffiHandle: UInt64,
            eventId: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Event? in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.eventById(
                     eventId: try FfiConverterTypeEventId_lift(eventId)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Event?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeEvent.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        count: { (
            uniffiHandle: UInt64,
            filters: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteU64,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> UInt64 in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.count(
                     filters: try FfiConverterSequenceTypeFilter.lift(filters)
                )
            }

            let uniffiHandleSuccess = { (returnValue: UInt64) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructU64(
                        returnValue: FfiConverterUInt64.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructU64(
                        returnValue: 0,
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        query: { (
            uniffiHandle: UInt64,
            filters: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Event] in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.query(
                     filters: try FfiConverterSequenceTypeFilter.lift(filters)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Event]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeEvent.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        delete: { (
            uniffiHandle: UInt64,
            filter: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.delete(
                     filter: try FfiConverterTypeFilter_lift(filter)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        wipe: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.wipe(
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeCustomNostrDatabase.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface CustomNostrDatabase: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitCustomNostrDatabase() {
    uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customnostrdatabase(&UniffiCallbackInterfaceCustomNostrDatabase.vtable)
}

public struct FfiConverterTypeCustomNostrDatabase: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<CustomNostrDatabase>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CustomNostrDatabase

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CustomNostrDatabase {
        return CustomNostrDatabaseImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CustomNostrDatabase) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CustomNostrDatabase {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CustomNostrDatabase, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeCustomNostrDatabase_lift(_ pointer: UnsafeMutableRawPointer) throws -> CustomNostrDatabase {
    return try FfiConverterTypeCustomNostrDatabase.lift(pointer)
}

public func FfiConverterTypeCustomNostrDatabase_lower(_ value: CustomNostrDatabase) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCustomNostrDatabase.lower(value)
}




public protocol EventSourceProtocol : AnyObject {
    
}

open class EventSource:
    EventSourceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_eventsource(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_eventsource(pointer, $0) }
    }

    
    /**
     * Both from database and relays
     */
public static func both(timeout: TimeInterval? = nil) -> EventSource {
    return try!  FfiConverterTypeEventSource.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventsource_both(
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    
    /**
     * Both from database and specific relays
     */
public static func bothWithSpecificRelays(urls: [String], timeout: TimeInterval? = nil) -> EventSource {
    return try!  FfiConverterTypeEventSource.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventsource_both_with_specific_relays(
        FfiConverterSequenceString.lower(urls),
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    
    /**
     * Database only
     */
public static func database() -> EventSource {
    return try!  FfiConverterTypeEventSource.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventsource_database($0
    )
})
}
    
    /**
     * Relays only
     */
public static func relays(timeout: TimeInterval? = nil) -> EventSource {
    return try!  FfiConverterTypeEventSource.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventsource_relays(
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    
    /**
     * From specific relays only
     */
public static func specificRelays(urls: [String], timeout: TimeInterval? = nil) -> EventSource {
    return try!  FfiConverterTypeEventSource.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventsource_specific_relays(
        FfiConverterSequenceString.lower(urls),
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    

    

}

public struct FfiConverterTypeEventSource: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventSource

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventSource {
        return EventSource(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventSource) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventSource {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventSource, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeEventSource_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventSource {
    return try FfiConverterTypeEventSource.lift(pointer)
}

public func FfiConverterTypeEventSource_lower(_ value: EventSource) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventSource.lower(value)
}




public protocol HandleNotification : AnyObject {
    
    func handleMsg(relayUrl: String, msg: RelayMessage) async 
    
    func handle(relayUrl: String, subscriptionId: String, event: Event) async 
    
}

open class HandleNotificationImpl:
    HandleNotification {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_handlenotification(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_handlenotification(pointer, $0) }
    }

    

    
open func handleMsg(relayUrl: String, msg: RelayMessage)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_handlenotification_handle_msg(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(relayUrl),FfiConverterTypeRelayMessage_lower(msg)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func handle(relayUrl: String, subscriptionId: String, event: Event)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_handlenotification_handle(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(relayUrl),FfiConverterString.lower(subscriptionId),FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceHandleNotification {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceHandleNotification = UniffiVTableCallbackInterfaceHandleNotification(
        handleMsg: { (
            uniffiHandle: UInt64,
            relayUrl: RustBuffer,
            msg: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeHandleNotification.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.handleMsg(
                     relayUrl: try FfiConverterString.lift(relayUrl),
                     msg: try FfiConverterTypeRelayMessage_lift(msg)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        handle: { (
            uniffiHandle: UInt64,
            relayUrl: RustBuffer,
            subscriptionId: RustBuffer,
            event: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeHandleNotification.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.handle(
                     relayUrl: try FfiConverterString.lift(relayUrl),
                     subscriptionId: try FfiConverterString.lift(subscriptionId),
                     event: try FfiConverterTypeEvent_lift(event)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeHandleNotification.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HandleNotification: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitHandleNotification() {
    uniffi_nostr_sdk_ffi_fn_init_callback_vtable_handlenotification(&UniffiCallbackInterfaceHandleNotification.vtable)
}

public struct FfiConverterTypeHandleNotification: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<HandleNotification>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HandleNotification

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HandleNotification {
        return HandleNotificationImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HandleNotification) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HandleNotification {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HandleNotification, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeHandleNotification_lift(_ pointer: UnsafeMutableRawPointer) throws -> HandleNotification {
    return try FfiConverterTypeHandleNotification.lift(pointer)
}

public func FfiConverterTypeHandleNotification_lower(_ value: HandleNotification) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHandleNotification.lower(value)
}




/**
 * A mock relay for (unit) tests.
 */
public protocol MockRelayProtocol : AnyObject {
    
    func none() async 
    
    /**
     * Shutdown relay
     */
    func shutdown() 
    
    /**
     * Get url
     */
    func url()  -> String
    
}

/**
 * A mock relay for (unit) tests.
 */
open class MockRelay:
    MockRelayProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_mockrelay(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_mockrelay(pointer, $0) }
    }

    
public static func run()async throws  -> MockRelay {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_constructor_mockrelay_run(
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeMockRelay.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

    
open func none()async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_mockrelay__none(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Shutdown relay
     */
open func shutdown() {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_mockrelay_shutdown(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Get url
     */
open func url() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_mockrelay_url(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeMockRelay: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MockRelay

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MockRelay {
        return MockRelay(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MockRelay) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MockRelay {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MockRelay, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeMockRelay_lift(_ pointer: UnsafeMutableRawPointer) throws -> MockRelay {
    return try FfiConverterTypeMockRelay.lift(pointer)
}

public func FfiConverterTypeMockRelay_lower(_ value: MockRelay) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMockRelay.lower(value)
}




/**
 * Nostr Wallet Connect client
 */
public protocol NwcProtocol : AnyObject {
    
    /**
     * Get balance
     */
    func getBalance() async throws  -> UInt64
    
    /**
     * Get info
     */
    func getInfo() async throws  -> GetInfoResponseResult
    
    /**
     * List transactions
     */
    func listTransactions(params: ListTransactionsRequestParams) async throws  -> [LookupInvoiceResponseResult]
    
    /**
     * Lookup invoice
     */
    func lookupInvoice(params: LookupInvoiceRequestParams) async throws  -> LookupInvoiceResponseResult
    
    /**
     * Create invoice
     */
    func makeInvoice(params: MakeInvoiceRequestParams) async throws  -> MakeInvoiceResponseResult
    
    /**
     * Pay invoice
     */
    func payInvoice(invoice: String) async throws  -> String
    
    /**
     * Pay keysend
     */
    func payKeysend(params: PayKeysendRequestParams) async throws  -> PayKeysendResponseResult
    
}

/**
 * Nostr Wallet Connect client
 */
open class Nwc:
    NwcProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nwc(self.pointer, $0) }
    }
    /**
     * Compose new `NWC` client
     */
public convenience init(uri: NostrWalletConnectUri) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nwc_new(
        FfiConverterTypeNostrWalletConnectURI_lower(uri),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nwc(pointer, $0) }
    }

    
    /**
     * Compose new `NWC` client with `NostrWalletConnectOptions`
     */
public static func withOpts(uri: NostrWalletConnectUri, opts: NostrWalletConnectOptions) -> Nwc {
    return try!  FfiConverterTypeNWC.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nwc_with_opts(
        FfiConverterTypeNostrWalletConnectURI_lower(uri),
        FfiConverterTypeNostrWalletConnectOptions.lower(opts),$0
    )
})
}
    

    
    /**
     * Get balance
     */
open func getBalance()async throws  -> UInt64 {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_get_balance(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get info
     */
open func getInfo()async throws  -> GetInfoResponseResult {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_get_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetInfoResponseResult_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * List transactions
     */
open func listTransactions(params: ListTransactionsRequestParams)async throws  -> [LookupInvoiceResponseResult] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_list_transactions(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListTransactionsRequestParams_lower(params)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeLookupInvoiceResponseResult.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Lookup invoice
     */
open func lookupInvoice(params: LookupInvoiceRequestParams)async throws  -> LookupInvoiceResponseResult {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_lookup_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLookupInvoiceRequestParams_lower(params)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLookupInvoiceResponseResult_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Create invoice
     */
open func makeInvoice(params: MakeInvoiceRequestParams)async throws  -> MakeInvoiceResponseResult {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_make_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMakeInvoiceRequestParams_lower(params)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMakeInvoiceResponseResult_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Pay invoice
     */
open func payInvoice(invoice: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_pay_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(invoice)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Pay keysend
     */
open func payKeysend(params: PayKeysendRequestParams)async throws  -> PayKeysendResponseResult {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_pay_keysend(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayKeysendRequestParams_lower(params)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayKeysendResponseResult_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

}

public struct FfiConverterTypeNWC: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nwc

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nwc {
        return Nwc(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nwc) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nwc {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nwc, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNWC_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nwc {
    return try FfiConverterTypeNWC.lift(pointer)
}

public func FfiConverterTypeNWC_lower(_ value: Nwc) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNWC.lower(value)
}




public protocol NegentropyOptionsProtocol : AnyObject {
    
    /**
     * Negentropy Sync direction (default: down)
     */
    func direction(direction: NegentropyDirection)  -> NegentropyOptions
    
    /**
     * Dry run
     *
     * Just check what event are missing: execute reconciliation but WITHOUT
     * getting/sending full events.
     */
    func dryRun()  -> NegentropyOptions
    
    /**
     * Timeout to check if negentropy it's supported (default: 10 secs)
     */
    func initialTimeout(timeout: TimeInterval)  -> NegentropyOptions
    
}

open class NegentropyOptions:
    NegentropyOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_negentropyoptions(self.pointer, $0) }
    }
    /**
     * New default options
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_negentropyoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_negentropyoptions(pointer, $0) }
    }

    

    
    /**
     * Negentropy Sync direction (default: down)
     */
open func direction(direction: NegentropyDirection) -> NegentropyOptions {
    return try!  FfiConverterTypeNegentropyOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_negentropyoptions_direction(self.uniffiClonePointer(),
        FfiConverterTypeNegentropyDirection.lower(direction),$0
    )
})
}
    
    /**
     * Dry run
     *
     * Just check what event are missing: execute reconciliation but WITHOUT
     * getting/sending full events.
     */
open func dryRun() -> NegentropyOptions {
    return try!  FfiConverterTypeNegentropyOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_negentropyoptions_dry_run(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Timeout to check if negentropy it's supported (default: 10 secs)
     */
open func initialTimeout(timeout: TimeInterval) -> NegentropyOptions {
    return try!  FfiConverterTypeNegentropyOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_negentropyoptions_initial_timeout(self.uniffiClonePointer(),
        FfiConverterDuration.lower(timeout),$0
    )
})
}
    

}

public struct FfiConverterTypeNegentropyOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NegentropyOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NegentropyOptions {
        return NegentropyOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NegentropyOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NegentropyOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NegentropyOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNegentropyOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> NegentropyOptions {
    return try FfiConverterTypeNegentropyOptions.lift(pointer)
}

public func FfiConverterTypeNegentropyOptions_lower(_ value: NegentropyOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNegentropyOptions.lower(value)
}




public protocol Nip46SignerProtocol : AnyObject {
    
    /**
     * Get `bunker` URI
     */
    func bunkerUri() async  -> NostrConnectUri
    
    /**
     * Get signer relays
     */
    func relays() async  -> [String]
    
    /**
     * Get signer public key
     */
    func signerPublicKey()  -> PublicKey
    
}

open class Nip46Signer:
    Nip46SignerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nip46signer(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nip46signer(pointer, $0) }
    }

    
    /**
     * Construct Nostr Connect client
     */
public static func `init`(uri: NostrConnectUri, appKeys: Keys, timeout: TimeInterval, opts: RelayOptions?)async throws  -> Nip46Signer {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_constructor_nip46signer_init(FfiConverterTypeNostrConnectURI_lower(uri),FfiConverterTypeKeys_lower(appKeys),FfiConverterDuration.lower(timeout),FfiConverterOptionTypeRelayOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNip46Signer.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

    
    /**
     * Get `bunker` URI
     */
open func bunkerUri()async  -> NostrConnectUri {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nip46signer_bunker_uri(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNostrConnectURI_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get signer relays
     */
open func relays()async  -> [String] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nip46signer_relays(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get signer public key
     */
open func signerPublicKey() -> PublicKey {
    return try!  FfiConverterTypePublicKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip46signer_signer_public_key(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeNip46Signer: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip46Signer

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip46Signer {
        return Nip46Signer(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip46Signer) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip46Signer {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip46Signer, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNip46Signer_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip46Signer {
    return try FfiConverterTypeNip46Signer.lift(pointer)
}

public func FfiConverterTypeNip46Signer_lower(_ value: Nip46Signer) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip46Signer.lower(value)
}




/**
 * Nostr Connect Signer
 *
 * Signer that listen for requests from client, handle them and send the response.
 *
 * <https://github.com/nostr-protocol/nips/blob/master/46.md>
 */
public protocol NostrConnectRemoteSignerProtocol : AnyObject {
    
    /**
     * Get `bunker` URI
     */
    func bunkerUri() async  -> NostrConnectUri
    
    /**
     * Get signer relays
     */
    func relays() async  -> [String]
    
    /**
     * Serve signer
     */
    func serve(actions: NostrConnectSignerActions) async throws 
    
}

/**
 * Nostr Connect Signer
 *
 * Signer that listen for requests from client, handle them and send the response.
 *
 * <https://github.com/nostr-protocol/nips/blob/master/46.md>
 */
open class NostrConnectRemoteSigner:
    NostrConnectRemoteSignerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrconnectremotesigner(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrconnectremotesigner(pointer, $0) }
    }

    
    /**
     * Construct remote signer from client URI (`nostrconnect://..`)
     */
public static func fromUri(uri: NostrConnectUri, secretKey: SecretKey, secret: String? = nil, opts: RelayOptions? = nil)async throws  -> NostrConnectRemoteSigner {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_constructor_nostrconnectremotesigner_from_uri(FfiConverterTypeNostrConnectURI_lower(uri),FfiConverterTypeSecretKey_lower(secretKey),FfiConverterOptionString.lower(secret),FfiConverterOptionTypeRelayOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNostrConnectRemoteSigner.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
public static func `init`(secretKey: SecretKey, relays: [String], secret: String? = nil, opts: RelayOptions? = nil)async throws  -> NostrConnectRemoteSigner {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_constructor_nostrconnectremotesigner_init(FfiConverterTypeSecretKey_lower(secretKey),FfiConverterSequenceString.lower(relays),FfiConverterOptionString.lower(secret),FfiConverterOptionTypeRelayOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNostrConnectRemoteSigner.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

    
    /**
     * Get `bunker` URI
     */
open func bunkerUri()async  -> NostrConnectUri {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrconnectremotesigner_bunker_uri(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNostrConnectURI_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get signer relays
     */
open func relays()async  -> [String] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrconnectremotesigner_relays(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Serve signer
     */
open func serve(actions: NostrConnectSignerActions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrconnectremotesigner_serve(
                    self.uniffiClonePointer(),
                    FfiConverterTypeNostrConnectSignerActions.lower(actions)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

}

public struct FfiConverterTypeNostrConnectRemoteSigner: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrConnectRemoteSigner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectRemoteSigner {
        return NostrConnectRemoteSigner(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrConnectRemoteSigner) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectRemoteSigner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrConnectRemoteSigner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrConnectRemoteSigner_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectRemoteSigner {
    return try FfiConverterTypeNostrConnectRemoteSigner.lift(pointer)
}

public func FfiConverterTypeNostrConnectRemoteSigner_lower(_ value: NostrConnectRemoteSigner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrConnectRemoteSigner.lower(value)
}




public protocol NostrConnectSignerActions : AnyObject {
    
    /**
     * Approve
     */
    func approve(req: Nip46Request)  -> Bool
    
}

open class NostrConnectSignerActionsImpl:
    NostrConnectSignerActions {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrconnectsigneractions(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrconnectsigneractions(pointer, $0) }
    }

    

    
    /**
     * Approve
     */
open func approve(req: Nip46Request) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrconnectsigneractions_approve(self.uniffiClonePointer(),
        FfiConverterTypeNip46Request_lower(req),$0
    )
})
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceNostrConnectSignerActions {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceNostrConnectSignerActions = UniffiVTableCallbackInterfaceNostrConnectSignerActions(
        approve: { (
            uniffiHandle: UInt64,
            req: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterTypeNostrConnectSignerActions.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.approve(
                     req: try FfiConverterTypeNip46Request_lift(req)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeNostrConnectSignerActions.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface NostrConnectSignerActions: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitNostrConnectSignerActions() {
    uniffi_nostr_sdk_ffi_fn_init_callback_vtable_nostrconnectsigneractions(&UniffiCallbackInterfaceNostrConnectSignerActions.vtable)
}

public struct FfiConverterTypeNostrConnectSignerActions: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<NostrConnectSignerActions>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrConnectSignerActions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectSignerActions {
        return NostrConnectSignerActionsImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrConnectSignerActions) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectSignerActions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrConnectSignerActions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrConnectSignerActions_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectSignerActions {
    return try FfiConverterTypeNostrConnectSignerActions.lift(pointer)
}

public func FfiConverterTypeNostrConnectSignerActions_lower(_ value: NostrConnectSignerActions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrConnectSignerActions.lower(value)
}




public protocol NostrDatabaseProtocol : AnyObject {
    
    func count(filters: [Filter]) async throws  -> UInt64
    
    /**
     * Delete all events that match the `Filter`
     */
    func delete(filter: Filter) async throws 
    
    /**
     * Get [`Event`] by [`EventId`]
     */
    func eventById(eventId: EventId) async throws  -> Event?
    
    /**
     * Get list of relays that have seen the [`EventId`]
     */
    func eventSeenOnRelays(eventId: EventId) async throws  -> [String]?
    
    func profile(publicKey: PublicKey) async throws  -> Profile
    
    func query(filters: [Filter]) async throws  -> [Event]
    
    /**
     * Save [`Event`] into store
     *
     * Return `true` if event was successfully saved into database.
     */
    func saveEvent(event: Event) async throws  -> Bool
    
    /**
     * Wipe all data
     */
    func wipe() async throws 
    
}

open class NostrDatabase:
    NostrDatabaseProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrdatabase(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrdatabase(pointer, $0) }
    }

    
public static func custom(database: CustomNostrDatabase) -> NostrDatabase {
    return try!  FfiConverterTypeNostrDatabase.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_custom(
        FfiConverterTypeCustomNostrDatabase.lower(database),$0
    )
})
}
    
    /**
     * LMDB backend
     */
public static func lmdb(path: String)throws  -> NostrDatabase {
    return try  FfiConverterTypeNostrDatabase.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_lmdb(
        FfiConverterString.lower(path),$0
    )
})
}
    

    
open func count(filters: [Filter])async throws  -> UInt64 {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_count(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Delete all events that match the `Filter`
     */
open func delete(filter: Filter)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_delete(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get [`Event`] by [`EventId`]
     */
open func eventById(eventId: EventId)async throws  -> Event? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_event_by_id(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get list of relays that have seen the [`EventId`]
     */
open func eventSeenOnRelays(eventId: EventId)async throws  -> [String]? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_event_seen_on_relays(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func profile(publicKey: PublicKey)async throws  -> Profile {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_profile(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeProfile.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func query(filters: [Filter])async throws  -> [Event] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_query(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Save [`Event`] into store
     *
     * Return `true` if event was successfully saved into database.
     */
open func saveEvent(event: Event)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_save_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Wipe all data
     */
open func wipe()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_wipe(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

}

public struct FfiConverterTypeNostrDatabase: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrDatabase

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrDatabase {
        return NostrDatabase(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrDatabase) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrDatabase {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrDatabase, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrDatabase_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrDatabase {
    return try FfiConverterTypeNostrDatabase.lift(pointer)
}

public func FfiConverterTypeNostrDatabase_lower(_ value: NostrDatabase) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrDatabase.lower(value)
}




public protocol NostrSignerProtocol : AnyObject {
    
    func nip04Decrypt(publicKey: PublicKey, encryptedContent: String) async throws  -> String
    
    func nip04Encrypt(publicKey: PublicKey, content: String) async throws  -> String
    
    func nip44Decrypt(publicKey: PublicKey, content: String) async throws  -> String
    
    func nip44Encrypt(publicKey: PublicKey, content: String) async throws  -> String
    
    /**
     * Get signer public key
     */
    func publicKey() async throws  -> PublicKey
    
    func signEvent(unsignedEvent: UnsignedEvent) async throws  -> Event
    
    func signEventBuilder(builder: EventBuilder) async throws  -> Event
    
    /**
     * Unwrap Gift Wrap event
     *
     * Internally verify the `seal` event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
    func unwrapGiftWrap(giftWrap: Event) async throws  -> UnwrappedGift
    
}

open class NostrSigner:
    NostrSignerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrsigner(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrsigner(pointer, $0) }
    }

    
public static func keys(keys: Keys) -> NostrSigner {
    return try!  FfiConverterTypeNostrSigner.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_keys(
        FfiConverterTypeKeys_lower(keys),$0
    )
})
}
    
public static func nip46(nip46: Nip46Signer) -> NostrSigner {
    return try!  FfiConverterTypeNostrSigner.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_nip46(
        FfiConverterTypeNip46Signer.lower(nip46),$0
    )
})
}
    

    
open func nip04Decrypt(publicKey: PublicKey, encryptedContent: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_decrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(encryptedContent)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func nip04Encrypt(publicKey: PublicKey, content: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_encrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func nip44Decrypt(publicKey: PublicKey, content: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_decrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func nip44Encrypt(publicKey: PublicKey, content: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_encrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get signer public key
     */
open func publicKey()async throws  -> PublicKey {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_public_key(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypePublicKey_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func signEvent(unsignedEvent: UnsignedEvent)async throws  -> Event {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_sign_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUnsignedEvent_lower(unsignedEvent)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvent_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func signEventBuilder(builder: EventBuilder)async throws  -> Event {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_sign_event_builder(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventBuilder_lower(builder)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvent_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Unwrap Gift Wrap event
     *
     * Internally verify the `seal` event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
open func unwrapGiftWrap(giftWrap: Event)async throws  -> UnwrappedGift {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_unwrap_gift_wrap(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(giftWrap)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeUnwrappedGift_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    

}

public struct FfiConverterTypeNostrSigner: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrSigner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrSigner {
        return NostrSigner(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrSigner) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrSigner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrSigner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrSigner_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrSigner {
    return try FfiConverterTypeNostrSigner.lift(pointer)
}

public func FfiConverterTypeNostrSigner_lower(_ value: NostrSigner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrSigner.lower(value)
}




/**
 * NWC options
 */
public protocol NostrWalletConnectOptionsProtocol : AnyObject {
    
    /**
     * Set connection mode
     */
    func connectionMode(mode: ConnectionMode) throws  -> NostrWalletConnectOptions
    
    /**
     * Set NWC requests timeout (default: 10 secs)
     */
    func timeout(timeout: TimeInterval)  -> NostrWalletConnectOptions
    
}

/**
 * NWC options
 */
open class NostrWalletConnectOptions:
    NostrWalletConnectOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrwalletconnectoptions(self.pointer, $0) }
    }
    /**
     * New default NWC options
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnectoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrwalletconnectoptions(pointer, $0) }
    }

    

    
    /**
     * Set connection mode
     */
open func connectionMode(mode: ConnectionMode)throws  -> NostrWalletConnectOptions {
    return try  FfiConverterTypeNostrWalletConnectOptions.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_connection_mode(self.uniffiClonePointer(),
        FfiConverterTypeConnectionMode.lower(mode),$0
    )
})
}
    
    /**
     * Set NWC requests timeout (default: 10 secs)
     */
open func timeout(timeout: TimeInterval) -> NostrWalletConnectOptions {
    return try!  FfiConverterTypeNostrWalletConnectOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_timeout(self.uniffiClonePointer(),
        FfiConverterDuration.lower(timeout),$0
    )
})
}
    

}

public struct FfiConverterTypeNostrWalletConnectOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrWalletConnectOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrWalletConnectOptions {
        return NostrWalletConnectOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrWalletConnectOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrWalletConnectOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrWalletConnectOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrWalletConnectOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrWalletConnectOptions {
    return try FfiConverterTypeNostrWalletConnectOptions.lift(pointer)
}

public func FfiConverterTypeNostrWalletConnectOptions_lower(_ value: NostrWalletConnectOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrWalletConnectOptions.lower(value)
}




/**
 * Nostr Zapper
 */
public protocol NostrZapperProtocol : AnyObject {
    
}

/**
 * Nostr Zapper
 */
open class NostrZapper:
    NostrZapperProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrzapper(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrzapper(pointer, $0) }
    }

    
public static func nwc(client: Nwc) -> NostrZapper {
    return try!  FfiConverterTypeNostrZapper.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrzapper_nwc(
        FfiConverterTypeNWC.lower(client),$0
    )
})
}
    

    

}

public struct FfiConverterTypeNostrZapper: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrZapper

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrZapper {
        return NostrZapper(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrZapper) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrZapper {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrZapper, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrZapper_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrZapper {
    return try FfiConverterTypeNostrZapper.lift(pointer)
}

public func FfiConverterTypeNostrZapper_lower(_ value: NostrZapper) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrZapper.lower(value)
}




public protocol OptionsProtocol : AnyObject {
    
    /**
     * Automatically start connection with relays (default: false)
     *
     * When set to `true`, there isn't the need of calling the connect methods.
     */
    func autoconnect(val: Bool)  -> Options
    
    /**
     * Auto authenticate to relays (default: true)
     *
     * <https://github.com/nostr-protocol/nips/blob/master/42.md>
     */
    func automaticAuthentication(enabled: Bool)  -> Options
    
    /**
     * Connection
     */
    func connection(connection: Connection)  -> Options
    
    /**
     * Connection timeout (default: None)
     *
     * If set to `None`, the client will try to connect to the relays without waiting.
     */
    func connectionTimeout(timeout: TimeInterval?)  -> Options
    
    func difficulty(difficulty: UInt8)  -> Options
    
    /**
     * Set filtering mode (default: blacklist)
     */
    func filteringMode(mode: RelayFilteringMode)  -> Options
    
    /**
     * Enable gossip model (default: false)
     */
    func gossip(enabled: Bool)  -> Options
    
    /**
     * Set max latency (default: None)
     *
     * Relays with an avg. latency greater that this value will be skipped.
     */
    func maxAvgLatency(max: TimeInterval)  -> Options
    
    /**
     * Minimum POW difficulty for received events
     */
    func minPow(difficulty: UInt8)  -> Options
    
    /**
     * Set custom relay limits
     */
    func relayLimits(limits: RelayLimits)  -> Options
    
    func reqFiltersChunkSize(reqFiltersChunkSize: UInt8)  -> Options
    
    func sendTimeout(sendTimeout: TimeInterval?)  -> Options
    
    func skipDisconnectedRelays(skip: Bool)  -> Options
    
    func timeout(timeout: TimeInterval)  -> Options
    
    func waitForSend(wait: Bool)  -> Options
    
    func waitForSubscription(wait: Bool)  -> Options
    
}

open class Options:
    OptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_options(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_options_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_options(pointer, $0) }
    }

    

    
    /**
     * Automatically start connection with relays (default: false)
     *
     * When set to `true`, there isn't the need of calling the connect methods.
     */
open func autoconnect(val: Bool) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_autoconnect(self.uniffiClonePointer(),
        FfiConverterBool.lower(val),$0
    )
})
}
    
    /**
     * Auto authenticate to relays (default: true)
     *
     * <https://github.com/nostr-protocol/nips/blob/master/42.md>
     */
open func automaticAuthentication(enabled: Bool) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_automatic_authentication(self.uniffiClonePointer(),
        FfiConverterBool.lower(enabled),$0
    )
})
}
    
    /**
     * Connection
     */
open func connection(connection: Connection) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_connection(self.uniffiClonePointer(),
        FfiConverterTypeConnection.lower(connection),$0
    )
})
}
    
    /**
     * Connection timeout (default: None)
     *
     * If set to `None`, the client will try to connect to the relays without waiting.
     */
open func connectionTimeout(timeout: TimeInterval?) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_connection_timeout(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    
open func difficulty(difficulty: UInt8) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_difficulty(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
})
}
    
    /**
     * Set filtering mode (default: blacklist)
     */
open func filteringMode(mode: RelayFilteringMode) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_filtering_mode(self.uniffiClonePointer(),
        FfiConverterTypeRelayFilteringMode.lower(mode),$0
    )
})
}
    
    /**
     * Enable gossip model (default: false)
     */
open func gossip(enabled: Bool) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_gossip(self.uniffiClonePointer(),
        FfiConverterBool.lower(enabled),$0
    )
})
}
    
    /**
     * Set max latency (default: None)
     *
     * Relays with an avg. latency greater that this value will be skipped.
     */
open func maxAvgLatency(max: TimeInterval) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_max_avg_latency(self.uniffiClonePointer(),
        FfiConverterDuration.lower(max),$0
    )
})
}
    
    /**
     * Minimum POW difficulty for received events
     */
open func minPow(difficulty: UInt8) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_min_pow(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
})
}
    
    /**
     * Set custom relay limits
     */
open func relayLimits(limits: RelayLimits) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_relay_limits(self.uniffiClonePointer(),
        FfiConverterTypeRelayLimits.lower(limits),$0
    )
})
}
    
open func reqFiltersChunkSize(reqFiltersChunkSize: UInt8) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_req_filters_chunk_size(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(reqFiltersChunkSize),$0
    )
})
}
    
open func sendTimeout(sendTimeout: TimeInterval?) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_send_timeout(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(sendTimeout),$0
    )
})
}
    
open func skipDisconnectedRelays(skip: Bool) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_skip_disconnected_relays(self.uniffiClonePointer(),
        FfiConverterBool.lower(skip),$0
    )
})
}
    
open func timeout(timeout: TimeInterval) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_timeout(self.uniffiClonePointer(),
        FfiConverterDuration.lower(timeout),$0
    )
})
}
    
open func waitForSend(wait: Bool) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_wait_for_send(self.uniffiClonePointer(),
        FfiConverterBool.lower(wait),$0
    )
})
}
    
open func waitForSubscription(wait: Bool) -> Options {
    return try!  FfiConverterTypeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_options_wait_for_subscription(self.uniffiClonePointer(),
        FfiConverterBool.lower(wait),$0
    )
})
}
    

}

public struct FfiConverterTypeOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Options

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Options {
        return Options(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Options) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Options {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Options, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> Options {
    return try FfiConverterTypeOptions.lift(pointer)
}

public func FfiConverterTypeOptions_lower(_ value: Options) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOptions.lower(value)
}




public protocol ProfileProtocol : AnyObject {
    
    /**
     * Get profile metadata
     */
    func metadata()  -> Metadata
    
    /**
     * Get profile name
     *
     * Steps (go to next step if field is `None` or `empty`):
     * * Check `display_name` field
     * * Check `name` field
     * * Return cutted public key (ex. `00000000:00000002`)
     */
    func name()  -> String
    
    /**
     * Get profile public key
     */
    func publicKey()  -> PublicKey
    
}

open class Profile:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    ProfileProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_profile(self.pointer, $0) }
    }
    /**
     * Compose new profile
     */
public convenience init(publicKey: PublicKey, metadata: Metadata) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_profile_new(
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterTypeMetadata_lower(metadata),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_profile(pointer, $0) }
    }

    

    
    /**
     * Get profile metadata
     */
open func metadata() -> Metadata {
    return try!  FfiConverterTypeMetadata_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_metadata(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get profile name
     *
     * Steps (go to next step if field is `None` or `empty`):
     * * Check `display_name` field
     * * Check `name` field
     * * Return cutted public key (ex. `00000000:00000002`)
     */
open func name() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_name(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get profile public key
     */
open func publicKey() -> PublicKey {
    return try!  FfiConverterTypePublicKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Profile, other: Profile) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeProfile.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_profile_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeProfile: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Profile

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Profile {
        return Profile(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Profile) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Profile {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Profile, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeProfile_lift(_ pointer: UnsafeMutableRawPointer) throws -> Profile {
    return try FfiConverterTypeProfile.lift(pointer)
}

public func FfiConverterTypeProfile_lower(_ value: Profile) -> UnsafeMutableRawPointer {
    return FfiConverterTypeProfile.lower(value)
}




public protocol RelayProtocol : AnyObject {
    
    /**
     * Send multiple `Event` at once
     */
    func batchEvent(events: [Event], opts: RelaySendOptions) async throws 
    
    /**
     * Send multiple `ClientMessage` at once
     */
    func batchMsg(msgs: [ClientMessage], opts: RelaySendOptions) async throws 
    
    /**
     * Connect to relay and keep alive connection
     */
    func connect(connectionTimeout: TimeInterval?) async 
    
    /**
     * Get connection mode
     */
    func connectionMode()  -> ConnectionMode
    
    /**
     * Count events of filters
     */
    func countEventsOf(filters: [Filter], timeout: TimeInterval) async throws  -> UInt64
    
    /**
     * Disconnect from relay and set status to 'Terminated'
     */
    func disconnect() async throws 
    
    func document() async  -> RelayInformationDocument
    
    /**
     * Get relay filtering
     */
    func filtering()  -> RelayFiltering
    
    /**
     * Get events of filters
     */
    func getEventsOf(filters: [Filter], timeout: TimeInterval) async throws  -> [Event]
    
    /**
     * Check if `Relay` is connected
     */
    func isConnected() async  -> Bool
    
    func opts()  -> RelayOptions
    
    /**
     * Get number of messages in queue
     */
    func queue()  -> UInt64
    
    /**
     * Negentropy reconciliation
     *
     * Use events stored in database
     */
    func reconcile(filter: Filter, opts: NegentropyOptions) async throws  -> Reconciliation
    
    /**
     * Negentropy reconciliation with custom items
     */
    func reconcileWithItems(filter: Filter, items: [NegentropyItem], opts: NegentropyOptions) async throws  -> Reconciliation
    
    /**
     * Send event and wait for `OK` relay msg
     */
    func sendEvent(event: Event, opts: RelaySendOptions) async throws  -> EventId
    
    /**
     * Send msg to relay
     */
    func sendMsg(msg: ClientMessage, opts: RelaySendOptions) async throws 
    
    func stats()  -> RelayConnectionStats
    
    /**
     * Get relay status
     */
    func status() async  -> RelayStatus
    
    /**
     * Subscribe to filters
     *
     * Internally generate a new random subscription ID. Check `subscribe_with_id` method to use a custom subscription ID.
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
    func subscribe(filters: [Filter], opts: SubscribeOptions) async throws  -> String
    
    /**
     * Subscribe with custom subscription ID
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
    func subscribeWithId(id: String, filters: [Filter], opts: SubscribeOptions) async throws 
    
    /**
     * Get filters by subscription ID
     */
    func subscription(id: String) async  -> [Filter]?
    
    func subscriptions() async  -> [String: [Filter]]
    
    /**
     * Check if relay support negentropy protocol
     */
    func supportNegentropy() async throws  -> Bool
    
    /**
     * Unsubscribe
     */
    func unsubscribe(id: String, opts: RelaySendOptions) async throws 
    
    /**
     * Unsubscribe from all subscriptions
     */
    func unsubscribeAll(opts: RelaySendOptions) async throws 
    
    /**
     * Get relay url
     */
    func url()  -> String
    
}

open class Relay:
    RelayProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relay(self.pointer, $0) }
    }
    /**
     * Create new `Relay` with **default** `options` and `in-memory database`
     */
public convenience init(url: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_relay_new(
        FfiConverterString.lower(url),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relay(pointer, $0) }
    }

    
    /**
     * Create new `Relay` with **custom** `database` and/or `options`
     */
public static func custom(url: String, database: NostrDatabase, opts: RelayOptions)throws  -> Relay {
    return try  FfiConverterTypeRelay.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_relay_custom(
        FfiConverterString.lower(url),
        FfiConverterTypeNostrDatabase.lower(database),
        FfiConverterTypeRelayOptions.lower(opts),$0
    )
})
}
    
    /**
     * Create new `Relay` with default `in-memory database` and custom `options`
     */
public static func withOpts(url: String, opts: RelayOptions)throws  -> Relay {
    return try  FfiConverterTypeRelay.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_relay_with_opts(
        FfiConverterString.lower(url),
        FfiConverterTypeRelayOptions.lower(opts),$0
    )
})
}
    

    
    /**
     * Send multiple `Event` at once
     */
open func batchEvent(events: [Event], opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_batch_event(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeEvent.lower(events),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send multiple `ClientMessage` at once
     */
open func batchMsg(msgs: [ClientMessage], opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_batch_msg(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeClientMessage.lower(msgs),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Connect to relay and keep alive connection
     */
open func connect(connectionTimeout: TimeInterval?)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_connect(
                    self.uniffiClonePointer(),
                    FfiConverterOptionDuration.lower(connectionTimeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Get connection mode
     */
open func connectionMode() -> ConnectionMode {
    return try!  FfiConverterTypeConnectionMode.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_connection_mode(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Count events of filters
     */
open func countEventsOf(filters: [Filter], timeout: TimeInterval)async throws  -> UInt64 {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_count_events_of(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Disconnect from relay and set status to 'Terminated'
     */
open func disconnect()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_disconnect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func document()async  -> RelayInformationDocument {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_document(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRelayInformationDocument_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get relay filtering
     */
open func filtering() -> RelayFiltering {
    return try!  FfiConverterTypeRelayFiltering.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_filtering(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get events of filters
     */
open func getEventsOf(filters: [Filter], timeout: TimeInterval)async throws  -> [Event] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_get_events_of(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Check if `Relay` is connected
     */
open func isConnected()async  -> Bool {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_is_connected(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
open func opts() -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_opts(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get number of messages in queue
     */
open func queue() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_queue(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Negentropy reconciliation
     *
     * Use events stored in database
     */
open func reconcile(filter: Filter, opts: NegentropyOptions)async throws  -> Reconciliation {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_reconcile(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterTypeNegentropyOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeReconciliation.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Negentropy reconciliation with custom items
     */
open func reconcileWithItems(filter: Filter, items: [NegentropyItem], opts: NegentropyOptions)async throws  -> Reconciliation {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_reconcile_with_items(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterSequenceTypeNegentropyItem.lower(items),FfiConverterTypeNegentropyOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeReconciliation.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send event and wait for `OK` relay msg
     */
open func sendEvent(event: Event, opts: RelaySendOptions)async throws  -> EventId {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_send_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send msg to relay
     */
open func sendMsg(msg: ClientMessage, opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_send_msg(
                    self.uniffiClonePointer(),
                    FfiConverterTypeClientMessage_lower(msg),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func stats() -> RelayConnectionStats {
    return try!  FfiConverterTypeRelayConnectionStats.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_stats(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get relay status
     */
open func status()async  -> RelayStatus {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_status(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRelayStatus.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Subscribe to filters
     *
     * Internally generate a new random subscription ID. Check `subscribe_with_id` method to use a custom subscription ID.
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
open func subscribe(filters: [Filter], opts: SubscribeOptions)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_subscribe(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters),FfiConverterTypeSubscribeOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Subscribe with custom subscription ID
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
open func subscribeWithId(id: String, filters: [Filter], opts: SubscribeOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_subscribe_with_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterTypeSubscribeOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get filters by subscription ID
     */
open func subscription(id: String)async  -> [Filter]? {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_subscription(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
open func subscriptions()async  -> [String: [Filter]] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_subscriptions(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Check if relay support negentropy protocol
     */
open func supportNegentropy()async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_support_negentropy(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Unsubscribe
     */
open func unsubscribe(id: String, opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Unsubscribe from all subscriptions
     */
open func unsubscribeAll(opts: RelaySendOptions)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe_all(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get relay url
     */
open func url() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_url(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeRelay: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Relay

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Relay {
        return Relay(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Relay) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Relay {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Relay, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelay_lift(_ pointer: UnsafeMutableRawPointer) throws -> Relay {
    return try FfiConverterTypeRelay.lift(pointer)
}

public func FfiConverterTypeRelay_lower(_ value: Relay) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelay.lower(value)
}




public protocol RelayConnectionStatsProtocol : AnyObject {
    
    /**
     * The number of times a connection has been attempted
     */
    func attempts()  -> UInt64
    
    /**
     * Bytes received
     */
    func bytesReceived()  -> UInt64
    
    /**
     * Bytes sent
     */
    func bytesSent()  -> UInt64
    
    /**
     * Get UNIX timestamp of the last connection
     */
    func connectedAt()  -> Timestamp
    
    /**
     * Get UNIX timestamp of the first connection
     */
    func firstConnectionTimestamp()  -> Timestamp
    
    func latency() async  -> TimeInterval?
    
    /**
     * The number of times a connection has been successfully established
     */
    func success()  -> UInt64
    
    /**
     * Uptime
     */
    func uptime()  -> Double
    
}

open class RelayConnectionStats:
    RelayConnectionStatsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relayconnectionstats(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relayconnectionstats(pointer, $0) }
    }

    

    
    /**
     * The number of times a connection has been attempted
     */
open func attempts() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_attempts(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Bytes received
     */
open func bytesReceived() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_received(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Bytes sent
     */
open func bytesSent() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_sent(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get UNIX timestamp of the last connection
     */
open func connectedAt() -> Timestamp {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_connected_at(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get UNIX timestamp of the first connection
     */
open func firstConnectionTimestamp() -> Timestamp {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_first_connection_timestamp(self.uniffiClonePointer(),$0
    )
})
}
    
open func latency()async  -> TimeInterval? {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_latency(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionDuration.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * The number of times a connection has been successfully established
     */
open func success() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_success(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Uptime
     */
open func uptime() -> Double {
    return try!  FfiConverterDouble.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_uptime(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeRelayConnectionStats: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayConnectionStats

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayConnectionStats {
        return RelayConnectionStats(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayConnectionStats) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayConnectionStats {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayConnectionStats, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayConnectionStats_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayConnectionStats {
    return try FfiConverterTypeRelayConnectionStats.lift(pointer)
}

public func FfiConverterTypeRelayConnectionStats_lower(_ value: RelayConnectionStats) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayConnectionStats.lower(value)
}




public protocol RelayFilteringProtocol : AnyObject {
    
    /**
     * Add event IDs
     *
     * Note: IDs are ignored in whitelist mode!
     */
    func addIds(ids: [EventId]) async 
    
    /**
     * Add public keys
     */
    func addPublicKeys(publicKeys: [PublicKey]) async 
    
    /**
     * Remove everything
     */
    func clear() async 
    
    /**
     * Check if has event ID
     */
    func hasId(id: EventId) async  -> Bool
    
    /**
     * Check if has public key
     */
    func hasPublicKey(publicKey: PublicKey) async  -> Bool
    
    /**
     * Get filtering mode
     */
    func mode()  -> RelayFilteringMode
    
    /**
     * Remove event ID
     *
     * Note: IDs are ignored in whitelist mode!
     */
    func removeId(id: EventId) async 
    
    /**
     * Remove event IDs
     *
     * Note: IDs are ignored in whitelist mode!
     */
    func removeIds(ids: [EventId]) async 
    
    /**
     * Remove public key
     */
    func removePublicKey(publicKey: PublicKey) async 
    
    /**
     * Remove public keys
     */
    func removePublicKeys(ids: [PublicKey]) async 
    
    /**
     * Update filtering mode
     */
    func updateMode(mode: RelayFilteringMode) 
    
}

open class RelayFiltering:
    RelayFilteringProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relayfiltering(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relayfiltering(pointer, $0) }
    }

    
    /**
     * Construct new filtering in blacklist mode
     */
public static func blacklist() -> RelayFiltering {
    return try!  FfiConverterTypeRelayFiltering.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relayfiltering_blacklist($0
    )
})
}
    
    /**
     * Construct new filtering in whitelist mode
     */
public static func whitelist() -> RelayFiltering {
    return try!  FfiConverterTypeRelayFiltering.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relayfiltering_whitelist($0
    )
})
}
    

    
    /**
     * Add event IDs
     *
     * Note: IDs are ignored in whitelist mode!
     */
open func addIds(ids: [EventId])async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayfiltering_add_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeEventId.lower(ids)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Add public keys
     */
open func addPublicKeys(publicKeys: [PublicKey])async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayfiltering_add_public_keys(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypePublicKey.lower(publicKeys)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Remove everything
     */
open func clear()async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayfiltering_clear(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Check if has event ID
     */
open func hasId(id: EventId)async  -> Bool {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayfiltering_has_id(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(id)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Check if has public key
     */
open func hasPublicKey(publicKey: PublicKey)async  -> Bool {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayfiltering_has_public_key(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get filtering mode
     */
open func mode() -> RelayFilteringMode {
    return try!  FfiConverterTypeRelayFilteringMode.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayfiltering_mode(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Remove event ID
     *
     * Note: IDs are ignored in whitelist mode!
     */
open func removeId(id: EventId)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayfiltering_remove_id(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(id)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Remove event IDs
     *
     * Note: IDs are ignored in whitelist mode!
     */
open func removeIds(ids: [EventId])async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayfiltering_remove_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeEventId.lower(ids)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Remove public key
     */
open func removePublicKey(publicKey: PublicKey)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayfiltering_remove_public_key(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Remove public keys
     */
open func removePublicKeys(ids: [PublicKey])async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relayfiltering_remove_public_keys(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypePublicKey.lower(ids)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Update filtering mode
     */
open func updateMode(mode: RelayFilteringMode) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayfiltering_update_mode(self.uniffiClonePointer(),
        FfiConverterTypeRelayFilteringMode.lower(mode),$0
    )
}
}
    

}

public struct FfiConverterTypeRelayFiltering: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayFiltering

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayFiltering {
        return RelayFiltering(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayFiltering) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayFiltering {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayFiltering, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayFiltering_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayFiltering {
    return try FfiConverterTypeRelayFiltering.lift(pointer)
}

public func FfiConverterTypeRelayFiltering_lower(_ value: RelayFiltering) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayFiltering.lower(value)
}




/**
 * Relay Limits
 */
public protocol RelayLimitsProtocol : AnyObject {
    
    /**
     * Maximum number of tags allowed (default: 2_000)
     */
    func eventMaxNumTags(maxNumTags: UInt16?)  -> RelayLimits
    
    /**
     * Maximum number of tags allowed per kind
     */
    func eventMaxNumTagsPerKind(kind: Kind, maxNumTags: UInt16?)  -> RelayLimits
    
    /**
     * Maximum size of normalised JSON, in bytes (default: 70_000)
     */
    func eventMaxSize(maxSize: UInt32?)  -> RelayLimits
    
    /**
     * Maximum size per kind of normalised JSON, in bytes.
     */
    func eventMaxSizePerKind(kind: Kind, maxSize: UInt32?)  -> RelayLimits
    
    /**
     * Maximum size of normalised JSON, in bytes (default: 5_250_000)
     */
    func messageMaxSize(maxSize: UInt32?)  -> RelayLimits
    
}

/**
 * Relay Limits
 */
open class RelayLimits:
    CustomDebugStringConvertible,
    Equatable,
    RelayLimitsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relaylimits(self.pointer, $0) }
    }
    /**
     * Construct with default limits
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relaylimits(pointer, $0) }
    }

    
    /**
     * Disable all limits
     */
public static func disable() -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_disable($0
    )
})
}
    

    
    /**
     * Maximum number of tags allowed (default: 2_000)
     */
open func eventMaxNumTags(maxNumTags: UInt16?) -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_num_tags(self.uniffiClonePointer(),
        FfiConverterOptionUInt16.lower(maxNumTags),$0
    )
})
}
    
    /**
     * Maximum number of tags allowed per kind
     */
open func eventMaxNumTagsPerKind(kind: Kind, maxNumTags: UInt16?) -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_num_tags_per_kind(self.uniffiClonePointer(),
        FfiConverterTypeKind_lower(kind),
        FfiConverterOptionUInt16.lower(maxNumTags),$0
    )
})
}
    
    /**
     * Maximum size of normalised JSON, in bytes (default: 70_000)
     */
open func eventMaxSize(maxSize: UInt32?) -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_size(self.uniffiClonePointer(),
        FfiConverterOptionUInt32.lower(maxSize),$0
    )
})
}
    
    /**
     * Maximum size per kind of normalised JSON, in bytes.
     */
open func eventMaxSizePerKind(kind: Kind, maxSize: UInt32?) -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_size_per_kind(self.uniffiClonePointer(),
        FfiConverterTypeKind_lower(kind),
        FfiConverterOptionUInt32.lower(maxSize),$0
    )
})
}
    
    /**
     * Maximum size of normalised JSON, in bytes (default: 5_250_000)
     */
open func messageMaxSize(maxSize: UInt32?) -> RelayLimits {
    return try!  FfiConverterTypeRelayLimits.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_message_max_size(self.uniffiClonePointer(),
        FfiConverterOptionUInt32.lower(maxSize),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: RelayLimits, other: RelayLimits) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeRelayLimits.lower(other),$0
    )
}
        )
    }

}

public struct FfiConverterTypeRelayLimits: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayLimits

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayLimits {
        return RelayLimits(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayLimits) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayLimits {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayLimits, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayLimits_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayLimits {
    return try FfiConverterTypeRelayLimits.lift(pointer)
}

public func FfiConverterTypeRelayLimits_lower(_ value: RelayLimits) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayLimits.lower(value)
}




/**
 * `Relay` options
 */
public protocol RelayOptionsProtocol : AnyObject {
    
    /**
     * Automatically adjust retry seconds based on success/attempts (default: true)
     */
    func adjustRetrySec(adjustRetrySec: Bool)  -> RelayOptions
    
    /**
     * Set connection mode
     */
    func connectionMode(mode: ConnectionMode) throws  -> RelayOptions
    
    /**
     * Set filtering mode (default: blacklist)
     */
    func filteringMode(mode: RelayFilteringMode)  -> RelayOptions
    
    /**
     * Set custom limits
     */
    func limits(limits: RelayLimits)  -> RelayOptions
    
    /**
     * Set max latency (default: None)
     *
     * Relay with an avg. latency greater that this value will be skipped.
     */
    func maxAvgLatency(max: TimeInterval?)  -> RelayOptions
    
    /**
     * Set ping flag
     */
    func ping(ping: Bool)  -> RelayOptions
    
    /**
     * Minimum POW for received events (default: 0)
     */
    func pow(difficulty: UInt8)  -> RelayOptions
    
    /**
     * Set read flag
     */
    func read(read: Bool)  -> RelayOptions
    
    /**
     * Enable/disable auto reconnection (default: true)
     */
    func reconnect(reconnect: Bool)  -> RelayOptions
    
    /**
     * Retry connection time (default: 10 sec)
     *
     * Are allowed values `>=` 5 secs
     */
    func retrySec(retrySec: UInt64)  -> RelayOptions
    
    /**
     * Set adjust_retry_sec option
     */
    func updateAdjustRetrySec(adjustRetrySec: Bool) 
    
    /**
     * Update `pow` option
     */
    func updatePowDifficulty(difficulty: UInt8) 
    
    /**
     * Update `reconnect` option
     */
    func updateReconnect(reconnect: Bool) 
    
    /**
     * Set retry_sec option
     */
    func updateRetrySec(retrySec: UInt64) 
    
    /**
     * Set write flag
     */
    func write(write: Bool)  -> RelayOptions
    
}

/**
 * `Relay` options
 */
open class RelayOptions:
    RelayOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relayoptions(self.pointer, $0) }
    }
    /**
     * New default relay options
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relayoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relayoptions(pointer, $0) }
    }

    

    
    /**
     * Automatically adjust retry seconds based on success/attempts (default: true)
     */
open func adjustRetrySec(adjustRetrySec: Bool) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_adjust_retry_sec(self.uniffiClonePointer(),
        FfiConverterBool.lower(adjustRetrySec),$0
    )
})
}
    
    /**
     * Set connection mode
     */
open func connectionMode(mode: ConnectionMode)throws  -> RelayOptions {
    return try  FfiConverterTypeRelayOptions.lift(try rustCallWithError(FfiConverterTypeNostrSdkError.lift) {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_connection_mode(self.uniffiClonePointer(),
        FfiConverterTypeConnectionMode.lower(mode),$0
    )
})
}
    
    /**
     * Set filtering mode (default: blacklist)
     */
open func filteringMode(mode: RelayFilteringMode) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_filtering_mode(self.uniffiClonePointer(),
        FfiConverterTypeRelayFilteringMode.lower(mode),$0
    )
})
}
    
    /**
     * Set custom limits
     */
open func limits(limits: RelayLimits) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_limits(self.uniffiClonePointer(),
        FfiConverterTypeRelayLimits.lower(limits),$0
    )
})
}
    
    /**
     * Set max latency (default: None)
     *
     * Relay with an avg. latency greater that this value will be skipped.
     */
open func maxAvgLatency(max: TimeInterval?) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_max_avg_latency(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(max),$0
    )
})
}
    
    /**
     * Set ping flag
     */
open func ping(ping: Bool) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_ping(self.uniffiClonePointer(),
        FfiConverterBool.lower(ping),$0
    )
})
}
    
    /**
     * Minimum POW for received events (default: 0)
     */
open func pow(difficulty: UInt8) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_pow(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
})
}
    
    /**
     * Set read flag
     */
open func read(read: Bool) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_read(self.uniffiClonePointer(),
        FfiConverterBool.lower(read),$0
    )
})
}
    
    /**
     * Enable/disable auto reconnection (default: true)
     */
open func reconnect(reconnect: Bool) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_reconnect(self.uniffiClonePointer(),
        FfiConverterBool.lower(reconnect),$0
    )
})
}
    
    /**
     * Retry connection time (default: 10 sec)
     *
     * Are allowed values `>=` 5 secs
     */
open func retrySec(retrySec: UInt64) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_retry_sec(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(retrySec),$0
    )
})
}
    
    /**
     * Set adjust_retry_sec option
     */
open func updateAdjustRetrySec(adjustRetrySec: Bool) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_update_adjust_retry_sec(self.uniffiClonePointer(),
        FfiConverterBool.lower(adjustRetrySec),$0
    )
}
}
    
    /**
     * Update `pow` option
     */
open func updatePowDifficulty(difficulty: UInt8) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_update_pow_difficulty(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
}
}
    
    /**
     * Update `reconnect` option
     */
open func updateReconnect(reconnect: Bool) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_update_reconnect(self.uniffiClonePointer(),
        FfiConverterBool.lower(reconnect),$0
    )
}
}
    
    /**
     * Set retry_sec option
     */
open func updateRetrySec(retrySec: UInt64) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_update_retry_sec(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(retrySec),$0
    )
}
}
    
    /**
     * Set write flag
     */
open func write(write: Bool) -> RelayOptions {
    return try!  FfiConverterTypeRelayOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_write(self.uniffiClonePointer(),
        FfiConverterBool.lower(write),$0
    )
})
}
    

}

public struct FfiConverterTypeRelayOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayOptions {
        return RelayOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayOptions {
    return try FfiConverterTypeRelayOptions.lift(pointer)
}

public func FfiConverterTypeRelayOptions_lower(_ value: RelayOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayOptions.lower(value)
}




public protocol RelayPoolProtocol : AnyObject {
    
    func addRelay(url: String, opts: RelayOptions) async throws  -> Bool
    
    /**
     * Send multiple events at once to all relays with `WRITE` flag
     */
    func batchEvent(events: [Event], opts: RelaySendOptions) async throws  -> Output
    
    /**
     * Send multiple events at once to specific relays
     */
    func batchEventTo(urls: [String], events: [Event], opts: RelaySendOptions) async throws  -> Output
    
    /**
     * Send multiple client messages at once to specific relays
     *
     * Note: **the relays must already be added!**
     */
    func batchMsgTo(urls: [String], msgs: [ClientMessage], opts: RelaySendOptions) async throws  -> Output
    
    /**
     * Connect to all added relays and keep connection alive
     */
    func connect(connectionTimeout: TimeInterval?) async 
    
    /**
     * Connect to relay
     */
    func connectRelay(url: String, connectionTimeout: TimeInterval?) async throws 
    
    /**
     * Get database
     */
    func database()  -> NostrDatabase
    
    /**
     * Disconnect from all relays
     */
    func disconnect() async throws 
    
    /**
     * Get relay filtering
     */
    func filtering()  -> RelayFiltering
    
    /**
     * Get events of filters from **specific relays**
     */
    func getEventsFrom(urls: [String], filters: [Filter], timeout: TimeInterval, opts: FilterOptions) async throws  -> [Event]
    
    /**
     * Get events of filters
     */
    func getEventsOf(filters: [Filter], timeout: TimeInterval, opts: FilterOptions) async throws  -> [Event]
    
    /**
     * Handle relay pool notifications
     */
    func handleNotifications(handler: HandleNotification) async throws 
    
    /**
     * Negentropy reconciliation
     *
     * Use events stored in database
     */
    func reconcile(filter: Filter, opts: NegentropyOptions) async throws  -> ReconciliationOutput
    
    /**
     * Negentropy reconciliation with custom items
     */
    func reconcileWithItems(filter: Filter, items: [NegentropyItem], opts: NegentropyOptions) async throws  -> ReconciliationOutput
    
    /**
     * Get relay
     */
    func relay(url: String) async throws  -> Relay
    
    /**
     * Get relays with `READ` or `WRITE` flags
     */
    func relays() async  -> [String: Relay]
    
    func removeAllRelay() async throws 
    
    func removeRelay(url: String) async throws 
    
    /**
     * Send event to all relays with `WRITE` flag
     */
    func sendEvent(event: Event, opts: RelaySendOptions) async throws  -> SendEventOutput
    
    /**
     * Send event to specific relays
     */
    func sendEventTo(urls: [String], event: Event, opts: RelaySendOptions) async throws  -> SendEventOutput
    
    /**
     * Send client message to specific relays
     *
     * Note: **the relays must already be added!**
     */
    func sendMsgTo(urls: [String], msg: ClientMessage, opts: RelaySendOptions) async throws  -> Output
    
    /**
     * Completely shutdown pool
     */
    func shutdown() async throws 
    
    /**
     * Subscribe to filters to relays with `READ` flag.
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
    func subscribe(filters: [Filter], opts: SubscribeOptions) async throws  -> SubscribeOutput
    
    /**
     * Subscribe to filters to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     */
    func subscribeTo(urls: [String], filters: [Filter], opts: SubscribeOptions) async throws  -> SubscribeOutput
    
    /**
     * Subscribe with custom subscription ID to relays with `READ` flag.
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
    func subscribeWithId(id: String, filters: [Filter], opts: SubscribeOptions) async throws  -> Output
    
    /**
     * Subscribe to filters with custom subscription ID to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     */
    func subscribeWithIdTo(urls: [String], id: String, filters: [Filter], opts: SubscribeOptions) async throws  -> Output
    
    /**
     * Get filters by subscription ID
     */
    func subscription(id: String) async  -> [Filter]?
    
    /**
     * Get subscriptions
     */
    func subscriptions() async  -> [String: [Filter]]
    
    /**
     * Unsubscribe
     */
    func unsubscribe(id: String, opts: RelaySendOptions) async 
    
    /**
     * Unsubscribe from all subscriptions
     */
    func unsubscribeAll(opts: RelaySendOptions) async 
    
}

open class RelayPool:
    RelayPoolProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relaypool(self.pointer, $0) }
    }
    /**
     * Create new `RelayPool` with `in-memory` database
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaypool_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relaypool(pointer, $0) }
    }

    
    /**
     * Create new `RelayPool` with `custom` database
     */
public static func withDatabase(database: NostrDatabase) -> RelayPool {
    return try!  FfiConverterTypeRelayPool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaypool_with_database(
        FfiConverterTypeNostrDatabase.lower(database),$0
    )
})
}
    

    
open func addRelay(url: String, opts: RelayOptions)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_add_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterTypeRelayOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send multiple events at once to all relays with `WRITE` flag
     */
open func batchEvent(events: [Event], opts: RelaySendOptions)async throws  -> Output {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_batch_event(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeEvent.lower(events),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send multiple events at once to specific relays
     */
open func batchEventTo(urls: [String], events: [Event], opts: RelaySendOptions)async throws  -> Output {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_batch_event_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterSequenceTypeEvent.lower(events),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send multiple client messages at once to specific relays
     *
     * Note: **the relays must already be added!**
     */
open func batchMsgTo(urls: [String], msgs: [ClientMessage], opts: RelaySendOptions)async throws  -> Output {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_batch_msg_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterSequenceTypeClientMessage.lower(msgs),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Connect to all added relays and keep connection alive
     */
open func connect(connectionTimeout: TimeInterval?)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_connect(
                    self.uniffiClonePointer(),
                    FfiConverterOptionDuration.lower(connectionTimeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Connect to relay
     */
open func connectRelay(url: String, connectionTimeout: TimeInterval?)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_connect_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterOptionDuration.lower(connectionTimeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get database
     */
open func database() -> NostrDatabase {
    return try!  FfiConverterTypeNostrDatabase.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_database(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Disconnect from all relays
     */
open func disconnect()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_disconnect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get relay filtering
     */
open func filtering() -> RelayFiltering {
    return try!  FfiConverterTypeRelayFiltering.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaypool_filtering(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get events of filters from **specific relays**
     */
open func getEventsFrom(urls: [String], filters: [Filter], timeout: TimeInterval, opts: FilterOptions)async throws  -> [Event] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_get_events_from(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterDuration.lower(timeout),FfiConverterTypeFilterOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get events of filters
     */
open func getEventsOf(filters: [Filter], timeout: TimeInterval, opts: FilterOptions)async throws  -> [Event] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_get_events_of(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters),FfiConverterDuration.lower(timeout),FfiConverterTypeFilterOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Handle relay pool notifications
     */
open func handleNotifications(handler: HandleNotification)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_handle_notifications(
                    self.uniffiClonePointer(),
                    FfiConverterTypeHandleNotification.lower(handler)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Negentropy reconciliation
     *
     * Use events stored in database
     */
open func reconcile(filter: Filter, opts: NegentropyOptions)async throws  -> ReconciliationOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_reconcile(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterTypeNegentropyOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeReconciliationOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Negentropy reconciliation with custom items
     */
open func reconcileWithItems(filter: Filter, items: [NegentropyItem], opts: NegentropyOptions)async throws  -> ReconciliationOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_reconcile_with_items(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterSequenceTypeNegentropyItem.lower(items),FfiConverterTypeNegentropyOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeReconciliationOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get relay
     */
open func relay(url: String)async throws  -> Relay {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRelay.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get relays with `READ` or `WRITE` flags
     */
open func relays()async  -> [String: Relay] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_relays(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringTypeRelay.lift,
            errorHandler: nil
            
        )
}
    
open func removeAllRelay()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_remove_all_relay(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
open func removeRelay(url: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_remove_relay(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send event to all relays with `WRITE` flag
     */
open func sendEvent(event: Event, opts: RelaySendOptions)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_send_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send event to specific relays
     */
open func sendEventTo(urls: [String], event: Event, opts: RelaySendOptions)async throws  -> SendEventOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_send_event_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterTypeEvent_lower(event),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Send client message to specific relays
     *
     * Note: **the relays must already be added!**
     */
open func sendMsgTo(urls: [String], msg: ClientMessage, opts: RelaySendOptions)async throws  -> Output {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_send_msg_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterTypeClientMessage_lower(msg),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Completely shutdown pool
     */
open func shutdown()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_shutdown(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Subscribe to filters to relays with `READ` flag.
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
open func subscribe(filters: [Filter], opts: SubscribeOptions)async throws  -> SubscribeOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_subscribe(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFilter.lower(filters),FfiConverterTypeSubscribeOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSubscribeOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Subscribe to filters to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     */
open func subscribeTo(urls: [String], filters: [Filter], opts: SubscribeOptions)async throws  -> SubscribeOutput {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_subscribe_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterTypeSubscribeOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSubscribeOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Subscribe with custom subscription ID to relays with `READ` flag.
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
open func subscribeWithId(id: String, filters: [Filter], opts: SubscribeOptions)async throws  -> Output {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_subscribe_with_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterTypeSubscribeOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Subscribe to filters with custom subscription ID to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     */
open func subscribeWithIdTo(urls: [String], id: String, filters: [Filter], opts: SubscribeOptions)async throws  -> Output {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_subscribe_with_id_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(urls),FfiConverterString.lower(id),FfiConverterSequenceTypeFilter.lower(filters),FfiConverterTypeSubscribeOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOutput.lift,
            errorHandler: FfiConverterTypeNostrSdkError.lift
        )
}
    
    /**
     * Get filters by subscription ID
     */
open func subscription(id: String)async  -> [Filter]? {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_subscription(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get subscriptions
     */
open func subscriptions()async  -> [String: [Filter]] {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_subscriptions(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Unsubscribe
     */
open func unsubscribe(id: String, opts: RelaySendOptions)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_unsubscribe(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id),FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Unsubscribe from all subscriptions
     */
open func unsubscribeAll(opts: RelaySendOptions)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relaypool_unsubscribe_all(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelaySendOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}

public struct FfiConverterTypeRelayPool: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayPool

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayPool {
        return RelayPool(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayPool) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayPool {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayPool, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayPool_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayPool {
    return try FfiConverterTypeRelayPool.lift(pointer)
}

public func FfiConverterTypeRelayPool_lower(_ value: RelayPool) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayPool.lower(value)
}




public protocol RelaySendOptionsProtocol : AnyObject {
    
    /**
     * Skip wait for disconnected relay (default: true)
     */
    func skipDisconnected(value: Bool)  -> RelaySendOptions
    
    /**
     * Skip wait for confirmation that message is sent (default: false)
     */
    func skipSendConfirmation(value: Bool)  -> RelaySendOptions
    
    /**
     * Timeout for sending event (default: 20 secs)
     *
     * If `None`, the default timeout will be used
     */
    func timeout(timeout: TimeInterval?)  -> RelaySendOptions
    
}

open class RelaySendOptions:
    RelaySendOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relaysendoptions(self.pointer, $0) }
    }
    /**
     * New default `RelaySendOptions`
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaysendoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relaysendoptions(pointer, $0) }
    }

    

    
    /**
     * Skip wait for disconnected relay (default: true)
     */
open func skipDisconnected(value: Bool) -> RelaySendOptions {
    return try!  FfiConverterTypeRelaySendOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaysendoptions_skip_disconnected(self.uniffiClonePointer(),
        FfiConverterBool.lower(value),$0
    )
})
}
    
    /**
     * Skip wait for confirmation that message is sent (default: false)
     */
open func skipSendConfirmation(value: Bool) -> RelaySendOptions {
    return try!  FfiConverterTypeRelaySendOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaysendoptions_skip_send_confirmation(self.uniffiClonePointer(),
        FfiConverterBool.lower(value),$0
    )
})
}
    
    /**
     * Timeout for sending event (default: 20 secs)
     *
     * If `None`, the default timeout will be used
     */
open func timeout(timeout: TimeInterval?) -> RelaySendOptions {
    return try!  FfiConverterTypeRelaySendOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaysendoptions_timeout(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    

}

public struct FfiConverterTypeRelaySendOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelaySendOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelaySendOptions {
        return RelaySendOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelaySendOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelaySendOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelaySendOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelaySendOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelaySendOptions {
    return try FfiConverterTypeRelaySendOptions.lift(pointer)
}

public func FfiConverterTypeRelaySendOptions_lower(_ value: RelaySendOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelaySendOptions.lower(value)
}




/**
 * Auto-closing subscribe options
 */
public protocol SubscribeAutoCloseOptionsProtocol : AnyObject {
    
    /**
     * Close subscription when `FilterOptions` is satisfied
     */
    func filter(filter: FilterOptions)  -> SubscribeAutoCloseOptions
    
    /**
     * Automatically close subscription after `Duration`
     */
    func timeout(timeout: TimeInterval?)  -> SubscribeAutoCloseOptions
    
}

/**
 * Auto-closing subscribe options
 */
open class SubscribeAutoCloseOptions:
    SubscribeAutoCloseOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_subscribeautocloseoptions(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_subscribeautocloseoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_subscribeautocloseoptions(pointer, $0) }
    }

    

    
    /**
     * Close subscription when `FilterOptions` is satisfied
     */
open func filter(filter: FilterOptions) -> SubscribeAutoCloseOptions {
    return try!  FfiConverterTypeSubscribeAutoCloseOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_filter(self.uniffiClonePointer(),
        FfiConverterTypeFilterOptions.lower(filter),$0
    )
})
}
    
    /**
     * Automatically close subscription after `Duration`
     */
open func timeout(timeout: TimeInterval?) -> SubscribeAutoCloseOptions {
    return try!  FfiConverterTypeSubscribeAutoCloseOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_timeout(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    

}

public struct FfiConverterTypeSubscribeAutoCloseOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SubscribeAutoCloseOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeAutoCloseOptions {
        return SubscribeAutoCloseOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SubscribeAutoCloseOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubscribeAutoCloseOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SubscribeAutoCloseOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSubscribeAutoCloseOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeAutoCloseOptions {
    return try FfiConverterTypeSubscribeAutoCloseOptions.lift(pointer)
}

public func FfiConverterTypeSubscribeAutoCloseOptions_lower(_ value: SubscribeAutoCloseOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSubscribeAutoCloseOptions.lower(value)
}




/**
 * Subscribe options
 */
public protocol SubscribeOptionsProtocol : AnyObject {
    
    /**
     * Set auto-close conditions
     */
    func closeOn(opts: SubscribeAutoCloseOptions?)  -> SubscribeOptions
    
    /**
     * Set [RelaySendOptions]
     */
    func sendOpts(opts: RelaySendOptions)  -> SubscribeOptions
    
}

/**
 * Subscribe options
 */
open class SubscribeOptions:
    SubscribeOptionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_subscribeoptions(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_subscribeoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_subscribeoptions(pointer, $0) }
    }

    

    
    /**
     * Set auto-close conditions
     */
open func closeOn(opts: SubscribeAutoCloseOptions?) -> SubscribeOptions {
    return try!  FfiConverterTypeSubscribeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeoptions_close_on(self.uniffiClonePointer(),
        FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts),$0
    )
})
}
    
    /**
     * Set [RelaySendOptions]
     */
open func sendOpts(opts: RelaySendOptions) -> SubscribeOptions {
    return try!  FfiConverterTypeSubscribeOptions.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeoptions_send_opts(self.uniffiClonePointer(),
        FfiConverterTypeRelaySendOptions.lower(opts),$0
    )
})
}
    

}

public struct FfiConverterTypeSubscribeOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SubscribeOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeOptions {
        return SubscribeOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SubscribeOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubscribeOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SubscribeOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSubscribeOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeOptions {
    return try FfiConverterTypeSubscribeOptions.lift(pointer)
}

public func FfiConverterTypeSubscribeOptions_lower(_ value: SubscribeOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSubscribeOptions.lower(value)
}




/**
 * Zap Details
 */
public protocol ZapDetailsProtocol : AnyObject {
    
    /**
     * Add message
     */
    func message(message: String)  -> ZapDetails
    
}

/**
 * Zap Details
 */
open class ZapDetails:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    ZapDetailsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_zapdetails(self.pointer, $0) }
    }
    /**
     * Create new Zap Details
     *
     * **Note: `private` zaps are not currently supported here!**
     */
public convenience init(zapType: ZapType) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_zapdetails_new(
        FfiConverterTypeZapType_lower(zapType),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_zapdetails(pointer, $0) }
    }

    

    
    /**
     * Add message
     */
open func message(message: String) -> ZapDetails {
    return try!  FfiConverterTypeZapDetails.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapdetails_message(self.uniffiClonePointer(),
        FfiConverterString.lower(message),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapdetails_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: ZapDetails, other: ZapDetails) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapdetails_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeZapDetails.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapdetails_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeZapDetails: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZapDetails

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapDetails {
        return ZapDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZapDetails) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZapDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZapDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeZapDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapDetails {
    return try FfiConverterTypeZapDetails.lift(pointer)
}

public func FfiConverterTypeZapDetails_lower(_ value: ZapDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZapDetails.lower(value)
}




/**
 * Zap entity
 */
public protocol ZapEntityProtocol : AnyObject {
    
}

/**
 * Zap entity
 */
open class ZapEntity:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    ZapEntityProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_zapentity(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_zapentity(pointer, $0) }
    }

    
public static func event(eventId: EventId) -> ZapEntity {
    return try!  FfiConverterTypeZapEntity.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_zapentity_event(
        FfiConverterTypeEventId_lower(eventId),$0
    )
})
}
    
public static func publicKey(publicKey: PublicKey) -> ZapEntity {
    return try!  FfiConverterTypeZapEntity.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_zapentity_public_key(
        FfiConverterTypePublicKey_lower(publicKey),$0
    )
})
}
    

    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapentity_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: ZapEntity, other: ZapEntity) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapentity_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeZapEntity.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zapentity_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeZapEntity: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZapEntity

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapEntity {
        return ZapEntity(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZapEntity) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZapEntity {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZapEntity, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeZapEntity_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapEntity {
    return try FfiConverterTypeZapEntity.lift(pointer)
}

public func FfiConverterTypeZapEntity_lower(_ value: ZapEntity) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZapEntity.lower(value)
}


public struct NegentropyItem {
    public var id: EventId
    public var timestamp: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: EventId, timestamp: Timestamp) {
        self.id = id
        self.timestamp = timestamp
    }
}



public struct FfiConverterTypeNegentropyItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NegentropyItem {
        return
            try NegentropyItem(
                id: FfiConverterTypeEventId.read(from: &buf), 
                timestamp: FfiConverterTypeTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: NegentropyItem, into buf: inout [UInt8]) {
        FfiConverterTypeEventId.write(value.id, into: &buf)
        FfiConverterTypeTimestamp.write(value.timestamp, into: &buf)
    }
}


public func FfiConverterTypeNegentropyItem_lift(_ buf: RustBuffer) throws -> NegentropyItem {
    return try FfiConverterTypeNegentropyItem.lift(buf)
}

public func FfiConverterTypeNegentropyItem_lower(_ value: NegentropyItem) -> RustBuffer {
    return FfiConverterTypeNegentropyItem.lower(value)
}


/**
 * Output
 *
 * Send or negentropy reconciliation output
 */
public struct Output {
    /**
     * Set of relays that success
     */
    public var success: [String]
    /**
     * Map of relays that failed, with related errors.
     */
    public var failed: [String: String?]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Set of relays that success
         */success: [String], 
        /**
         * Map of relays that failed, with related errors.
         */failed: [String: String?]) {
        self.success = success
        self.failed = failed
    }
}



extension Output: Equatable, Hashable {
    public static func ==(lhs: Output, rhs: Output) -> Bool {
        if lhs.success != rhs.success {
            return false
        }
        if lhs.failed != rhs.failed {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(success)
        hasher.combine(failed)
    }
}


public struct FfiConverterTypeOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Output {
        return
            try Output(
                success: FfiConverterSequenceString.read(from: &buf), 
                failed: FfiConverterDictionaryStringOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Output, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.success, into: &buf)
        FfiConverterDictionaryStringOptionString.write(value.failed, into: &buf)
    }
}


public func FfiConverterTypeOutput_lift(_ buf: RustBuffer) throws -> Output {
    return try FfiConverterTypeOutput.lift(buf)
}

public func FfiConverterTypeOutput_lower(_ value: Output) -> RustBuffer {
    return FfiConverterTypeOutput.lower(value)
}


/**
 * Reconciliation output
 */
public struct Reconciliation {
    /**
     * The IDs that were stored locally
     */
    public var local: [EventId]
    /**
     * The IDs that were missing locally (stored on relay)
     */
    public var remote: [EventId]
    /**
     * Events that are **successfully** sent to relays during reconciliation
     */
    public var sent: [EventId]
    /**
     * Event that are **successfully** received from relay
     */
    public var received: [EventId]
    public var sendFailures: [String: [ReconciliationSendFailureItem]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The IDs that were stored locally
         */local: [EventId], 
        /**
         * The IDs that were missing locally (stored on relay)
         */remote: [EventId], 
        /**
         * Events that are **successfully** sent to relays during reconciliation
         */sent: [EventId], 
        /**
         * Event that are **successfully** received from relay
         */received: [EventId], sendFailures: [String: [ReconciliationSendFailureItem]]) {
        self.local = local
        self.remote = remote
        self.sent = sent
        self.received = received
        self.sendFailures = sendFailures
    }
}



public struct FfiConverterTypeReconciliation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Reconciliation {
        return
            try Reconciliation(
                local: FfiConverterSequenceTypeEventId.read(from: &buf), 
                remote: FfiConverterSequenceTypeEventId.read(from: &buf), 
                sent: FfiConverterSequenceTypeEventId.read(from: &buf), 
                received: FfiConverterSequenceTypeEventId.read(from: &buf), 
                sendFailures: FfiConverterDictionaryStringSequenceTypeReconciliationSendFailureItem.read(from: &buf)
        )
    }

    public static func write(_ value: Reconciliation, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeEventId.write(value.local, into: &buf)
        FfiConverterSequenceTypeEventId.write(value.remote, into: &buf)
        FfiConverterSequenceTypeEventId.write(value.sent, into: &buf)
        FfiConverterSequenceTypeEventId.write(value.received, into: &buf)
        FfiConverterDictionaryStringSequenceTypeReconciliationSendFailureItem.write(value.sendFailures, into: &buf)
    }
}


public func FfiConverterTypeReconciliation_lift(_ buf: RustBuffer) throws -> Reconciliation {
    return try FfiConverterTypeReconciliation.lift(buf)
}

public func FfiConverterTypeReconciliation_lower(_ value: Reconciliation) -> RustBuffer {
    return FfiConverterTypeReconciliation.lower(value)
}


/**
 * Reconciliation output
 */
public struct ReconciliationOutput {
    public var report: Reconciliation
    public var output: Output

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(report: Reconciliation, output: Output) {
        self.report = report
        self.output = output
    }
}



public struct FfiConverterTypeReconciliationOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReconciliationOutput {
        return
            try ReconciliationOutput(
                report: FfiConverterTypeReconciliation.read(from: &buf), 
                output: FfiConverterTypeOutput.read(from: &buf)
        )
    }

    public static func write(_ value: ReconciliationOutput, into buf: inout [UInt8]) {
        FfiConverterTypeReconciliation.write(value.report, into: &buf)
        FfiConverterTypeOutput.write(value.output, into: &buf)
    }
}


public func FfiConverterTypeReconciliationOutput_lift(_ buf: RustBuffer) throws -> ReconciliationOutput {
    return try FfiConverterTypeReconciliationOutput.lift(buf)
}

public func FfiConverterTypeReconciliationOutput_lower(_ value: ReconciliationOutput) -> RustBuffer {
    return FfiConverterTypeReconciliationOutput.lower(value)
}


public struct ReconciliationSendFailureItem {
    public var id: EventId
    public var error: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: EventId, error: String) {
        self.id = id
        self.error = error
    }
}



public struct FfiConverterTypeReconciliationSendFailureItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReconciliationSendFailureItem {
        return
            try ReconciliationSendFailureItem(
                id: FfiConverterTypeEventId.read(from: &buf), 
                error: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ReconciliationSendFailureItem, into buf: inout [UInt8]) {
        FfiConverterTypeEventId.write(value.id, into: &buf)
        FfiConverterString.write(value.error, into: &buf)
    }
}


public func FfiConverterTypeReconciliationSendFailureItem_lift(_ buf: RustBuffer) throws -> ReconciliationSendFailureItem {
    return try FfiConverterTypeReconciliationSendFailureItem.lift(buf)
}

public func FfiConverterTypeReconciliationSendFailureItem_lower(_ value: ReconciliationSendFailureItem) -> RustBuffer {
    return FfiConverterTypeReconciliationSendFailureItem.lower(value)
}


/**
 * Send event output
 */
public struct SendEventOutput {
    /**
     * Event ID
     */
    public var id: EventId
    /**
     * Output
     */
    public var output: Output

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Event ID
         */id: EventId, 
        /**
         * Output
         */output: Output) {
        self.id = id
        self.output = output
    }
}



public struct FfiConverterTypeSendEventOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendEventOutput {
        return
            try SendEventOutput(
                id: FfiConverterTypeEventId.read(from: &buf), 
                output: FfiConverterTypeOutput.read(from: &buf)
        )
    }

    public static func write(_ value: SendEventOutput, into buf: inout [UInt8]) {
        FfiConverterTypeEventId.write(value.id, into: &buf)
        FfiConverterTypeOutput.write(value.output, into: &buf)
    }
}


public func FfiConverterTypeSendEventOutput_lift(_ buf: RustBuffer) throws -> SendEventOutput {
    return try FfiConverterTypeSendEventOutput.lift(buf)
}

public func FfiConverterTypeSendEventOutput_lower(_ value: SendEventOutput) -> RustBuffer {
    return FfiConverterTypeSendEventOutput.lower(value)
}


/**
 * Subscribe output
 */
public struct SubscribeOutput {
    /**
     * Subscription ID
     */
    public var id: String
    /**
     * Output
     */
    public var output: Output

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Subscription ID
         */id: String, 
        /**
         * Output
         */output: Output) {
        self.id = id
        self.output = output
    }
}



extension SubscribeOutput: Equatable, Hashable {
    public static func ==(lhs: SubscribeOutput, rhs: SubscribeOutput) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.output != rhs.output {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(output)
    }
}


public struct FfiConverterTypeSubscribeOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubscribeOutput {
        return
            try SubscribeOutput(
                id: FfiConverterString.read(from: &buf), 
                output: FfiConverterTypeOutput.read(from: &buf)
        )
    }

    public static func write(_ value: SubscribeOutput, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypeOutput.write(value.output, into: &buf)
    }
}


public func FfiConverterTypeSubscribeOutput_lift(_ buf: RustBuffer) throws -> SubscribeOutput {
    return try FfiConverterTypeSubscribeOutput.lift(buf)
}

public func FfiConverterTypeSubscribeOutput_lower(_ value: SubscribeOutput) -> RustBuffer {
    return FfiConverterTypeSubscribeOutput.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ConnectionMode {
    
    case direct
    case proxy(addr: String
    )
    case tor(customPath: String?
    )
}


public struct FfiConverterTypeConnectionMode: FfiConverterRustBuffer {
    typealias SwiftType = ConnectionMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectionMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .direct
        
        case 2: return .proxy(addr: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .tor(customPath: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConnectionMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .direct:
            writeInt(&buf, Int32(1))
        
        
        case let .proxy(addr):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(addr, into: &buf)
            
        
        case let .tor(customPath):
            writeInt(&buf, Int32(3))
            FfiConverterOptionString.write(customPath, into: &buf)
            
        }
    }
}


public func FfiConverterTypeConnectionMode_lift(_ buf: RustBuffer) throws -> ConnectionMode {
    return try FfiConverterTypeConnectionMode.lift(buf)
}

public func FfiConverterTypeConnectionMode_lower(_ value: ConnectionMode) -> RustBuffer {
    return FfiConverterTypeConnectionMode.lower(value)
}



extension ConnectionMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Connection target
 */

public enum ConnectionTarget {
    
    /**
     * Use proxy for all relays
     */
    case all
    /**
     * Use proxy only for `.onion` relays
     */
    case onion
}


public struct FfiConverterTypeConnectionTarget: FfiConverterRustBuffer {
    typealias SwiftType = ConnectionTarget

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectionTarget {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .all
        
        case 2: return .onion
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConnectionTarget, into buf: inout [UInt8]) {
        switch value {
        
        
        case .all:
            writeInt(&buf, Int32(1))
        
        
        case .onion:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeConnectionTarget_lift(_ buf: RustBuffer) throws -> ConnectionTarget {
    return try FfiConverterTypeConnectionTarget.lift(buf)
}

public func FfiConverterTypeConnectionTarget_lower(_ value: ConnectionTarget) -> RustBuffer {
    return FfiConverterTypeConnectionTarget.lower(value)
}



extension ConnectionTarget: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DatabaseEventStatus {
    
    case saved
    case deleted
    case notExistent
}


public struct FfiConverterTypeDatabaseEventStatus: FfiConverterRustBuffer {
    typealias SwiftType = DatabaseEventStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DatabaseEventStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .saved
        
        case 2: return .deleted
        
        case 3: return .notExistent
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DatabaseEventStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .saved:
            writeInt(&buf, Int32(1))
        
        
        case .deleted:
            writeInt(&buf, Int32(2))
        
        
        case .notExistent:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeDatabaseEventStatus_lift(_ buf: RustBuffer) throws -> DatabaseEventStatus {
    return try FfiConverterTypeDatabaseEventStatus.lift(buf)
}

public func FfiConverterTypeDatabaseEventStatus_lower(_ value: DatabaseEventStatus) -> RustBuffer {
    return FfiConverterTypeDatabaseEventStatus.lower(value)
}



extension DatabaseEventStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Filter options
 */

public enum FilterOptions {
    
    /**
     * Exit on EOSE
     */
    case exitOnEose
    /**
     * After EOSE is received, keep listening for N more events that match the filter, then return
     */
    case waitForEventsAfterEose(num: UInt16
    )
    /**
     * After EOSE is received, keep listening for matching events for `Duration` more time, then return
     */
    case waitDurationAfterEose(duration: TimeInterval
    )
}


public struct FfiConverterTypeFilterOptions: FfiConverterRustBuffer {
    typealias SwiftType = FilterOptions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FilterOptions {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .exitOnEose
        
        case 2: return .waitForEventsAfterEose(num: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 3: return .waitDurationAfterEose(duration: try FfiConverterDuration.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FilterOptions, into buf: inout [UInt8]) {
        switch value {
        
        
        case .exitOnEose:
            writeInt(&buf, Int32(1))
        
        
        case let .waitForEventsAfterEose(num):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(num, into: &buf)
            
        
        case let .waitDurationAfterEose(duration):
            writeInt(&buf, Int32(3))
            FfiConverterDuration.write(duration, into: &buf)
            
        }
    }
}


public func FfiConverterTypeFilterOptions_lift(_ buf: RustBuffer) throws -> FilterOptions {
    return try FfiConverterTypeFilterOptions.lift(buf)
}

public func FfiConverterTypeFilterOptions_lower(_ value: FilterOptions) -> RustBuffer {
    return FfiConverterTypeFilterOptions.lower(value)
}



extension FilterOptions: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogLevel {
    
    case error
    case warn
    case info
    case debug
    case trace
}


public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .error
        
        case 2: return .warn
        
        case 3: return .info
        
        case 4: return .debug
        
        case 5: return .trace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .error:
            writeInt(&buf, Int32(1))
        
        
        case .warn:
            writeInt(&buf, Int32(2))
        
        
        case .info:
            writeInt(&buf, Int32(3))
        
        
        case .debug:
            writeInt(&buf, Int32(4))
        
        
        case .trace:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}



extension LogLevel: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NegentropyDirection {
    
    case up
    case down
    case both
}


public struct FfiConverterTypeNegentropyDirection: FfiConverterRustBuffer {
    typealias SwiftType = NegentropyDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NegentropyDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .up
        
        case 2: return .down
        
        case 3: return .both
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NegentropyDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .up:
            writeInt(&buf, Int32(1))
        
        
        case .down:
            writeInt(&buf, Int32(2))
        
        
        case .both:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeNegentropyDirection_lift(_ buf: RustBuffer) throws -> NegentropyDirection {
    return try FfiConverterTypeNegentropyDirection.lift(buf)
}

public func FfiConverterTypeNegentropyDirection_lower(_ value: NegentropyDirection) -> RustBuffer {
    return FfiConverterTypeNegentropyDirection.lower(value)
}



extension NegentropyDirection: Equatable, Hashable {}




public enum NostrSdkError {

    
    
    case Generic(message: String)
    
}


public struct FfiConverterTypeNostrSdkError: FfiConverterRustBuffer {
    typealias SwiftType = NostrSdkError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrSdkError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NostrSdkError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


extension NostrSdkError: Equatable, Hashable {}

extension NostrSdkError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RelayFilteringMode {
    
    /**
     * Only the matching values will be allowed
     */
    case whitelist
    /**
     * All matching values will be discarded
     */
    case blacklist
}


public struct FfiConverterTypeRelayFilteringMode: FfiConverterRustBuffer {
    typealias SwiftType = RelayFilteringMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayFilteringMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .whitelist
        
        case 2: return .blacklist
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RelayFilteringMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .whitelist:
            writeInt(&buf, Int32(1))
        
        
        case .blacklist:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeRelayFilteringMode_lift(_ buf: RustBuffer) throws -> RelayFilteringMode {
    return try FfiConverterTypeRelayFilteringMode.lift(buf)
}

public func FfiConverterTypeRelayFilteringMode_lower(_ value: RelayFilteringMode) -> RustBuffer {
    return FfiConverterTypeRelayFilteringMode.lower(value)
}



extension RelayFilteringMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RelayStatus {
    
    /**
     * Relay initialized
     */
    case initialized
    /**
     * Pending
     */
    case pending
    /**
     * Connecting
     */
    case connecting
    /**
     * Relay connected
     */
    case connected
    /**
     * Relay disconnected, will retry to connect again
     */
    case disconnected
    /**
     * Relay completely disconnected
     */
    case terminated
}


public struct FfiConverterTypeRelayStatus: FfiConverterRustBuffer {
    typealias SwiftType = RelayStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initialized
        
        case 2: return .pending
        
        case 3: return .connecting
        
        case 4: return .connected
        
        case 5: return .disconnected
        
        case 6: return .terminated
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RelayStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .initialized:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case .connecting:
            writeInt(&buf, Int32(3))
        
        
        case .connected:
            writeInt(&buf, Int32(4))
        
        
        case .disconnected:
            writeInt(&buf, Int32(5))
        
        
        case .terminated:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypeRelayStatus_lift(_ buf: RustBuffer) throws -> RelayStatus {
    return try FfiConverterTypeRelayStatus.lift(buf)
}

public func FfiConverterTypeRelayStatus_lower(_ value: RelayStatus) -> RustBuffer {
    return FfiConverterTypeRelayStatus.lower(value)
}



extension RelayStatus: Equatable, Hashable {}



fileprivate struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDuration.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDuration.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeNostrSigner: FfiConverterRustBuffer {
    typealias SwiftType = NostrSigner?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNostrSigner.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNostrSigner.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRelayOptions: FfiConverterRustBuffer {
    typealias SwiftType = RelayOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRelayOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRelayOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSubscribeAutoCloseOptions: FfiConverterRustBuffer {
    typealias SwiftType = SubscribeAutoCloseOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSubscribeAutoCloseOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSubscribeAutoCloseOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeZapDetails: FfiConverterRustBuffer {
    typealias SwiftType = ZapDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeZapDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeZapDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = [Filter]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFilter.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFilter.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEvent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEvent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventId: FfiConverterRustBuffer {
    typealias SwiftType = EventId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Timestamp?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTimestamp.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTimestamp.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNegentropyItem: FfiConverterRustBuffer {
    typealias SwiftType = [NegentropyItem]

    public static func write(_ value: [NegentropyItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNegentropyItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NegentropyItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [NegentropyItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNegentropyItem.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeReconciliationSendFailureItem: FfiConverterRustBuffer {
    typealias SwiftType = [ReconciliationSendFailureItem]

    public static func write(_ value: [ReconciliationSendFailureItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReconciliationSendFailureItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ReconciliationSendFailureItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [ReconciliationSendFailureItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReconciliationSendFailureItem.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeClientMessage: FfiConverterRustBuffer {
    typealias SwiftType = [ClientMessage]

    public static func write(_ value: [ClientMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeClientMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ClientMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [ClientMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeClientMessage.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = [Event]

    public static func write(_ value: [Event], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEvent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Event] {
        let len: Int32 = try readInt(&buf)
        var seq = [Event]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEvent.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeEventId: FfiConverterRustBuffer {
    typealias SwiftType = [EventId]

    public static func write(_ value: [EventId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEventId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EventId] {
        let len: Int32 = try readInt(&buf)
        var seq = [EventId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEventId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = [Filter]

    public static func write(_ value: [Filter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Filter] {
        let len: Int32 = try readInt(&buf)
        var seq = [Filter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFilter.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLookupInvoiceResponseResult: FfiConverterRustBuffer {
    typealias SwiftType = [LookupInvoiceResponseResult]

    public static func write(_ value: [LookupInvoiceResponseResult], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLookupInvoiceResponseResult.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LookupInvoiceResponseResult] {
        let len: Int32 = try readInt(&buf)
        var seq = [LookupInvoiceResponseResult]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLookupInvoiceResponseResult.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    public static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringTypeRelay: FfiConverterRustBuffer {
    public static func write(_ value: [String: Relay], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeRelay.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Relay] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Relay]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeRelay.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringOptionString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String?], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterOptionString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String?] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String?]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterOptionString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceTypeReconciliationSendFailureItem: FfiConverterRustBuffer {
    public static func write(_ value: [String: [ReconciliationSendFailureItem]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeReconciliationSendFailureItem.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [ReconciliationSendFailureItem]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [ReconciliationSendFailureItem]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeReconciliationSendFailureItem.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceTypeFilter: FfiConverterRustBuffer {
    public static func write(_ value: [String: [Filter]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeFilter.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [Filter]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [Filter]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeFilter.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


























































private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountNostrSdkFfi() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
public func initLogger(level: LogLevel) {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_func_init_logger(
        FfiConverterTypeLogLevel.lower(level),$0
    )
}
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_nostr_sdk_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_init_logger() != 38847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_add_discovery_relay() != 57691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_add_read_relay() != 52565) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_add_relay() != 33779) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_add_write_relay() != 6818) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_automatic_authentication() != 51347) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_connect() != 30312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_connect_relay() != 31242) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_connect_with_timeout() != 16188) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_database() != 35722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_disconnect() != 21461) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_disconnect_relay() != 63825) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_dislike() != 15515) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_fetch_metadata() != 24983) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_file_metadata() != 65496) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_filtering() != 62979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_get_events_from() != 34355) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_get_events_of() != 44667) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap() != 52974) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap_to() != 59923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_handle_notifications() != 8916) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_like() != 17749) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_pool() != 3145) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_reaction() != 13847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_reconcile() != 9483) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_relay() != 53414) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_relays() != 53935) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_remove_relay() != 5421) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_repost() != 15487) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event() != 36678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder() != 28604) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder_to() != 34972) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event_to() != 40531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_msg_to() != 7643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_private_msg() != 65326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_private_msg_to() != 1051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_set_metadata() != 37318) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_shutdown() != 16786) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_sign_event_builder() != 47615) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_signer() != 31951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscribe() != 20608) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_to() != 26336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id() != 13157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id_to() != 27069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscription() != 1946) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscriptions() != 20072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe() != 16499) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe_all() != 37740) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_unwrap_gift_wrap() != 9076) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_update_difficulty() != 12551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_update_min_pow_difficulty() != 58908) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_zap() != 33763) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_build() != 61424) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_database() != 21061) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_opts() != 22620) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_signer() != 30905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_zapper() != 2114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_connection_addr() != 43068) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_connection_embedded_tor() != 51580) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_connection_mode() != 217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_connection_target() != 61648) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_backend() != 43310) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_save_event() != 44808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_check_id() != 33847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_has_coordinate_been_deleted() != 8731) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_event_id_seen() != 48961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_event_seen_on_relays() != 64294) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_event_by_id() != 63015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_count() != 29484) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_query() != 33233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_delete() != 56179) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_wipe() != 62100) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle_msg() != 15446) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle() != 58660) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_mockrelay__none() != 40990) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_mockrelay_shutdown() != 1736) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_mockrelay_url() != 63169) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_get_balance() != 30742) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_get_info() != 13299) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_list_transactions() != 27417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_lookup_invoice() != 14000) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_make_invoice() != 26233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_invoice() != 28548) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_keysend() != 7487) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_negentropyoptions_direction() != 49635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_negentropyoptions_dry_run() != 41399) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_negentropyoptions_initial_timeout() != 40199) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip46signer_bunker_uri() != 15034) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip46signer_relays() != 52111) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip46signer_signer_public_key() != 60994) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnectremotesigner_bunker_uri() != 7854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnectremotesigner_relays() != 20744) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnectremotesigner_serve() != 40586) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnectsigneractions_approve() != 33577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_count() != 63911) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_delete() != 19224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_event_by_id() != 13180) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_event_seen_on_relays() != 47905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_profile() != 30385) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_query() != 20702) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_save_event() != 62854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_wipe() != 58001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_decrypt() != 13688) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_encrypt() != 22096) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_decrypt() != 16401) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_encrypt() != 37397) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_public_key() != 58772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_sign_event() != 49886) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_sign_event_builder() != 4087) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_unwrap_gift_wrap() != 27503) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_connection_mode() != 29062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_timeout() != 18259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_autoconnect() != 15533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_automatic_authentication() != 33238) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_connection() != 11615) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_connection_timeout() != 57708) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_difficulty() != 20804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_filtering_mode() != 33603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_gossip() != 22162) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_max_avg_latency() != 34264) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_min_pow() != 54102) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_relay_limits() != 11682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_req_filters_chunk_size() != 19808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_send_timeout() != 11614) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_skip_disconnected_relays() != 28418) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_timeout() != 10820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_wait_for_send() != 50702) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_options_wait_for_subscription() != 52599) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_profile_metadata() != 34875) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_profile_name() != 10929) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_profile_public_key() != 31716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_batch_event() != 30109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_batch_msg() != 15403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_connect() != 15421) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_connection_mode() != 52002) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_count_events_of() != 10925) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_disconnect() != 54334) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_document() != 55628) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_filtering() != 16293) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_get_events_of() != 8379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_is_connected() != 50961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_opts() != 21198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_queue() != 23174) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_reconcile() != 20273) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_reconcile_with_items() != 13207) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_send_event() != 20786) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_send_msg() != 20244) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_stats() != 58574) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_status() != 14630) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe() != 7870) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe_with_id() != 33573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscription() != 14346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscriptions() != 24939) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_support_negentropy() != 5020) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe() != 20812) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe_all() != 32815) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_url() != 1351) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_attempts() != 52060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_received() != 157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_sent() != 64970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_connected_at() != 17598) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_first_connection_timestamp() != 30824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_latency() != 43153) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_success() != 52759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_uptime() != 29449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayfiltering_add_ids() != 37238) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayfiltering_add_public_keys() != 16552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayfiltering_clear() != 53904) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayfiltering_has_id() != 884) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayfiltering_has_public_key() != 9857) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayfiltering_mode() != 29749) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayfiltering_remove_id() != 62305) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayfiltering_remove_ids() != 35650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayfiltering_remove_public_key() != 61695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayfiltering_remove_public_keys() != 54891) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayfiltering_update_mode() != 20763) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags() != 29781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags_per_kind() != 24819) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size() != 63930) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size_per_kind() != 61881) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_message_max_size() != 9957) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_adjust_retry_sec() != 36994) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_connection_mode() != 24699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_filtering_mode() != 53101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_limits() != 10405) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_max_avg_latency() != 58939) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_ping() != 51607) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_pow() != 37387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_read() != 47081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_reconnect() != 48820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_retry_sec() != 58762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_update_adjust_retry_sec() != 1296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_update_pow_difficulty() != 44137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_update_reconnect() != 23173) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_update_retry_sec() != 43799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_write() != 45946) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_add_relay() != 60070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_batch_event() != 30015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_batch_event_to() != 65135) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_batch_msg_to() != 33822) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_connect() != 31806) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_connect_relay() != 36418) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_database() != 4532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_disconnect() != 51163) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_filtering() != 46575) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_get_events_from() != 53633) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_get_events_of() != 56917) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_handle_notifications() != 15285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_reconcile() != 62721) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_reconcile_with_items() != 61106) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_relay() != 11676) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_relays() != 16476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_remove_all_relay() != 16039) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_remove_relay() != 40859) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_send_event() != 16615) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_send_event_to() != 14653) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_send_msg_to() != 65436) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_shutdown() != 24603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscribe() != 63089) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscribe_to() != 20032) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscribe_with_id() != 5916) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscribe_with_id_to() != 46946) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscription() != 18304) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_subscriptions() != 34853) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_unsubscribe() != 28366) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaypool_unsubscribe_all() != 15780) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaysendoptions_skip_disconnected() != 4190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaysendoptions_skip_send_confirmation() != 22060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaysendoptions_timeout() != 16256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_filter() != 17195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_timeout() != 36298) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeoptions_close_on() != 31672) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeoptions_send_opts() != 55685) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_zapdetails_message() != 43166) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_client_new() != 54751) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_client_with_opts() != 35054) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_clientbuilder_new() != 11332) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_connection_new() != 32544) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventsource_both() != 16599) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventsource_both_with_specific_relays() != 59547) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventsource_database() != 22588) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventsource_relays() != 8271) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventsource_specific_relays() != 35301) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_mockrelay_run() != 52562) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nwc_new() != 26100) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nwc_with_opts() != 18653) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_negentropyoptions_new() != 15449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip46signer_init() != 34524) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnectremotesigner_from_uri() != 28026) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnectremotesigner_init() != 6872) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_custom() != 63992) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_lmdb() != 21752) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_keys() != 51910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_nip46() != 28927) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnectoptions_new() != 35456) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrzapper_nwc() != 65346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_options_new() != 30503) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_profile_new() != 65224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relay_custom() != 38370) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relay_new() != 3279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relay_with_opts() != 9335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relayfiltering_blacklist() != 16765) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relayfiltering_whitelist() != 49922) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_disable() != 39641) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_new() != 1364) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relayoptions_new() != 32157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaypool_new() != 50786) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaypool_with_database() != 59953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaysendoptions_new() != 31427) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_subscribeautocloseoptions_new() != 39595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_subscribeoptions_new() != 56214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_zapdetails_new() != 18563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_zapentity_event() != 61043) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_zapentity_public_key() != 56616) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitCustomNostrDatabase()
    uniffiCallbackInitHandleNotification()
    uniffiCallbackInitNostrConnectSignerActions()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all