// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(nostr_sdkFFI)
import nostr_sdkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_nostr_sdk_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_nostr_sdk_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureNostrSdkFfiInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}




public protocol AdmitPolicy: AnyObject, Sendable {
    
    /**
     * Admit connecting to a relay
     *
     * Returns `AdmitStatus`: `success` if the connection is allowed, otherwise `rejected`.
     */
    func admitConnection(relayUrl: RelayUrl) async throws  -> AdmitStatus?
    
    /**
     * Admit Event
     *
     * Returns `AdmitStatus`: `success` if the event is admitted, otherwise `rejected`.
     */
    func admitEvent(relayUrl: RelayUrl, subscriptionId: String, event: Event) async throws  -> AdmitStatus?
    
}
open class AdmitPolicyImpl: AdmitPolicy, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_admitpolicy(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_admitpolicy(pointer, $0) }
    }

    

    
    /**
     * Admit connecting to a relay
     *
     * Returns `AdmitStatus`: `success` if the connection is allowed, otherwise `rejected`.
     */
open func admitConnection(relayUrl: RelayUrl)async throws  -> AdmitStatus?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_admitpolicy_admit_connection(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelayUrl_lower(relayUrl)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeAdmitStatus.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Admit Event
     *
     * Returns `AdmitStatus`: `success` if the event is admitted, otherwise `rejected`.
     */
open func admitEvent(relayUrl: RelayUrl, subscriptionId: String, event: Event)async throws  -> AdmitStatus?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_admitpolicy_admit_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelayUrl_lower(relayUrl),FfiConverterString.lower(subscriptionId),FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeAdmitStatus.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceAdmitPolicy {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceAdmitPolicy] = [UniffiVTableCallbackInterfaceAdmitPolicy(
        admitConnection: { (
            uniffiHandle: UInt64,
            relayUrl: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> AdmitStatus? in
                guard let uniffiObj = try? FfiConverterTypeAdmitPolicy.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.admitConnection(
                     relayUrl: try FfiConverterTypeRelayUrl_lift(relayUrl)
                )
            }

            let uniffiHandleSuccess = { (returnValue: AdmitStatus?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeAdmitStatus.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        admitEvent: { (
            uniffiHandle: UInt64,
            relayUrl: UnsafeMutableRawPointer,
            subscriptionId: RustBuffer,
            event: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> AdmitStatus? in
                guard let uniffiObj = try? FfiConverterTypeAdmitPolicy.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.admitEvent(
                     relayUrl: try FfiConverterTypeRelayUrl_lift(relayUrl),
                     subscriptionId: try FfiConverterString.lift(subscriptionId),
                     event: try FfiConverterTypeEvent_lift(event)
                )
            }

            let uniffiHandleSuccess = { (returnValue: AdmitStatus?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeAdmitStatus.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeAdmitPolicy.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface AdmitPolicy: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitAdmitPolicy() {
    uniffi_nostr_sdk_ffi_fn_init_callback_vtable_admitpolicy(UniffiCallbackInterfaceAdmitPolicy.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAdmitPolicy: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<AdmitPolicy>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AdmitPolicy

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AdmitPolicy {
        return AdmitPolicyImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AdmitPolicy) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AdmitPolicy {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AdmitPolicy, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAdmitPolicy_lift(_ pointer: UnsafeMutableRawPointer) throws -> AdmitPolicy {
    return try FfiConverterTypeAdmitPolicy.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAdmitPolicy_lower(_ value: AdmitPolicy) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAdmitPolicy.lower(value)
}






public protocol AdmitStatusProtocol: AnyObject, Sendable {
    
}
open class AdmitStatus: AdmitStatusProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_admitstatus(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_admitstatus(pointer, $0) }
    }

    
public static func rejected(reason: String? = nil) -> AdmitStatus  {
    return try!  FfiConverterTypeAdmitStatus_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_admitstatus_rejected(
        FfiConverterOptionString.lower(reason),$0
    )
})
}
    
public static func success() -> AdmitStatus  {
    return try!  FfiConverterTypeAdmitStatus_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_admitstatus_success($0
    )
})
}
    

    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_admitstatus_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: AdmitStatus, other: AdmitStatus) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_admitstatus_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeAdmitStatus_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_admitstatus_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension AdmitStatus: CustomDebugStringConvertible {}
extension AdmitStatus: Equatable {}
extension AdmitStatus: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAdmitStatus: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AdmitStatus

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AdmitStatus {
        return AdmitStatus(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AdmitStatus) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AdmitStatus {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AdmitStatus, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAdmitStatus_lift(_ pointer: UnsafeMutableRawPointer) throws -> AdmitStatus {
    return try FfiConverterTypeAdmitStatus.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAdmitStatus_lower(_ value: AdmitStatus) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAdmitStatus.lower(value)
}






public protocol ClientProtocol: AnyObject, Sendable {
    
    /**
     * Add discovery relay
     *
     * If relay already exists, this method automatically add the `DISCOVERY` flag to it and return `false`.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/65.md>
     */
    func addDiscoveryRelay(url: RelayUrl) async throws  -> Bool
    
    /**
     * Add read relay
     *
     * If relay already exists, this method add the `READ` flag to it and return `false`.
     */
    func addReadRelay(url: RelayUrl) async throws  -> Bool
    
    /**
     * Add new relay
     *
     * Relays added with this method will have both `READ` and `WRITE` flags enabled
     *
     * If the relay already exists, the flags will be updated and `false` returned.
     *
     * If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
     * to avoid to set pool subscriptions.
     *
     * This method use previously set or default `Options` to configure the `Relay` (ex. set proxy, set min POW, set relay limits, ...).
     *
     * Connection is **NOT** automatically started with relay, remember to call `connect` method!
     */
    func addRelay(url: RelayUrl) async throws  -> Bool
    
    /**
     * Add new relay with custom options
     */
    func addRelayWithOpts(url: RelayUrl, opts: RelayOptions) async throws  -> Bool
    
    /**
     * Add write relay
     *
     * If relay already exists, this method add the `WRITE` flag to it and return `false`.
     */
    func addWriteRelay(url: RelayUrl) async throws  -> Bool
    
    /**
     * Auto authenticate to relays (default: true)
     *
     * <https://github.com/nostr-protocol/nips/blob/master/42.md>
     */
    func automaticAuthentication(enable: Bool) 
    
    /**
     * Connect to all added relays
     *
     * Attempts to initiate a connection for every relay currently in
     * [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`].
     * A background connection task is spawned for each such relay, which then tries
     * to establish the connection.
     * Any relay not in one of these two statuses is skipped.
     *
     * For further details, see the documentation of [`Relay::connect`].
     */
    func connect() async 
    
    /**
     * Connect to a previously added relay
     */
    func connectRelay(url: RelayUrl) async throws 
    
    func database()  -> NostrDatabase
    
    /**
     * Disconnect from all relays
     */
    func disconnect() async 
    
    func disconnectRelay(url: RelayUrl) async throws 
    
    /**
     * Get events both from database and relays
     *
     * This is an auto-closing subscription and will be closed automatically on `EOSE`.
     *
     * You can obtain the same result by merging the `Events` from different type of sources.
     *
     * This method will be deprecated in the future!
     * This is a temporary solution for who still want to query events both from database and relays and merge the result.
     * The optimal solution is to execute a [`Client::sync`] to get all old events, [`Client::subscribe`] to get all
     * new future events, [`NostrDatabase::query`] to query events and [`Client::handle_notifications`] to listen-for/handle new events (i.e. to know when update the UI).
     * This will allow very fast queries, low bandwidth usage (depending on how many events the client have to sync) and a low load on relays.
     *
     * # Gossip
     *
     * If `gossip` is enabled (see [`Options::gossip`]) the events will be requested also to
     * NIP65 relays (automatically discovered) of public keys included in filters (if any).
     */
    func fetchCombinedEvents(filter: Filter, timeout: TimeInterval) async throws  -> Events
    
    /**
     * Fetch events from relays
     *
     * This is an auto-closing subscription and will be closed automatically on `EOSE`.
     *
     * # Gossip
     *
     * If `gossip` is enabled (see `Options`) the events will be requested also to
     * NIP65 relays (automatically discovered) of public keys included in filters (if any).
     */
    func fetchEvents(filter: Filter, timeout: TimeInterval) async throws  -> Events
    
    /**
     * Fetch events from specific relays
     *
     * This is an auto-closing subscription and will be closed automatically on `EOSE`.
     */
    func fetchEventsFrom(urls: [RelayUrl], filter: Filter, timeout: TimeInterval) async throws  -> Events
    
    /**
     * Fetch the newest public key metadata from relays.
     *
     * Returns `None` if the `Metadata` of the `PublicKey` has not been found.
     *
     * Check `Client::fetch_events` for more details.
     *
     * If you only want to consult cached data,
     * consider `client.database().profile(PUBKEY)`.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func fetchMetadata(publicKey: PublicKey, timeout: TimeInterval) async throws  -> Metadata?
    
    /**
     * Disconnect and force remove all relays
     */
    func forceRemoveAllRelays() async 
    
    /**
     * Force remove and disconnect relay
     *
     * Note: this method will remove the relay, also if it's in use for the gossip model or other service!
     */
    func forceRemoveRelay(url: RelayUrl) async throws 
    
    /**
     * Construct Gift Wrap and send to relays
     *
     * Check `send_event` method to know how sending events works.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
    func giftWrap(receiver: PublicKey, rumor: UnsignedEvent, extraTags: [Tag]) async throws  -> SendEventOutput
    
    /**
     * Construct Gift Wrap and send to specific relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
    func giftWrapTo(urls: [RelayUrl], receiver: PublicKey, rumor: UnsignedEvent, extraTags: [Tag]) async throws  -> SendEventOutput
    
    /**
     * Handle notifications
     */
    func handleNotifications(handler: HandleNotification) async throws 
    
    func relay(url: RelayUrl) async throws  -> Relay
    
    /**
     * Get relays with `READ` or `WRITE` flags
     */
    func relays() async  -> [RelayUrl: Relay]
    
    /**
     * Disconnect and remove all relays
     *
     * Some relays used by some services could not be disconnected with this method
     * (like the ones used for gossip).
     * Use [`Client::force_remove_all_relays`] to remove every relay.
     */
    func removeAllRelays() async 
    
    /**
     * Remove and disconnect relay
     *
     * If the relay has `GOSSIP` flag, it will not be removed from the pool and its
     * flags will be updated (remove `READ`, `WRITE` and `DISCOVERY` flags).
     */
    func removeRelay(url: RelayUrl) async throws 
    
    /**
     * Send event
     *
     * Send event to all relays with `WRITE` flag.
     * If `gossip` is enabled (see `Options`) the event will be sent also to NIP65 relays (automatically discovered).
     */
    func sendEvent(event: Event) async throws  -> SendEventOutput
    
    /**
     * Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to relays (check `send_event` method for more details)
     *
     * Rise an error if the `NostrSigner` is not set.
     */
    func sendEventBuilder(builder: EventBuilder) async throws  -> SendEventOutput
    
    /**
     * Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to specific relays.
     *
     * Rise an error if the `NostrSigner` is not set.
     */
    func sendEventBuilderTo(urls: [RelayUrl], builder: EventBuilder) async throws  -> SendEventOutput
    
    /**
     * Send event to specific relays.
     */
    func sendEventTo(urls: [RelayUrl], event: Event) async throws  -> SendEventOutput
    
    func sendMsgTo(urls: [RelayUrl], msg: ClientMessage) async throws  -> Output
    
    /**
     * Send a private direct message
     *
     * If gossip is enabled, the message will be sent to the NIP17 relays (automatically discovered).
     * If gossip is not enabled will be sent to all relays with WRITE` relay service flag.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/17.md>
     */
    func sendPrivateMsg(receiver: PublicKey, message: String, rumorExtraTags: [Tag]) async throws  -> SendEventOutput
    
    /**
     * Send private direct message to specific relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/17.md>
     */
    func sendPrivateMsgTo(urls: [RelayUrl], receiver: PublicKey, message: String, rumorExtraTags: [Tag]) async throws  -> SendEventOutput
    
    func setMetadata(metadata: Metadata) async throws  -> SendEventOutput
    
    func shutdown() async 
    
    /**
     * Signs the `EventBuilder` into an `Event` using the `NostrSigner`
     */
    func signEventBuilder(builder: EventBuilder) async throws  -> Event
    
    func signer() async throws  -> NostrSigner
    
    /**
     * Stream events from relays
     *
     * # Overview
     *
     * This is an **auto-closing subscription** and will be closed automatically on `EOSE`.
     * For long-lived subscriptions, check [`Client::subscribe`].
     *
     * # Gossip
     *
     * If `gossip` is enabled the events will be streamed also from
     * NIP65 relays (automatically discovered) of public keys included in filters (if any).
     */
    func streamEvents(filter: Filter, timeout: TimeInterval) async throws  -> EventStream
    
    /**
     * Stream events from specific relays
     *
     * # Overview
     *
     * This is an **auto-closing subscription** and will be closed automatically on `EOSE`.
     * For long-lived subscriptions, check [`Client::subscribe_to`].
     */
    func streamEventsFrom(urls: [RelayUrl], filter: Filter, timeout: TimeInterval) async throws  -> EventStream
    
    /**
     * Stream events from specific relays with specific filters
     *
     * # Overview
     *
     * This is an **auto-closing subscription** and will be closed automatically on `EOSE`.
     */
    func streamEventsTargeted(targets: [RelayUrl: Filter], timeout: TimeInterval) async throws  -> EventStream
    
    /**
     * Subscribe to filters
     *
     * If `gossip` is enabled (see `Options]) the events will be requested also to
     * NIP65 relays (automatically discovered) of public keys included in filters (if any).
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
    func subscribe(filter: Filter, opts: SubscribeAutoCloseOptions?) async throws  -> SubscribeOutput
    
    /**
     * Subscribe to filters to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
    func subscribeTo(urls: [RelayUrl], filter: Filter, opts: SubscribeAutoCloseOptions?) async throws  -> SubscribeOutput
    
    /**
     * Subscribe to filters with custom subscription ID
     *
     * If `gossip` is enabled (see `Options]) the events will be requested also to
     * NIP65 relays (automatically discovered) of public keys included in filters (if any).
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
    func subscribeWithId(id: String, filter: Filter, opts: SubscribeAutoCloseOptions?) async throws  -> Output
    
    /**
     * Subscribe to filters with custom subscription ID to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
    func subscribeWithIdTo(urls: [RelayUrl], id: String, filter: Filter, opts: SubscribeAutoCloseOptions?) async throws  -> Output
    
    func subscription(id: String) async  -> [RelayUrl: [Filter]]
    
    func subscriptions() async  -> [String: [RelayUrl: [Filter]]]
    
    /**
     * Sync events with relays (negentropy reconciliation)
     *
     * If `gossip` is enabled (see `Options`) the events will be reconciled also with
     * NIP65 relays (automatically discovered) of public keys included in filters (if any).
     *
     * <https://github.com/hoytech/negentropy>
     */
    func sync(filter: Filter, opts: SyncOptions) async throws  -> ReconciliationOutput
    
    /**
     * Try to establish a connection with the relays.
     *
     * Attempts to establish a connection for every relay currently in
     * [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`]
     * without spawning the connection task if it fails.
     * This means that if the connection fails, no automatic retries are scheduled.
     * Use [`Client::connect`] if you want to immediately spawn a connection task,
     * regardless of whether the initial connection succeeds.
     *
     * For further details, see the documentation of [`Relay::try_connect`].
     */
    func tryConnect(timeout: TimeInterval) async  -> Output
    
    func unsubscribe(subscriptionId: String) async 
    
    func unsubscribeAll() async 
    
    /**
     * Unwrap Gift Wrap event
     *
     * Internally verify the `seal` event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
    func unwrapGiftWrap(giftWrap: Event) async throws  -> UnwrappedGift
    
    /**
     * Waits for relays connections
     *
     * Wait for relays connections at most for the specified `timeout`.
     * The code continues when the relays are connected or the `timeout` is reached.
     */
    func waitForConnection(timeout: TimeInterval) async 
    
}
open class Client: ClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_client(self.pointer, $0) }
    }
public convenience init(signer: NostrSigner? = nil) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_client_new(
        FfiConverterOptionTypeNostrSigner.lower(signer),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_client(pointer, $0) }
    }

    

    
    /**
     * Add discovery relay
     *
     * If relay already exists, this method automatically add the `DISCOVERY` flag to it and return `false`.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/65.md>
     */
open func addDiscoveryRelay(url: RelayUrl)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_add_discovery_relay(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelayUrl_lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Add read relay
     *
     * If relay already exists, this method add the `READ` flag to it and return `false`.
     */
open func addReadRelay(url: RelayUrl)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_add_read_relay(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelayUrl_lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Add new relay
     *
     * Relays added with this method will have both `READ` and `WRITE` flags enabled
     *
     * If the relay already exists, the flags will be updated and `false` returned.
     *
     * If are set pool subscriptions, the new added relay will inherit them. Use `subscribe_to` method instead of `subscribe`,
     * to avoid to set pool subscriptions.
     *
     * This method use previously set or default `Options` to configure the `Relay` (ex. set proxy, set min POW, set relay limits, ...).
     *
     * Connection is **NOT** automatically started with relay, remember to call `connect` method!
     */
open func addRelay(url: RelayUrl)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_add_relay(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelayUrl_lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Add new relay with custom options
     */
open func addRelayWithOpts(url: RelayUrl, opts: RelayOptions)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_add_relay_with_opts(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelayUrl_lower(url),FfiConverterTypeRelayOptions_lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Add write relay
     *
     * If relay already exists, this method add the `WRITE` flag to it and return `false`.
     */
open func addWriteRelay(url: RelayUrl)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_add_write_relay(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelayUrl_lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Auto authenticate to relays (default: true)
     *
     * <https://github.com/nostr-protocol/nips/blob/master/42.md>
     */
open func automaticAuthentication(enable: Bool)  {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_automatic_authentication(self.uniffiClonePointer(),
        FfiConverterBool.lower(enable),$0
    )
}
}
    
    /**
     * Connect to all added relays
     *
     * Attempts to initiate a connection for every relay currently in
     * [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`].
     * A background connection task is spawned for each such relay, which then tries
     * to establish the connection.
     * Any relay not in one of these two statuses is skipped.
     *
     * For further details, see the documentation of [`Relay::connect`].
     */
open func connect()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_connect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Connect to a previously added relay
     */
open func connectRelay(url: RelayUrl)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_connect_relay(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelayUrl_lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func database() -> NostrDatabase  {
    return try!  FfiConverterTypeNostrDatabase_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_client_database(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Disconnect from all relays
     */
open func disconnect()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_disconnect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func disconnectRelay(url: RelayUrl)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_disconnect_relay(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelayUrl_lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Get events both from database and relays
     *
     * This is an auto-closing subscription and will be closed automatically on `EOSE`.
     *
     * You can obtain the same result by merging the `Events` from different type of sources.
     *
     * This method will be deprecated in the future!
     * This is a temporary solution for who still want to query events both from database and relays and merge the result.
     * The optimal solution is to execute a [`Client::sync`] to get all old events, [`Client::subscribe`] to get all
     * new future events, [`NostrDatabase::query`] to query events and [`Client::handle_notifications`] to listen-for/handle new events (i.e. to know when update the UI).
     * This will allow very fast queries, low bandwidth usage (depending on how many events the client have to sync) and a low load on relays.
     *
     * # Gossip
     *
     * If `gossip` is enabled (see [`Options::gossip`]) the events will be requested also to
     * NIP65 relays (automatically discovered) of public keys included in filters (if any).
     */
open func fetchCombinedEvents(filter: Filter, timeout: TimeInterval)async throws  -> Events  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_fetch_combined_events(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvents_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Fetch events from relays
     *
     * This is an auto-closing subscription and will be closed automatically on `EOSE`.
     *
     * # Gossip
     *
     * If `gossip` is enabled (see `Options`) the events will be requested also to
     * NIP65 relays (automatically discovered) of public keys included in filters (if any).
     */
open func fetchEvents(filter: Filter, timeout: TimeInterval)async throws  -> Events  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_fetch_events(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvents_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Fetch events from specific relays
     *
     * This is an auto-closing subscription and will be closed automatically on `EOSE`.
     */
open func fetchEventsFrom(urls: [RelayUrl], filter: Filter, timeout: TimeInterval)async throws  -> Events  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_fetch_events_from(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeRelayUrl.lower(urls),FfiConverterTypeFilter_lower(filter),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvents_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Fetch the newest public key metadata from relays.
     *
     * Returns `None` if the `Metadata` of the `PublicKey` has not been found.
     *
     * Check `Client::fetch_events` for more details.
     *
     * If you only want to consult cached data,
     * consider `client.database().profile(PUBKEY)`.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
open func fetchMetadata(publicKey: PublicKey, timeout: TimeInterval)async throws  -> Metadata?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_fetch_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeMetadata.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Disconnect and force remove all relays
     */
open func forceRemoveAllRelays()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_force_remove_all_relays(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Force remove and disconnect relay
     *
     * Note: this method will remove the relay, also if it's in use for the gossip model or other service!
     */
open func forceRemoveRelay(url: RelayUrl)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_force_remove_relay(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelayUrl_lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Construct Gift Wrap and send to relays
     *
     * Check `send_event` method to know how sending events works.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
open func giftWrap(receiver: PublicKey, rumor: UnsignedEvent, extraTags: [Tag])async throws  -> SendEventOutput  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_gift_wrap(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(receiver),FfiConverterTypeUnsignedEvent_lower(rumor),FfiConverterSequenceTypeTag.lower(extraTags)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Construct Gift Wrap and send to specific relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
open func giftWrapTo(urls: [RelayUrl], receiver: PublicKey, rumor: UnsignedEvent, extraTags: [Tag])async throws  -> SendEventOutput  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_gift_wrap_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeRelayUrl.lower(urls),FfiConverterTypePublicKey_lower(receiver),FfiConverterTypeUnsignedEvent_lower(rumor),FfiConverterSequenceTypeTag.lower(extraTags)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Handle notifications
     */
open func handleNotifications(handler: HandleNotification)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_handle_notifications(
                    self.uniffiClonePointer(),
                    FfiConverterTypeHandleNotification_lower(handler)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func relay(url: RelayUrl)async throws  -> Relay  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_relay(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelayUrl_lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRelay_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Get relays with `READ` or `WRITE` flags
     */
open func relays()async  -> [RelayUrl: Relay]  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_relays(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryTypeRelayUrlTypeRelay.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Disconnect and remove all relays
     *
     * Some relays used by some services could not be disconnected with this method
     * (like the ones used for gossip).
     * Use [`Client::force_remove_all_relays`] to remove every relay.
     */
open func removeAllRelays()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_remove_all_relays(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Remove and disconnect relay
     *
     * If the relay has `GOSSIP` flag, it will not be removed from the pool and its
     * flags will be updated (remove `READ`, `WRITE` and `DISCOVERY` flags).
     */
open func removeRelay(url: RelayUrl)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_remove_relay(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelayUrl_lower(url)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Send event
     *
     * Send event to all relays with `WRITE` flag.
     * If `gossip` is enabled (see `Options`) the event will be sent also to NIP65 relays (automatically discovered).
     */
open func sendEvent(event: Event)async throws  -> SendEventOutput  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to relays (check `send_event` method for more details)
     *
     * Rise an error if the `NostrSigner` is not set.
     */
open func sendEventBuilder(builder: EventBuilder)async throws  -> SendEventOutput  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventBuilder_lower(builder)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Take an `EventBuilder`, sign it by using the `NostrSigner` and broadcast to specific relays.
     *
     * Rise an error if the `NostrSigner` is not set.
     */
open func sendEventBuilderTo(urls: [RelayUrl], builder: EventBuilder)async throws  -> SendEventOutput  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_event_builder_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeRelayUrl.lower(urls),FfiConverterTypeEventBuilder_lower(builder)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Send event to specific relays.
     */
open func sendEventTo(urls: [RelayUrl], event: Event)async throws  -> SendEventOutput  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_event_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeRelayUrl.lower(urls),FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func sendMsgTo(urls: [RelayUrl], msg: ClientMessage)async throws  -> Output  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_msg_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeRelayUrl.lower(urls),FfiConverterTypeClientMessage_lower(msg)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOutput_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Send a private direct message
     *
     * If gossip is enabled, the message will be sent to the NIP17 relays (automatically discovered).
     * If gossip is not enabled will be sent to all relays with WRITE` relay service flag.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/17.md>
     */
open func sendPrivateMsg(receiver: PublicKey, message: String, rumorExtraTags: [Tag] = [])async throws  -> SendEventOutput  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_private_msg(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(receiver),FfiConverterString.lower(message),FfiConverterSequenceTypeTag.lower(rumorExtraTags)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Send private direct message to specific relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/17.md>
     */
open func sendPrivateMsgTo(urls: [RelayUrl], receiver: PublicKey, message: String, rumorExtraTags: [Tag] = [])async throws  -> SendEventOutput  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_send_private_msg_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeRelayUrl.lower(urls),FfiConverterTypePublicKey_lower(receiver),FfiConverterString.lower(message),FfiConverterSequenceTypeTag.lower(rumorExtraTags)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func setMetadata(metadata: Metadata)async throws  -> SendEventOutput  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_set_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMetadata_lower(metadata)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendEventOutput_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func shutdown()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_shutdown(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Signs the `EventBuilder` into an `Event` using the `NostrSigner`
     */
open func signEventBuilder(builder: EventBuilder)async throws  -> Event  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_sign_event_builder(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventBuilder_lower(builder)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvent_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func signer()async throws  -> NostrSigner  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_signer(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNostrSigner_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Stream events from relays
     *
     * # Overview
     *
     * This is an **auto-closing subscription** and will be closed automatically on `EOSE`.
     * For long-lived subscriptions, check [`Client::subscribe`].
     *
     * # Gossip
     *
     * If `gossip` is enabled the events will be streamed also from
     * NIP65 relays (automatically discovered) of public keys included in filters (if any).
     */
open func streamEvents(filter: Filter, timeout: TimeInterval)async throws  -> EventStream  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_stream_events(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventStream_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Stream events from specific relays
     *
     * # Overview
     *
     * This is an **auto-closing subscription** and will be closed automatically on `EOSE`.
     * For long-lived subscriptions, check [`Client::subscribe_to`].
     */
open func streamEventsFrom(urls: [RelayUrl], filter: Filter, timeout: TimeInterval)async throws  -> EventStream  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_stream_events_from(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeRelayUrl.lower(urls),FfiConverterTypeFilter_lower(filter),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventStream_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Stream events from specific relays with specific filters
     *
     * # Overview
     *
     * This is an **auto-closing subscription** and will be closed automatically on `EOSE`.
     */
open func streamEventsTargeted(targets: [RelayUrl: Filter], timeout: TimeInterval)async throws  -> EventStream  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_stream_events_targeted(
                    self.uniffiClonePointer(),
                    FfiConverterDictionaryTypeRelayUrlTypeFilter.lower(targets),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventStream_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Subscribe to filters
     *
     * If `gossip` is enabled (see `Options]) the events will be requested also to
     * NIP65 relays (automatically discovered) of public keys included in filters (if any).
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
open func subscribe(filter: Filter, opts: SubscribeAutoCloseOptions? = nil)async throws  -> SubscribeOutput  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscribe(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSubscribeOutput_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Subscribe to filters to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
open func subscribeTo(urls: [RelayUrl], filter: Filter, opts: SubscribeAutoCloseOptions? = nil)async throws  -> SubscribeOutput  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscribe_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeRelayUrl.lower(urls),FfiConverterTypeFilter_lower(filter),FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSubscribeOutput_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Subscribe to filters with custom subscription ID
     *
     * If `gossip` is enabled (see `Options]) the events will be requested also to
     * NIP65 relays (automatically discovered) of public keys included in filters (if any).
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
open func subscribeWithId(id: String, filter: Filter, opts: SubscribeAutoCloseOptions? = nil)async throws  -> Output  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscribe_with_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id),FfiConverterTypeFilter_lower(filter),FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOutput_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Subscribe to filters with custom subscription ID to specific relays
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
     */
open func subscribeWithIdTo(urls: [RelayUrl], id: String, filter: Filter, opts: SubscribeAutoCloseOptions? = nil)async throws  -> Output  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscribe_with_id_to(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeRelayUrl.lower(urls),FfiConverterString.lower(id),FfiConverterTypeFilter_lower(filter),FfiConverterOptionTypeSubscribeAutoCloseOptions.lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOutput_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func subscription(id: String)async  -> [RelayUrl: [Filter]]  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscription(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryTypeRelayUrlSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
open func subscriptions()async  -> [String: [RelayUrl: [Filter]]]  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_subscriptions(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringDictionaryTypeRelayUrlSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Sync events with relays (negentropy reconciliation)
     *
     * If `gossip` is enabled (see `Options`) the events will be reconciled also with
     * NIP65 relays (automatically discovered) of public keys included in filters (if any).
     *
     * <https://github.com/hoytech/negentropy>
     */
open func sync(filter: Filter, opts: SyncOptions)async throws  -> ReconciliationOutput  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_sync(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterTypeSyncOptions_lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeReconciliationOutput_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Try to establish a connection with the relays.
     *
     * Attempts to establish a connection for every relay currently in
     * [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`]
     * without spawning the connection task if it fails.
     * This means that if the connection fails, no automatic retries are scheduled.
     * Use [`Client::connect`] if you want to immediately spawn a connection task,
     * regardless of whether the initial connection succeeds.
     *
     * For further details, see the documentation of [`Relay::try_connect`].
     */
open func tryConnect(timeout: TimeInterval)async  -> Output  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_try_connect(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOutput_lift,
            errorHandler: nil
            
        )
}
    
open func unsubscribe(subscriptionId: String)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(subscriptionId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func unsubscribeAll()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_unsubscribe_all(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Unwrap Gift Wrap event
     *
     * Internally verify the `seal` event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
open func unwrapGiftWrap(giftWrap: Event)async throws  -> UnwrappedGift  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_unwrap_gift_wrap(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(giftWrap)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeUnwrappedGift_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Waits for relays connections
     *
     * Wait for relays connections at most for the specified `timeout`.
     * The code continues when the relays are connected or the `timeout` is reached.
     */
open func waitForConnection(timeout: TimeInterval)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_client_wait_for_connection(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}






public protocol ClientBuilderProtocol: AnyObject, Sendable {
    
    /**
     * Set an admission policy
     */
    func admitPolicy(policy: AdmitPolicy)  -> ClientBuilder
    
    /**
     * Build [`Client`]
     */
    func build()  -> Client
    
    func database(database: NostrDatabase)  -> ClientBuilder
    
    /**
     * Set a gossip store
     */
    func gossip(gossip: NostrGossip)  -> ClientBuilder
    
    /**
     * Set opts
     */
    func opts(opts: ClientOptions)  -> ClientBuilder
    
    func signer(signer: NostrSigner)  -> ClientBuilder
    
    /**
     * Set a custom WebSocket transport
     */
    func websocketTransport(transport: CustomWebSocketTransport)  -> ClientBuilder
    
}
open class ClientBuilder: ClientBuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_clientbuilder(self.pointer, $0) }
    }
    /**
     * New client builder
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_clientbuilder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_clientbuilder(pointer, $0) }
    }

    

    
    /**
     * Set an admission policy
     */
open func admitPolicy(policy: AdmitPolicy) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_admit_policy(self.uniffiClonePointer(),
        FfiConverterTypeAdmitPolicy_lower(policy),$0
    )
})
}
    
    /**
     * Build [`Client`]
     */
open func build() -> Client  {
    return try!  FfiConverterTypeClient_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_build(self.uniffiClonePointer(),$0
    )
})
}
    
open func database(database: NostrDatabase) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_database(self.uniffiClonePointer(),
        FfiConverterTypeNostrDatabase_lower(database),$0
    )
})
}
    
    /**
     * Set a gossip store
     */
open func gossip(gossip: NostrGossip) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_gossip(self.uniffiClonePointer(),
        FfiConverterTypeNostrGossip_lower(gossip),$0
    )
})
}
    
    /**
     * Set opts
     */
open func opts(opts: ClientOptions) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_opts(self.uniffiClonePointer(),
        FfiConverterTypeClientOptions_lower(opts),$0
    )
})
}
    
open func signer(signer: NostrSigner) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_signer(self.uniffiClonePointer(),
        FfiConverterTypeNostrSigner_lower(signer),$0
    )
})
}
    
    /**
     * Set a custom WebSocket transport
     */
open func websocketTransport(transport: CustomWebSocketTransport) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientbuilder_websocket_transport(self.uniffiClonePointer(),
        FfiConverterTypeCustomWebSocketTransport_lower(transport),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
        return ClientBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientBuilder {
    return try FfiConverterTypeClientBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientBuilder_lower(_ value: ClientBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientBuilder.lower(value)
}






public protocol ClientMessageProtocol: AnyObject, Sendable {
    
    /**
     * Clone `ClientMessage` and convert it to `ClientMessageEnum`
     */
    func asEnum()  -> ClientMessageEnum
    
    func asJson() throws  -> String
    
}
open class ClientMessage: ClientMessageProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_clientmessage(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_clientmessage(pointer, $0) }
    }

    
    /**
     * Create new `AUTH` message
     */
public static func auth(event: Event) -> ClientMessage  {
    return try!  FfiConverterTypeClientMessage_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_auth(
        FfiConverterTypeEvent_lower(event),$0
    )
})
}
    
    /**
     * Create new `CLOSE` message
     */
public static func close(subscriptionId: String) -> ClientMessage  {
    return try!  FfiConverterTypeClientMessage_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_close(
        FfiConverterString.lower(subscriptionId),$0
    )
})
}
    
    /**
     * Create new `COUNT` message
     */
public static func count(subscriptionId: String, filter: Filter) -> ClientMessage  {
    return try!  FfiConverterTypeClientMessage_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_count(
        FfiConverterString.lower(subscriptionId),
        FfiConverterTypeFilter_lower(filter),$0
    )
})
}
    
    /**
     * Create new `EVENT` message
     */
public static func event(event: Event) -> ClientMessage  {
    return try!  FfiConverterTypeClientMessage_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_event(
        FfiConverterTypeEvent_lower(event),$0
    )
})
}
    
    /**
     * Convert `ClientMessageEnum` to `ClientMessage`
     */
public static func fromEnum(e: ClientMessageEnum) -> ClientMessage  {
    return try!  FfiConverterTypeClientMessage_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_from_enum(
        FfiConverterTypeClientMessageEnum_lower(e),$0
    )
})
}
    
    /**
     * Deserialize `ClientMessage` from JSON string
     *
     * **This method NOT verify the event signature!**
     */
public static func fromJson(json: String)throws  -> ClientMessage  {
    return try  FfiConverterTypeClientMessage_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    
    /**
     * Create new `REQ` message
     */
public static func req(subscriptionId: String, filter: Filter) -> ClientMessage  {
    return try!  FfiConverterTypeClientMessage_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_clientmessage_req(
        FfiConverterString.lower(subscriptionId),
        FfiConverterTypeFilter_lower(filter),$0
    )
})
}
    

    
    /**
     * Clone `ClientMessage` and convert it to `ClientMessageEnum`
     */
open func asEnum() -> ClientMessageEnum  {
    return try!  FfiConverterTypeClientMessageEnum_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientmessage_as_enum(self.uniffiClonePointer(),$0
    )
})
}
    
open func asJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_clientmessage_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: ClientMessage, other: ClientMessage) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeClientMessage_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientmessage_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension ClientMessage: CustomDebugStringConvertible {}
extension ClientMessage: Equatable {}
extension ClientMessage: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientMessage: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientMessage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientMessage {
        return ClientMessage(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientMessage) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientMessage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientMessage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientMessage_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientMessage {
    return try FfiConverterTypeClientMessage.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientMessage_lower(_ value: ClientMessage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientMessage.lower(value)
}






/**
 * Nostr client options
 */
public protocol ClientOptionsProtocol: AnyObject, Sendable {
    
    /**
     * Automatically start connection with relays (default: false)
     *
     * When set to `true`, there isn't the need of calling the connect methods.
     */
    func autoconnect(val: Bool)  -> ClientOptions
    
    /**
     * Auto authenticate to relays (default: true)
     *
     * <https://github.com/nostr-protocol/nips/blob/master/42.md>
     */
    func automaticAuthentication(enabled: Bool)  -> ClientOptions
    
    /**
     * If true, ban a relay when it sends an event that doesn't match the subscription filter.
     */
    func banRelayOnMismatch(enable: Bool)  -> ClientOptions
    
    /**
     * Connection
     */
    func connection(connection: Connection)  -> ClientOptions
    
    /**
     * Gossip options
     */
    func gossip(opts: GossipOptions)  -> ClientOptions
    
    /**
     * Set max latency (default: None)
     *
     * Relays with an avg. latency greater that this value will be skipped.
     */
    func maxAvgLatency(max: TimeInterval)  -> ClientOptions
    
    /**
     * Set custom relay limits
     */
    func relayLimits(limits: RelayLimits)  -> ClientOptions
    
    /**
     * Verify that received events belong to a subscription and match the filter.
     */
    func verifySubscriptions(enable: Bool)  -> ClientOptions
    
}
/**
 * Nostr client options
 */
open class ClientOptions: ClientOptionsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_clientoptions(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_clientoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_clientoptions(pointer, $0) }
    }

    

    
    /**
     * Automatically start connection with relays (default: false)
     *
     * When set to `true`, there isn't the need of calling the connect methods.
     */
open func autoconnect(val: Bool) -> ClientOptions  {
    return try!  FfiConverterTypeClientOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientoptions_autoconnect(self.uniffiClonePointer(),
        FfiConverterBool.lower(val),$0
    )
})
}
    
    /**
     * Auto authenticate to relays (default: true)
     *
     * <https://github.com/nostr-protocol/nips/blob/master/42.md>
     */
open func automaticAuthentication(enabled: Bool) -> ClientOptions  {
    return try!  FfiConverterTypeClientOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientoptions_automatic_authentication(self.uniffiClonePointer(),
        FfiConverterBool.lower(enabled),$0
    )
})
}
    
    /**
     * If true, ban a relay when it sends an event that doesn't match the subscription filter.
     */
open func banRelayOnMismatch(enable: Bool) -> ClientOptions  {
    return try!  FfiConverterTypeClientOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientoptions_ban_relay_on_mismatch(self.uniffiClonePointer(),
        FfiConverterBool.lower(enable),$0
    )
})
}
    
    /**
     * Connection
     */
open func connection(connection: Connection) -> ClientOptions  {
    return try!  FfiConverterTypeClientOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientoptions_connection(self.uniffiClonePointer(),
        FfiConverterTypeConnection_lower(connection),$0
    )
})
}
    
    /**
     * Gossip options
     */
open func gossip(opts: GossipOptions) -> ClientOptions  {
    return try!  FfiConverterTypeClientOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientoptions_gossip(self.uniffiClonePointer(),
        FfiConverterTypeGossipOptions_lower(opts),$0
    )
})
}
    
    /**
     * Set max latency (default: None)
     *
     * Relays with an avg. latency greater that this value will be skipped.
     */
open func maxAvgLatency(max: TimeInterval) -> ClientOptions  {
    return try!  FfiConverterTypeClientOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientoptions_max_avg_latency(self.uniffiClonePointer(),
        FfiConverterDuration.lower(max),$0
    )
})
}
    
    /**
     * Set custom relay limits
     */
open func relayLimits(limits: RelayLimits) -> ClientOptions  {
    return try!  FfiConverterTypeClientOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientoptions_relay_limits(self.uniffiClonePointer(),
        FfiConverterTypeRelayLimits_lower(limits),$0
    )
})
}
    
    /**
     * Verify that received events belong to a subscription and match the filter.
     */
open func verifySubscriptions(enable: Bool) -> ClientOptions  {
    return try!  FfiConverterTypeClientOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_clientoptions_verify_subscriptions(self.uniffiClonePointer(),
        FfiConverterBool.lower(enable),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientOptions {
        return ClientOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientOptions {
    return try FfiConverterTypeClientOptions.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientOptions_lower(_ value: ClientOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientOptions.lower(value)
}






/**
 * Connection
 */
public protocol ConnectionProtocol: AnyObject, Sendable {
    
    /**
     * Set proxy (ex. `127.0.0.1:9050`)
     */
    func addr(addr: String) throws  -> Connection
    
    /**
     * Set connection mode (default: direct)
     */
    func mode(mode: ConnectionMode) throws  -> Connection
    
    /**
     * Set connection target (default: all)
     */
    func target(target: ConnectionTarget)  -> Connection
    
}
/**
 * Connection
 */
open class Connection: ConnectionProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_connection(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_connection_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_connection(pointer, $0) }
    }

    

    
    /**
     * Set proxy (ex. `127.0.0.1:9050`)
     */
open func addr(addr: String)throws  -> Connection  {
    return try  FfiConverterTypeConnection_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_connection_addr(self.uniffiClonePointer(),
        FfiConverterString.lower(addr),$0
    )
})
}
    
    /**
     * Set connection mode (default: direct)
     */
open func mode(mode: ConnectionMode)throws  -> Connection  {
    return try  FfiConverterTypeConnection_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_connection_mode(self.uniffiClonePointer(),
        FfiConverterTypeConnectionMode_lower(mode),$0
    )
})
}
    
    /**
     * Set connection target (default: all)
     */
open func target(target: ConnectionTarget) -> Connection  {
    return try!  FfiConverterTypeConnection_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_connection_target(self.uniffiClonePointer(),
        FfiConverterTypeConnectionTarget_lower(target),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Connection, other: Connection) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeConnection_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_connection_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Connection: CustomDebugStringConvertible {}
extension Connection: Equatable {}
extension Connection: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnection: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Connection

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Connection {
        return Connection(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Connection) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Connection {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Connection, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnection_lift(_ pointer: UnsafeMutableRawPointer) throws -> Connection {
    return try FfiConverterTypeConnection.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnection_lower(_ value: Connection) -> UnsafeMutableRawPointer {
    return FfiConverterTypeConnection.lower(value)
}






/**
 * Coordinate for event (`a` tag)
 */
public protocol CoordinateProtocol: AnyObject, Sendable {
    
    func identifier()  -> String
    
    func kind()  -> Kind
    
    func publicKey()  -> PublicKey
    
    /**
     * Check if the coordinate is valid.
     *
     * Returns `false` if:
     * - the `Kind` is `replaceable` and the identifier is not empty
     * - the `Kind` is `addressable` and the identifier is empty
     */
    func verify()  -> Bool
    
}
/**
 * Coordinate for event (`a` tag)
 */
open class Coordinate: CoordinateProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_coordinate(self.pointer, $0) }
    }
public convenience init(kind: Kind, publicKey: PublicKey, identifier: String = "") {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_coordinate_new(
        FfiConverterTypeKind_lower(kind),
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterString.lower(identifier),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_coordinate(pointer, $0) }
    }

    
public static func parse(coordinate: String)throws  -> Coordinate  {
    return try  FfiConverterTypeCoordinate_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_coordinate_parse(
        FfiConverterString.lower(coordinate),$0
    )
})
}
    

    
open func identifier() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_coordinate_identifier(self.uniffiClonePointer(),$0
    )
})
}
    
open func kind() -> Kind  {
    return try!  FfiConverterTypeKind_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_coordinate_kind(self.uniffiClonePointer(),$0
    )
})
}
    
open func publicKey() -> PublicKey  {
    return try!  FfiConverterTypePublicKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_coordinate_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if the coordinate is valid.
     *
     * Returns `false` if:
     * - the `Kind` is `replaceable` and the identifier is not empty
     * - the `Kind` is `addressable` and the identifier is empty
     */
open func verify() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_coordinate_verify(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Coordinate, other: Coordinate) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeCoordinate_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_coordinate_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Coordinate: CustomDebugStringConvertible {}
extension Coordinate: CustomStringConvertible {}
extension Coordinate: Equatable {}
extension Coordinate: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCoordinate: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Coordinate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Coordinate {
        return Coordinate(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Coordinate) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Coordinate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Coordinate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoordinate_lift(_ pointer: UnsafeMutableRawPointer) throws -> Coordinate {
    return try FfiConverterTypeCoordinate.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoordinate_lower(_ value: Coordinate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCoordinate.lower(value)
}






public protocol CustomNostrDatabase: AnyObject, Sendable {
    
    /**
     * Name of backend
     */
    func backend()  -> String
    
    /**
     * Save [`Event`] into store
     *
     * **This method assumes that [`Event`] was already verified**
     */
    func saveEvent(event: Event) async throws  -> SaveEventStatus?
    
    /**
     * Check event status by ID
     *
     * Check if the event is saved, deleted or not existent.
     */
    func checkId(eventId: EventId) async throws  -> DatabaseEventStatus
    
    /**
     * Get event by ID
     */
    func eventById(eventId: EventId) async throws  -> Event?
    
    /**
     * Count the number of [`Event`] found by filter
     *
     * Use `Filter::new()` or `Filter::default()` to count all events.
     */
    func count(filters: Filter) async throws  -> UInt64
    
    /**
     * Query store with filter
     */
    func query(filter: Filter) async throws  -> [Event]
    
    /**
     * Delete all events that match the `Filter`
     */
    func delete(filter: Filter) async throws 
    
    /**
     * Wipe all data
     */
    func wipe() async throws 
    
}
open class CustomNostrDatabaseImpl: CustomNostrDatabase, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_customnostrdatabase(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_customnostrdatabase(pointer, $0) }
    }

    

    
    /**
     * Name of backend
     */
open func backend() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_backend(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Save [`Event`] into store
     *
     * **This method assumes that [`Event`] was already verified**
     */
open func saveEvent(event: Event)async throws  -> SaveEventStatus?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_save_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeSaveEventStatus.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Check event status by ID
     *
     * Check if the event is saved, deleted or not existent.
     */
open func checkId(eventId: EventId)async throws  -> DatabaseEventStatus  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_check_id(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeDatabaseEventStatus_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Get event by ID
     */
open func eventById(eventId: EventId)async throws  -> Event?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_event_by_id(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Count the number of [`Event`] found by filter
     *
     * Use `Filter::new()` or `Filter::default()` to count all events.
     */
open func count(filters: Filter)async throws  -> UInt64  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_count(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filters)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Query store with filter
     */
open func query(filter: Filter)async throws  -> [Event]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_query(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Delete all events that match the `Filter`
     */
open func delete(filter: Filter)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_delete(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Wipe all data
     */
open func wipe()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrdatabase_wipe(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceCustomNostrDatabase {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceCustomNostrDatabase] = [UniffiVTableCallbackInterfaceCustomNostrDatabase(
        backend: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> String in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.backend(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        saveEvent: { (
            uniffiHandle: UInt64,
            event: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> SaveEventStatus? in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveEvent(
                     event: try FfiConverterTypeEvent_lift(event)
                )
            }

            let uniffiHandleSuccess = { (returnValue: SaveEventStatus?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeSaveEventStatus.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        checkId: { (
            uniffiHandle: UInt64,
            eventId: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> DatabaseEventStatus in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.checkId(
                     eventId: try FfiConverterTypeEventId_lift(eventId)
                )
            }

            let uniffiHandleSuccess = { (returnValue: DatabaseEventStatus) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeDatabaseEventStatus_lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        eventById: { (
            uniffiHandle: UInt64,
            eventId: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Event? in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.eventById(
                     eventId: try FfiConverterTypeEventId_lift(eventId)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Event?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeEvent.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        count: { (
            uniffiHandle: UInt64,
            filters: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteU64,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> UInt64 in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.count(
                     filters: try FfiConverterTypeFilter_lift(filters)
                )
            }

            let uniffiHandleSuccess = { (returnValue: UInt64) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructU64(
                        returnValue: FfiConverterUInt64.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructU64(
                        returnValue: 0,
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        query: { (
            uniffiHandle: UInt64,
            filter: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Event] in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.query(
                     filter: try FfiConverterTypeFilter_lift(filter)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Event]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeEvent.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        delete: { (
            uniffiHandle: UInt64,
            filter: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.delete(
                     filter: try FfiConverterTypeFilter_lift(filter)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        wipe: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrDatabase.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.wipe(
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeCustomNostrDatabase.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface CustomNostrDatabase: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitCustomNostrDatabase() {
    uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customnostrdatabase(UniffiCallbackInterfaceCustomNostrDatabase.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCustomNostrDatabase: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<CustomNostrDatabase>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CustomNostrDatabase

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CustomNostrDatabase {
        return CustomNostrDatabaseImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CustomNostrDatabase) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CustomNostrDatabase {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CustomNostrDatabase, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCustomNostrDatabase_lift(_ pointer: UnsafeMutableRawPointer) throws -> CustomNostrDatabase {
    return try FfiConverterTypeCustomNostrDatabase.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCustomNostrDatabase_lower(_ value: CustomNostrDatabase) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCustomNostrDatabase.lower(value)
}






public protocol CustomNostrSigner: AnyObject, Sendable {
    
    func backend()  -> SignerBackend
    
    /**
     * Get signer public key
     */
    func getPublicKey() async throws  -> PublicKey?
    
    /**
     * Sign an unsigned event
     */
    func signEvent(unsignedEvent: UnsignedEvent) async throws  -> Event?
    
    /**
     * NIP04 encrypt (deprecate and unsecure)
     */
    func nip04Encrypt(publicKey: PublicKey, content: String) async throws  -> String
    
    /**
     * NIP04 decrypt
     */
    func nip04Decrypt(publicKey: PublicKey, encryptedContent: String) async throws  -> String
    
    /**
     * NIP44 encrypt
     */
    func nip44Encrypt(publicKey: PublicKey, content: String) async throws  -> String
    
    /**
     * NIP44 decrypt
     */
    func nip44Decrypt(publicKey: PublicKey, payload: String) async throws  -> String
    
}
open class CustomNostrSignerImpl: CustomNostrSigner, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_customnostrsigner(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_customnostrsigner(pointer, $0) }
    }

    

    
open func backend() -> SignerBackend  {
    return try!  FfiConverterTypeSignerBackend_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_backend(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get signer public key
     */
open func getPublicKey()async throws  -> PublicKey?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_get_public_key(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypePublicKey.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Sign an unsigned event
     */
open func signEvent(unsignedEvent: UnsignedEvent)async throws  -> Event?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_sign_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUnsignedEvent_lower(unsignedEvent)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * NIP04 encrypt (deprecate and unsecure)
     */
open func nip04Encrypt(publicKey: PublicKey, content: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip04_encrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * NIP04 decrypt
     */
open func nip04Decrypt(publicKey: PublicKey, encryptedContent: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip04_decrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(encryptedContent)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * NIP44 encrypt
     */
open func nip44Encrypt(publicKey: PublicKey, content: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip44_encrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * NIP44 decrypt
     */
open func nip44Decrypt(publicKey: PublicKey, payload: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customnostrsigner_nip44_decrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(payload)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceCustomNostrSigner {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceCustomNostrSigner] = [UniffiVTableCallbackInterfaceCustomNostrSigner(
        backend: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> SignerBackend in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.backend(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeSignerBackend_lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        getPublicKey: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> PublicKey? in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getPublicKey(
                )
            }

            let uniffiHandleSuccess = { (returnValue: PublicKey?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypePublicKey.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        signEvent: { (
            uniffiHandle: UInt64,
            unsignedEvent: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Event? in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.signEvent(
                     unsignedEvent: try FfiConverterTypeUnsignedEvent_lift(unsignedEvent)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Event?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeEvent.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        nip04Encrypt: { (
            uniffiHandle: UInt64,
            publicKey: UnsafeMutableRawPointer,
            content: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.nip04Encrypt(
                     publicKey: try FfiConverterTypePublicKey_lift(publicKey),
                     content: try FfiConverterString.lift(content)
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        nip04Decrypt: { (
            uniffiHandle: UInt64,
            publicKey: UnsafeMutableRawPointer,
            encryptedContent: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.nip04Decrypt(
                     publicKey: try FfiConverterTypePublicKey_lift(publicKey),
                     encryptedContent: try FfiConverterString.lift(encryptedContent)
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        nip44Encrypt: { (
            uniffiHandle: UInt64,
            publicKey: UnsafeMutableRawPointer,
            content: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.nip44Encrypt(
                     publicKey: try FfiConverterTypePublicKey_lift(publicKey),
                     content: try FfiConverterString.lift(content)
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        nip44Decrypt: { (
            uniffiHandle: UInt64,
            publicKey: UnsafeMutableRawPointer,
            payload: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeCustomNostrSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.nip44Decrypt(
                     publicKey: try FfiConverterTypePublicKey_lift(publicKey),
                     payload: try FfiConverterString.lift(payload)
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeCustomNostrSigner.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface CustomNostrSigner: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitCustomNostrSigner() {
    uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customnostrsigner(UniffiCallbackInterfaceCustomNostrSigner.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCustomNostrSigner: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<CustomNostrSigner>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CustomNostrSigner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CustomNostrSigner {
        return CustomNostrSignerImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CustomNostrSigner) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CustomNostrSigner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CustomNostrSigner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCustomNostrSigner_lift(_ pointer: UnsafeMutableRawPointer) throws -> CustomNostrSigner {
    return try FfiConverterTypeCustomNostrSigner.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCustomNostrSigner_lower(_ value: CustomNostrSigner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCustomNostrSigner.lower(value)
}






public protocol CustomWebSocketTransport: AnyObject, Sendable {
    
    /**
     * If returns `true`, the WebSocket implementation must handle and forward the PING/PONG messages.
     * The ping is used by the SDK,
     * for example, to calculate the average latency or to make sure the relay is still connected.
     */
    func supportPing()  -> Bool
    
    /**
     * Connect to a relay
     */
    func connect(url: String, mode: ConnectionMode, timeout: TimeInterval) async throws  -> WebSocketAdapterWrapper?
    
}
open class CustomWebSocketTransportImpl: CustomWebSocketTransport, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_customwebsockettransport(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_customwebsockettransport(pointer, $0) }
    }

    

    
    /**
     * If returns `true`, the WebSocket implementation must handle and forward the PING/PONG messages.
     * The ping is used by the SDK,
     * for example, to calculate the average latency or to make sure the relay is still connected.
     */
open func supportPing() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_customwebsockettransport_support_ping(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Connect to a relay
     */
open func connect(url: String, mode: ConnectionMode, timeout: TimeInterval)async throws  -> WebSocketAdapterWrapper?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_customwebsockettransport_connect(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterTypeConnectionMode_lower(mode),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeWebSocketAdapterWrapper.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceCustomWebSocketTransport {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceCustomWebSocketTransport] = [UniffiVTableCallbackInterfaceCustomWebSocketTransport(
        supportPing: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterTypeCustomWebSocketTransport.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.supportPing(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        connect: { (
            uniffiHandle: UInt64,
            url: RustBuffer,
            mode: RustBuffer,
            timeout: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> WebSocketAdapterWrapper? in
                guard let uniffiObj = try? FfiConverterTypeCustomWebSocketTransport.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.connect(
                     url: try FfiConverterString.lift(url),
                     mode: try FfiConverterTypeConnectionMode_lift(mode),
                     timeout: try FfiConverterDuration.lift(timeout)
                )
            }

            let uniffiHandleSuccess = { (returnValue: WebSocketAdapterWrapper?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeWebSocketAdapterWrapper.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeCustomWebSocketTransport.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface CustomWebSocketTransport: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitCustomWebSocketTransport() {
    uniffi_nostr_sdk_ffi_fn_init_callback_vtable_customwebsockettransport(UniffiCallbackInterfaceCustomWebSocketTransport.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCustomWebSocketTransport: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<CustomWebSocketTransport>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CustomWebSocketTransport

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CustomWebSocketTransport {
        return CustomWebSocketTransportImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CustomWebSocketTransport) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CustomWebSocketTransport {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CustomWebSocketTransport, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCustomWebSocketTransport_lift(_ pointer: UnsafeMutableRawPointer) throws -> CustomWebSocketTransport {
    return try FfiConverterTypeCustomWebSocketTransport.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCustomWebSocketTransport_lower(_ value: CustomWebSocketTransport) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCustomWebSocketTransport.lower(value)
}






/**
 * Encrypted Secret Key
 */
public protocol EncryptedSecretKeyProtocol: AnyObject, Sendable {
    
    /**
     * Decrypt secret key
     */
    func decrypt(password: String) throws  -> SecretKey
    
    /**
     * Get encrypted secret key security
     */
    func keySecurity()  -> KeySecurity
    
    func toBech32() throws  -> String
    
    /**
     * Get encrypted secret key version
     */
    func version()  -> EncryptedSecretKeyVersion
    
}
/**
 * Encrypted Secret Key
 */
open class EncryptedSecretKey: EncryptedSecretKeyProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_encryptedsecretkey(self.pointer, $0) }
    }
    /**
     * Encrypt secret key
     */
public convenience init(secretKey: SecretKey, password: String, logN: UInt8, keySecurity: KeySecurity)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_encryptedsecretkey_new(
        FfiConverterTypeSecretKey_lower(secretKey),
        FfiConverterString.lower(password),
        FfiConverterUInt8.lower(logN),
        FfiConverterTypeKeySecurity_lower(keySecurity),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_encryptedsecretkey(pointer, $0) }
    }

    
public static func fromBech32(bech32: String)throws  -> EncryptedSecretKey  {
    return try  FfiConverterTypeEncryptedSecretKey_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_encryptedsecretkey_from_bech32(
        FfiConverterString.lower(bech32),$0
    )
})
}
    

    
    /**
     * Decrypt secret key
     */
open func decrypt(password: String)throws  -> SecretKey  {
    return try  FfiConverterTypeSecretKey_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_decrypt(self.uniffiClonePointer(),
        FfiConverterString.lower(password),$0
    )
})
}
    
    /**
     * Get encrypted secret key security
     */
open func keySecurity() -> KeySecurity  {
    return try!  FfiConverterTypeKeySecurity_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_key_security(self.uniffiClonePointer(),$0
    )
})
}
    
open func toBech32()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_to_bech32(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get encrypted secret key version
     */
open func version() -> EncryptedSecretKeyVersion  {
    return try!  FfiConverterTypeEncryptedSecretKeyVersion_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_version(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: EncryptedSecretKey, other: EncryptedSecretKey) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeEncryptedSecretKey_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_encryptedsecretkey_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension EncryptedSecretKey: CustomDebugStringConvertible {}
extension EncryptedSecretKey: Equatable {}
extension EncryptedSecretKey: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEncryptedSecretKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EncryptedSecretKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EncryptedSecretKey {
        return EncryptedSecretKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EncryptedSecretKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedSecretKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EncryptedSecretKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryptedSecretKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> EncryptedSecretKey {
    return try FfiConverterTypeEncryptedSecretKey.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryptedSecretKey_lower(_ value: EncryptedSecretKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEncryptedSecretKey.lower(value)
}






public protocol EventProtocol: AnyObject, Sendable {
    
    func asJson() throws  -> String
    
    func asPrettyJson() throws  -> String
    
    /**
     * Get event author (`pubkey` field)
     */
    func author()  -> PublicKey
    
    func content()  -> String
    
    func createdAt()  -> Timestamp
    
    func id()  -> EventId
    
    /**
     * Returns `true` if the event has an expiration tag that is expired.
     * If an event has no expiration tag, then it will return `false`.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/40.md>
     */
    func isExpired()  -> Bool
    
    /**
     * Check if it's a protected event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/70.md>
     */
    func isProtected()  -> Bool
    
    func kind()  -> Kind
    
    func signature()  -> String
    
    func tags()  -> Tags
    
    /**
     * Verify both `EventId` and `Signature`
     */
    func verify()  -> Bool
    
    /**
     * Verify if the `EventId` it's composed correctly
     */
    func verifyId()  -> Bool
    
    /**
     * Verify only event `Signature`
     */
    func verifySignature()  -> Bool
    
}
open class Event: EventProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_event(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_event(pointer, $0) }
    }

    
public static func fromJson(json: String)throws  -> Event  {
    return try  FfiConverterTypeEvent_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_event_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    

    
open func asJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_event_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
open func asPrettyJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_event_as_pretty_json(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get event author (`pubkey` field)
     */
open func author() -> PublicKey  {
    return try!  FfiConverterTypePublicKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_event_author(self.uniffiClonePointer(),$0
    )
})
}
    
open func content() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_event_content(self.uniffiClonePointer(),$0
    )
})
}
    
open func createdAt() -> Timestamp  {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_event_created_at(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> EventId  {
    return try!  FfiConverterTypeEventId_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_event_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns `true` if the event has an expiration tag that is expired.
     * If an event has no expiration tag, then it will return `false`.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/40.md>
     */
open func isExpired() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_event_is_expired(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if it's a protected event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/70.md>
     */
open func isProtected() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_event_is_protected(self.uniffiClonePointer(),$0
    )
})
}
    
open func kind() -> Kind  {
    return try!  FfiConverterTypeKind_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_event_kind(self.uniffiClonePointer(),$0
    )
})
}
    
open func signature() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_event_signature(self.uniffiClonePointer(),$0
    )
})
}
    
open func tags() -> Tags  {
    return try!  FfiConverterTypeTags_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_event_tags(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Verify both `EventId` and `Signature`
     */
open func verify() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_event_verify(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Verify if the `EventId` it's composed correctly
     */
open func verifyId() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_event_verify_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Verify only event `Signature`
     */
open func verifySignature() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_event_verify_signature(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Event, other: Event) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeEvent_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_event_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Event: CustomDebugStringConvertible {}
extension Event: Equatable {}
extension Event: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEvent: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Event

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Event {
        return Event(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Event) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Event, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEvent_lift(_ pointer: UnsafeMutableRawPointer) throws -> Event {
    return try FfiConverterTypeEvent.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEvent_lower(_ value: Event) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEvent.lower(value)
}






public protocol EventBuilderProtocol: AnyObject, Sendable {
    
    /**
     * Allow self-tagging
     *
     * When this mode is enabled, any `p` tags referencing the authors public key will not be discarded.
     */
    func allowSelfTagging()  -> EventBuilder
    
    /**
     * Build an unsigned event
     *
     * By default, this method removes any `p` tags that match the author's public key.
     * To allow self-tagging, call [`EventBuilder::allow_self_tagging`] first.
     */
    func build(publicKey: PublicKey)  -> UnsignedEvent
    
    /**
     * Set a custom `created_at` UNIX timestamp
     */
    func customCreatedAt(createdAt: Timestamp)  -> EventBuilder
    
    /**
     * Deduplicate tags
     *
     * For more details check [`Tags::dedup`].
     */
    func dedupTags()  -> EventBuilder
    
    /**
     * Set POW difficulty
     *
     * Only values `> 0` are accepted!
     */
    func pow(difficulty: UInt8)  -> EventBuilder
    
    /**
     * Build, sign and return [`Event`]
     *
     * Check [`EventBuilder::build`] to learn more.
     */
    func sign(signer: NostrSigner) async throws  -> Event
    
    /**
     * Build, sign and return [`Event`] using [`Keys`] signer
     *
     * Check [`EventBuilder::build`] to learn more.
     */
    func signWithKeys(keys: Keys) throws  -> Event
    
    /**
     * Add tags
     *
     * This method extend the current tags (if any).
     */
    func tags(tags: [Tag])  -> EventBuilder
    
}
open class EventBuilder: EventBuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_eventbuilder(self.pointer, $0) }
    }
public convenience init(kind: Kind, content: String) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_new(
        FfiConverterTypeKind_lower(kind),
        FfiConverterString.lower(content),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_eventbuilder(pointer, $0) }
    }

    
    /**
     * Article Curation set
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func articlesCurationSet(identifier: String, list: ArticlesCuration) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_articles_curation_set(
        FfiConverterString.lower(identifier),
        FfiConverterTypeArticlesCuration_lower(list),$0
    )
})
}
    
    /**
     * Authentication of clients to relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/42.md>
     */
public static func auth(challenge: String, relayUrl: RelayUrl)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_auth(
        FfiConverterString.lower(challenge),
        FfiConverterTypeRelayUrl_lower(relayUrl),$0
    )
})
}
    
    /**
     * Badge award
     *
     * <https://github.com/nostr-protocol/nips/blob/master/58.md>
     */
public static func awardBadge(badgeDefinition: Event, awardedPublicKeys: [PublicKey])throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_award_badge(
        FfiConverterTypeEvent_lower(badgeDefinition),
        FfiConverterSequenceTypePublicKey.lower(awardedPublicKeys),$0
    )
})
}
    
    /**
     * Blocked relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func blockedRelays(relay: [RelayUrl]) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_blocked_relays(
        FfiConverterSequenceTypeRelayUrl.lower(relay),$0
    )
})
}
    
    /**
     * Bookmarks
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func bookmarks(list: Bookmarks)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_bookmarks(
        FfiConverterTypeBookmarks_lower(list),$0
    )
})
}
    
    /**
     * Bookmark set
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func bookmarksSet(identifier: String, list: Bookmarks)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_bookmarks_set(
        FfiConverterString.lower(identifier),
        FfiConverterTypeBookmarks_lower(list),$0
    )
})
}
    
    /**
     * Create new channel
     *
     * <https://github.com/nostr-protocol/nips/blob/master/28.md>
     */
public static func channel(metadata: Metadata) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_channel(
        FfiConverterTypeMetadata_lower(metadata),$0
    )
})
}
    
    /**
     * Channel metadata
     *
     * <https://github.com/nostr-protocol/nips/blob/master/28.md>
     */
public static func channelMetadata(channelId: EventId, metadata: Metadata, relayUrl: RelayUrl? = nil)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_channel_metadata(
        FfiConverterTypeEventId_lower(channelId),
        FfiConverterTypeMetadata_lower(metadata),
        FfiConverterOptionTypeRelayUrl.lower(relayUrl),$0
    )
})
}
    
    /**
     * Channel message
     *
     * <https://github.com/nostr-protocol/nips/blob/master/28.md>
     */
public static func channelMsg(channelId: EventId, relayUrl: RelayUrl, content: String)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_channel_msg(
        FfiConverterTypeEventId_lower(channelId),
        FfiConverterTypeRelayUrl_lower(relayUrl),
        FfiConverterString.lower(content),$0
    )
})
}
    
    /**
     * Comment
     *
     * <https://github.com/nostr-protocol/nips/blob/master/22.md>
     */
public static func comment(content: String, commentTo: CommentTarget, root: CommentTarget? = nil)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_comment(
        FfiConverterString.lower(content),
        FfiConverterTypeCommentTarget_lower(commentTo),
        FfiConverterOptionTypeCommentTarget.lower(root),$0
    )
})
}
    
    /**
     * Communities
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func communities(communities: [Coordinate]) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_communities(
        FfiConverterSequenceTypeCoordinate.lower(communities),$0
    )
})
}
    
    /**
     * Contact/Follow list
     *
     * <https://github.com/nostr-protocol/nips/blob/master/02.md>
     */
public static func contactList(contacts: [Contact]) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_contact_list(
        FfiConverterSequenceTypeContact.lower(contacts),$0
    )
})
}
    
    /**
     * Badge definition
     *
     * <https://github.com/nostr-protocol/nips/blob/master/58.md>
     */
public static func defineBadge(badgeId: String, name: String? = nil, description: String? = nil, image: String? = nil, imageDimensions: ImageDimensions? = nil, thumbnails: [Image] = [])throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_define_badge(
        FfiConverterString.lower(badgeId),
        FfiConverterOptionString.lower(name),
        FfiConverterOptionString.lower(description),
        FfiConverterOptionString.lower(image),
        FfiConverterOptionTypeImageDimensions.lower(imageDimensions),
        FfiConverterSequenceTypeImage.lower(thumbnails),$0
    )
})
}
    
    /**
     * Event deletion request
     *
     * <https://github.com/nostr-protocol/nips/blob/master/09.md>
     */
public static func delete(request: EventDeletionRequest) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_delete(
        FfiConverterTypeEventDeletionRequest_lower(request),$0
    )
})
}
    
    /**
     * Emoji set
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func emojiSet(identifier: String, emojis: [EmojiInfo]) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_emoji_set(
        FfiConverterString.lower(identifier),
        FfiConverterSequenceTypeEmojiInfo.lower(emojis),$0
    )
})
}
    
    /**
     * Emojis
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func emojis(list: Emojis) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_emojis(
        FfiConverterTypeEmojis_lower(list),$0
    )
})
}
    
    /**
     * File metadata
     *
     * <https://github.com/nostr-protocol/nips/blob/master/94.md>
     */
public static func fileMetadata(description: String, metadata: FileMetadata) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_file_metadata(
        FfiConverterString.lower(description),
        FfiConverterTypeFileMetadata_lower(metadata),$0
    )
})
}
    
    /**
     * Follow set
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func followSet(identifier: String, publicKeys: [PublicKey]) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_follow_set(
        FfiConverterString.lower(identifier),
        FfiConverterSequenceTypePublicKey.lower(publicKeys),$0
    )
})
}
    
    /**
     * Git Issue
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
public static func gitIssue(issue: GitIssue)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_git_issue(
        FfiConverterTypeGitIssue_lower(issue),$0
    )
})
}
    
    /**
     * Git Patch
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
public static func gitPatch(patch: GitPatch)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_git_patch(
        FfiConverterTypeGitPatch_lower(patch),$0
    )
})
}
    
    /**
     * Git Repository Announcement
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
public static func gitRepositoryAnnouncement(data: GitRepositoryAnnouncement)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_git_repository_announcement(
        FfiConverterTypeGitRepositoryAnnouncement_lower(data),$0
    )
})
}
    
    /**
     * Hide message
     *
     * <https://github.com/nostr-protocol/nips/blob/master/28.md>
     */
public static func hideChannelMsg(messageId: EventId, reason: String? = nil) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_hide_channel_msg(
        FfiConverterTypeEventId_lower(messageId),
        FfiConverterOptionString.lower(reason),$0
    )
})
}
    
    /**
     * HTTP Auth
     *
     * <https://github.com/nostr-protocol/nips/blob/master/98.md>
     */
public static func httpAuth(data: HttpData)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_http_auth(
        FfiConverterTypeHttpData_lower(data),$0
    )
})
}
    
    /**
     * Interest set
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func interestSet(identifier: String, hashtags: [String]) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_interest_set(
        FfiConverterString.lower(identifier),
        FfiConverterSequenceString.lower(hashtags),$0
    )
})
}
    
    /**
     * Interests
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func interests(list: Interests) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_interests(
        FfiConverterTypeInterests_lower(list),$0
    )
})
}
    
    /**
     * Data Vending Machine (DVM) - Job Feedback
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
public static func jobFeedback(data: JobFeedbackData) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_job_feedback(
        FfiConverterTypeJobFeedbackData_lower(data),$0
    )
})
}
    
    /**
     * Data Vending Machine (DVM) - Job Request
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
public static func jobRequest(kind: Kind)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_job_request(
        FfiConverterTypeKind_lower(kind),$0
    )
})
}
    
    /**
     * Data Vending Machine (DVM) - Job Result
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
public static func jobResult(jobRequest: Event, payload: String, millisats: UInt64, bolt11: String? = nil)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_job_result(
        FfiConverterTypeEvent_lower(jobRequest),
        FfiConverterString.lower(payload),
        FfiConverterUInt64.lower(millisats),
        FfiConverterOptionString.lower(bolt11),$0
    )
})
}
    
    /**
     * Label
     *
     * <https://github.com/nostr-protocol/nips/blob/master/32.md>
     */
public static func label(labelNamespace: String, label: String) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_label(
        FfiConverterString.lower(labelNamespace),
        FfiConverterString.lower(label),$0
    )
})
}
    
    /**
     * Live Event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/53.md>
     */
public static func liveEvent(liveEvent: LiveEvent)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_live_event(
        FfiConverterTypeLiveEvent_lower(liveEvent),$0
    )
})
}
    
    /**
     * Live Event Message
     *
     * <https://github.com/nostr-protocol/nips/blob/master/53.md>
     */
public static func liveEventMsg(liveEventId: String, liveEventHost: PublicKey, content: String, relayUrl: RelayUrl? = nil)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_live_event_msg(
        FfiConverterString.lower(liveEventId),
        FfiConverterTypePublicKey_lower(liveEventHost),
        FfiConverterString.lower(content),
        FfiConverterOptionTypeRelayUrl.lower(relayUrl),$0
    )
})
}
    
    /**
     * Long-form text note (generally referred to as "articles" or "blog posts").
     *
     * <https://github.com/nostr-protocol/nips/blob/master/23.md>
     */
public static func longFormTextNote(content: String) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_long_form_text_note(
        FfiConverterString.lower(content),$0
    )
})
}
    
    /**
     * Profile metadata
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
public static func metadata(metadata: Metadata) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_metadata(
        FfiConverterTypeMetadata_lower(metadata),$0
    )
})
}
    
    /**
     * Mute channel user
     *
     * <https://github.com/nostr-protocol/nips/blob/master/28.md>
     */
public static func muteChannelUser(publicKey: PublicKey, reason: String? = nil) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_mute_channel_user(
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterOptionString.lower(reason),$0
    )
})
}
    
    /**
     * Mute list
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func muteList(list: MuteList) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_mute_list(
        FfiConverterTypeMuteList_lower(list),$0
    )
})
}
    
    /**
     * Nostr Connect / Nostr Remote Signing
     *
     * <https://github.com/nostr-protocol/nips/blob/master/46.md>
     */
public static func nostrConnect(senderKeys: Keys, receiverPubkey: PublicKey, msg: NostrConnectMessage)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_nostr_connect(
        FfiConverterTypeKeys_lower(senderKeys),
        FfiConverterTypePublicKey_lower(receiverPubkey),
        FfiConverterTypeNostrConnectMessage_lower(msg),$0
    )
})
}
    
    /**
     * Pinned notes
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func pinnedNotes(ids: [EventId]) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_pinned_notes(
        FfiConverterSequenceTypeEventId.lower(ids),$0
    )
})
}
    
    /**
     * Private Direct message rumor
     *
     * <div class="warning">
     * This constructor compose ONLY the rumor for the private direct message!
     * NOT USE THIS IF YOU DON'T KNOW WHAT YOU ARE DOING!
     * </div>
     *
     * <https://github.com/nostr-protocol/nips/blob/master/17.md>
     */
public static func privateMsgRumor(receiver: PublicKey, message: String) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_private_msg_rumor(
        FfiConverterTypePublicKey_lower(receiver),
        FfiConverterString.lower(message),$0
    )
})
}
    
    /**
     * Set product data
     *
     * <https://github.com/nostr-protocol/nips/blob/master/15.md>
     */
public static func productData(data: ProductData) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_product_data(
        FfiConverterTypeProductData_lower(data),$0
    )
})
}
    
    /**
     * Profile badges
     *
     * <https://github.com/nostr-protocol/nips/blob/master/58.md>
     */
public static func profileBadges(badgeDefinitions: [Event], badgeAwards: [Event], pubkeyAwarded: PublicKey)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_profile_badges(
        FfiConverterSequenceTypeEvent.lower(badgeDefinitions),
        FfiConverterSequenceTypeEvent.lower(badgeAwards),
        FfiConverterTypePublicKey_lower(pubkeyAwarded),$0
    )
})
}
    
    /**
     * Public chats
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func publicChats(chat: [EventId]) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_public_chats(
        FfiConverterSequenceTypeEventId.lower(chat),$0
    )
})
}
    
    /**
     * Create **public** zap request event
     *
     * **This event MUST NOT be broadcasted to relays**, instead must be sent to a recipient's LNURL pay callback url.
     *
     * To build a **private** or **anonymous** zap request use `nip57_private_zap_request(...)` or `nip57_anonymous_zap_request(...)` functions.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/57.md>
     */
public static func publicZapRequest(data: ZapRequestData) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_public_zap_request(
        FfiConverterTypeZapRequestData_lower(data),$0
    )
})
}
    
    /**
     * Add reaction (like/upvote, dislike/downvote or emoji) to an event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/25.md>
     */
public static func reaction(event: Event, reaction: String) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_reaction(
        FfiConverterTypeEvent_lower(event),
        FfiConverterString.lower(reaction),$0
    )
})
}
    
    /**
     * Relay list metadata
     *
     * <https://github.com/nostr-protocol/nips/blob/master/65.md>
     */
public static func relayList(map: [RelayUrl: RelayMetadata?])throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_relay_list(
        FfiConverterDictionaryTypeRelayUrlOptionTypeRelayMetadata.lower(map),$0
    )
})
}
    
    /**
     * Relay set
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func relaySet(identifier: String, relays: [RelayUrl]) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_relay_set(
        FfiConverterString.lower(identifier),
        FfiConverterSequenceTypeRelayUrl.lower(relays),$0
    )
})
}
    
    /**
     * Reporting
     *
     * <https://github.com/nostr-protocol/nips/blob/master/56.md>
     */
public static func report(tags: [Tag], content: String) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_report(
        FfiConverterSequenceTypeTag.lower(tags),
        FfiConverterString.lower(content),$0
    )
})
}
    
    /**
     * Repost
     *
     * <https://github.com/nostr-protocol/nips/blob/master/18.md>
     */
public static func repost(event: Event, relayUrl: RelayUrl? = nil)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_repost(
        FfiConverterTypeEvent_lower(event),
        FfiConverterOptionTypeRelayUrl.lower(relayUrl),$0
    )
})
}
    
    /**
     * Seal
     *
     * <https://github.com/nostr-protocol/nips/blob/master/59.md>
     */
public static func seal(signer: NostrSigner, receiverPublicKey: PublicKey, rumor: UnsignedEvent)async throws  -> EventBuilder  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_seal(FfiConverterTypeNostrSigner_lower(signer),FfiConverterTypePublicKey_lower(receiverPublicKey),FfiConverterTypeUnsignedEvent_lower(rumor)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventBuilder_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Search relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func searchRelays(relay: [RelayUrl]) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_search_relays(
        FfiConverterSequenceTypeRelayUrl.lower(relay),$0
    )
})
}
    
    /**
     * Set stall data
     *
     * <https://github.com/nostr-protocol/nips/blob/master/15.md>
     */
public static func stallData(data: StallData) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_stall_data(
        FfiConverterTypeStallData_lower(data),$0
    )
})
}
    
    /**
     * Text note
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
public static func textNote(content: String) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_text_note(
        FfiConverterString.lower(content),$0
    )
})
}
    
    /**
     * Text note reply
     *
     * This adds only the most significant tags, like:
     * - `p` tag with the author of the `reply_to` and `root` events;
     * - `e` tag of the `reply_to` and `root` events.
     *
     * Any additional necessary tag can be added with [`EventBuilder::tag`] or [`EventBuilder::tags`].
     *
     * <https://github.com/nostr-protocol/nips/blob/master/10.md>
     */
public static func textNoteReply(content: String, replyTo: Event, root: Event? = nil, relayUrl: RelayUrl? = nil)throws  -> EventBuilder  {
    return try  FfiConverterTypeEventBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_text_note_reply(
        FfiConverterString.lower(content),
        FfiConverterTypeEvent_lower(replyTo),
        FfiConverterOptionTypeEvent.lower(root),
        FfiConverterOptionTypeRelayUrl.lower(relayUrl),$0
    )
})
}
    
    /**
     * Videos Curation set
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func videosCurationSet(identifier: String, video: [Coordinate]) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_videos_curation_set(
        FfiConverterString.lower(identifier),
        FfiConverterSequenceTypeCoordinate.lower(video),$0
    )
})
}
    
    /**
     * Zap Receipt
     *
     * <https://github.com/nostr-protocol/nips/blob/master/57.md>
     */
public static func zapReceipt(bolt11: String, preimage: String?, zapRequest: Event) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventbuilder_zap_receipt(
        FfiConverterString.lower(bolt11),
        FfiConverterOptionString.lower(preimage),
        FfiConverterTypeEvent_lower(zapRequest),$0
    )
})
}
    

    
    /**
     * Allow self-tagging
     *
     * When this mode is enabled, any `p` tags referencing the authors public key will not be discarded.
     */
open func allowSelfTagging() -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_eventbuilder_allow_self_tagging(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Build an unsigned event
     *
     * By default, this method removes any `p` tags that match the author's public key.
     * To allow self-tagging, call [`EventBuilder::allow_self_tagging`] first.
     */
open func build(publicKey: PublicKey) -> UnsignedEvent  {
    return try!  FfiConverterTypeUnsignedEvent_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_eventbuilder_build(self.uniffiClonePointer(),
        FfiConverterTypePublicKey_lower(publicKey),$0
    )
})
}
    
    /**
     * Set a custom `created_at` UNIX timestamp
     */
open func customCreatedAt(createdAt: Timestamp) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_eventbuilder_custom_created_at(self.uniffiClonePointer(),
        FfiConverterTypeTimestamp_lower(createdAt),$0
    )
})
}
    
    /**
     * Deduplicate tags
     *
     * For more details check [`Tags::dedup`].
     */
open func dedupTags() -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_eventbuilder_dedup_tags(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Set POW difficulty
     *
     * Only values `> 0` are accepted!
     */
open func pow(difficulty: UInt8) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_eventbuilder_pow(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
})
}
    
    /**
     * Build, sign and return [`Event`]
     *
     * Check [`EventBuilder::build`] to learn more.
     */
open func sign(signer: NostrSigner)async throws  -> Event  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_eventbuilder_sign(
                    self.uniffiClonePointer(),
                    FfiConverterTypeNostrSigner_lower(signer)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvent_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Build, sign and return [`Event`] using [`Keys`] signer
     *
     * Check [`EventBuilder::build`] to learn more.
     */
open func signWithKeys(keys: Keys)throws  -> Event  {
    return try  FfiConverterTypeEvent_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_eventbuilder_sign_with_keys(self.uniffiClonePointer(),
        FfiConverterTypeKeys_lower(keys),$0
    )
})
}
    
    /**
     * Add tags
     *
     * This method extend the current tags (if any).
     */
open func tags(tags: [Tag]) -> EventBuilder  {
    return try!  FfiConverterTypeEventBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_eventbuilder_tags(self.uniffiClonePointer(),
        FfiConverterSequenceTypeTag.lower(tags),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: EventBuilder, other: EventBuilder) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeEventBuilder_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_eventbuilder_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension EventBuilder: CustomDebugStringConvertible {}
extension EventBuilder: Equatable {}
extension EventBuilder: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEventBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBuilder {
    return try FfiConverterTypeEventBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventBuilder_lower(_ value: EventBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventBuilder.lower(value)
}






public protocol EventIdProtocol: AnyObject, Sendable {
    
    func asBytes()  -> Data
    
    func toBech32() throws  -> String
    
    func toHex()  -> String
    
    func toNostrUri() throws  -> String
    
}
open class EventId: EventIdProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_eventid(self.pointer, $0) }
    }
public convenience init(publicKey: PublicKey, createdAt: Timestamp, kind: Kind, tags: Tags, content: String) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_eventid_new(
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterTypeTimestamp_lower(createdAt),
        FfiConverterTypeKind_lower(kind),
        FfiConverterTypeTags_lower(tags),
        FfiConverterString.lower(content),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_eventid(pointer, $0) }
    }

    
public static func fromBytes(bytes: Data)throws  -> EventId  {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventid_from_bytes(
        FfiConverterData.lower(bytes),$0
    )
})
}
    
    /**
     * Try to parse event ID from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
     */
public static func parse(id: String)throws  -> EventId  {
    return try  FfiConverterTypeEventId_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_eventid_parse(
        FfiConverterString.lower(id),$0
    )
})
}
    

    
open func asBytes() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_eventid_as_bytes(self.uniffiClonePointer(),$0
    )
})
}
    
open func toBech32()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_eventid_to_bech32(self.uniffiClonePointer(),$0
    )
})
}
    
open func toHex() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_eventid_to_hex(self.uniffiClonePointer(),$0
    )
})
}
    
open func toNostrUri()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_eventid_to_nostr_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: EventId, other: EventId) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeEventId_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_eventid_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension EventId: CustomDebugStringConvertible {}
extension EventId: Equatable {}
extension EventId: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEventId: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventId

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventId {
        return EventId(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventId) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventId {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventId, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventId_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventId {
    return try FfiConverterTypeEventId.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventId_lower(_ value: EventId) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventId.lower(value)
}






public protocol EventStreamProtocol: AnyObject, Sendable {
    
    func next() async  -> Event?
    
}
open class EventStream: EventStreamProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_eventstream(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_eventstream(pointer, $0) }
    }

    

    
open func next()async  -> Event?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_eventstream_next(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeEvent.lift,
            errorHandler: nil
            
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEventStream: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventStream

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventStream {
        return EventStream(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventStream) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventStream {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventStream, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventStream_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventStream {
    return try FfiConverterTypeEventStream.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventStream_lower(_ value: EventStream) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventStream.lower(value)
}






public protocol EventsProtocol: AnyObject, Sendable {
    
    /**
     * Check if contains `Event`
     */
    func contains(event: Event)  -> Bool
    
    /**
     * Get first `Event` (descending order)
     */
    func first()  -> Event?
    
    /**
     * Returns the number of events in the collection.
     */
    func isEmpty()  -> Bool
    
    /**
     * Returns the number of events in the collection.
     */
    func len()  -> UInt64
    
    /**
     * Merge events collections into a single one.
     *
     * This method consumes the object, making it unavailable for further use.
     *
     * Collection is converted to unbounded if one of the merge `Events` has a different hash.
     * In other words, the filter limit is respected only if the `Events` are related to the same
     * list of filters.
     */
    func merge(other: Events) throws  -> Events
    
    /**
     * Convert the collection to vector of events.
     *
     * This method consumes the object, making it unavailable for further use.
     */
    func toVec() throws  -> [Event]
    
}
open class Events: EventsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_events(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_events(pointer, $0) }
    }

    

    
    /**
     * Check if contains `Event`
     */
open func contains(event: Event) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_events_contains(self.uniffiClonePointer(),
        FfiConverterTypeEvent_lower(event),$0
    )
})
}
    
    /**
     * Get first `Event` (descending order)
     */
open func first() -> Event?  {
    return try!  FfiConverterOptionTypeEvent.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_events_first(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the number of events in the collection.
     */
open func isEmpty() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_events_is_empty(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the number of events in the collection.
     */
open func len() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_events_len(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Merge events collections into a single one.
     *
     * This method consumes the object, making it unavailable for further use.
     *
     * Collection is converted to unbounded if one of the merge `Events` has a different hash.
     * In other words, the filter limit is respected only if the `Events` are related to the same
     * list of filters.
     */
open func merge(other: Events)throws  -> Events  {
    return try  FfiConverterTypeEvents_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_events_merge(self.uniffiClonePointer(),
        FfiConverterTypeEvents_lower(other),$0
    )
})
}
    
    /**
     * Convert the collection to vector of events.
     *
     * This method consumes the object, making it unavailable for further use.
     */
open func toVec()throws  -> [Event]  {
    return try  FfiConverterSequenceTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_events_to_vec(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEvents: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Events

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Events {
        return Events(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Events) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Events {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Events, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEvents_lift(_ pointer: UnsafeMutableRawPointer) throws -> Events {
    return try FfiConverterTypeEvents.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEvents_lower(_ value: Events) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEvents.lower(value)
}






public protocol FileMetadataProtocol: AnyObject, Sendable {
    
    func aes256Gcm(key: String, iv: String)  -> FileMetadata
    
    /**
     * Add blurhash
     */
    func blurhash(blurhash: String)  -> FileMetadata
    
    /**
     * Add file size (pixels)
     */
    func dimensions(dim: ImageDimensions)  -> FileMetadata
    
    /**
     * Add magnet
     */
    func magnet(magnet: String)  -> FileMetadata
    
    /**
     * Add file size (bytes)
     */
    func size(size: UInt64)  -> FileMetadata
    
}
open class FileMetadata: FileMetadataProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_filemetadata(self.pointer, $0) }
    }
public convenience init(url: String, mimeType: String, hash: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_filemetadata_new(
        FfiConverterString.lower(url),
        FfiConverterString.lower(mimeType),
        FfiConverterString.lower(hash),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_filemetadata(pointer, $0) }
    }

    

    
open func aes256Gcm(key: String, iv: String) -> FileMetadata  {
    return try!  FfiConverterTypeFileMetadata_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filemetadata_aes_256_gcm(self.uniffiClonePointer(),
        FfiConverterString.lower(key),
        FfiConverterString.lower(iv),$0
    )
})
}
    
    /**
     * Add blurhash
     */
open func blurhash(blurhash: String) -> FileMetadata  {
    return try!  FfiConverterTypeFileMetadata_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filemetadata_blurhash(self.uniffiClonePointer(),
        FfiConverterString.lower(blurhash),$0
    )
})
}
    
    /**
     * Add file size (pixels)
     */
open func dimensions(dim: ImageDimensions) -> FileMetadata  {
    return try!  FfiConverterTypeFileMetadata_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filemetadata_dimensions(self.uniffiClonePointer(),
        FfiConverterTypeImageDimensions_lower(dim),$0
    )
})
}
    
    /**
     * Add magnet
     */
open func magnet(magnet: String) -> FileMetadata  {
    return try!  FfiConverterTypeFileMetadata_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filemetadata_magnet(self.uniffiClonePointer(),
        FfiConverterString.lower(magnet),$0
    )
})
}
    
    /**
     * Add file size (bytes)
     */
open func size(size: UInt64) -> FileMetadata  {
    return try!  FfiConverterTypeFileMetadata_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filemetadata_size(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(size),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: FileMetadata, other: FileMetadata) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeFileMetadata_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filemetadata_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension FileMetadata: CustomDebugStringConvertible {}
extension FileMetadata: Equatable {}
extension FileMetadata: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFileMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FileMetadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FileMetadata {
        return FileMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FileMetadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FileMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> FileMetadata {
    return try FfiConverterTypeFileMetadata.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileMetadata_lower(_ value: FileMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFileMetadata.lower(value)
}






public protocol FilterProtocol: AnyObject, Sendable {
    
    func asJson() throws  -> String
    
    func asRecord()  -> FilterRecord
    
    /**
     * Add event author Public Key
     */
    func author(author: PublicKey)  -> Filter
    
    func authors(authors: [PublicKey])  -> Filter
    
    /**
     * Add coordinate
     *
     * Query for `a` tag.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func coordinate(coordinate: Coordinate)  -> Filter
    
    /**
     * Add coordinates
     *
     * Query for `a` tags.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func coordinates(coordinates: [Coordinate])  -> Filter
    
    func customTag(tag: SingleLetterTag, content: String)  -> Filter
    
    func customTags(tag: SingleLetterTag, contents: [String])  -> Filter
    
    /**
     * Add event ID (`e` tag)
     */
    func event(eventId: EventId)  -> Filter
    
    /**
     * Add event IDs (`e` tag)
     */
    func events(ids: [EventId])  -> Filter
    
    func hashtag(hashtag: String)  -> Filter
    
    func hashtags(hashtags: [String])  -> Filter
    
    func id(id: EventId)  -> Filter
    
    func identifier(identifier: String)  -> Filter
    
    func identifiers(identifiers: [String])  -> Filter
    
    func ids(ids: [EventId])  -> Filter
    
    func isEmpty()  -> Bool
    
    func kind(kind: Kind)  -> Filter
    
    func kinds(kinds: [Kind])  -> Filter
    
    func limit(limit: UInt64)  -> Filter
    
    /**
     * Determine if `Filter` match given `Event`.
     */
    func matchEvent(event: Event)  -> Bool
    
    /**
     * Add Public Key (`p` tag)
     */
    func pubkey(pubkey: PublicKey)  -> Filter
    
    /**
     * Add Public Keys (`p` tag)
     */
    func pubkeys(pubkeys: [PublicKey])  -> Filter
    
    func reference(reference: String)  -> Filter
    
    func references(references: [String])  -> Filter
    
    func removeAuthors(authors: [PublicKey])  -> Filter
    
    /**
     * Remove coordinates
     *
     * Remove `a` tags.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func removeCoordinates(coordinates: [Coordinate])  -> Filter
    
    func removeCustomTags(tag: SingleLetterTag, contents: [String])  -> Filter
    
    func removeEvents(ids: [EventId])  -> Filter
    
    func removeHashtags(hashtags: [String])  -> Filter
    
    func removeIdentifiers(identifiers: [String])  -> Filter
    
    func removeIds(ids: [EventId])  -> Filter
    
    func removeKinds(kinds: [Kind])  -> Filter
    
    func removeLimit()  -> Filter
    
    func removePubkeys(pubkeys: [PublicKey])  -> Filter
    
    func removeReferences(references: [String])  -> Filter
    
    func removeSearch()  -> Filter
    
    func removeSince()  -> Filter
    
    func removeUntil()  -> Filter
    
    func search(text: String)  -> Filter
    
    func since(timestamp: Timestamp)  -> Filter
    
    func until(timestamp: Timestamp)  -> Filter
    
}
open class Filter: FilterProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_filter(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_filter_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_filter(pointer, $0) }
    }

    
public static func fromJson(json: String)throws  -> Filter  {
    return try  FfiConverterTypeFilter_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_filter_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    
public static func fromRecord(record: FilterRecord) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_filter_from_record(
        FfiConverterTypeFilterRecord_lower(record),$0
    )
})
}
    

    
open func asJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_filter_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
open func asRecord() -> FilterRecord  {
    return try!  FfiConverterTypeFilterRecord_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_as_record(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Add event author Public Key
     */
open func author(author: PublicKey) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_author(self.uniffiClonePointer(),
        FfiConverterTypePublicKey_lower(author),$0
    )
})
}
    
open func authors(authors: [PublicKey]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_authors(self.uniffiClonePointer(),
        FfiConverterSequenceTypePublicKey.lower(authors),$0
    )
})
}
    
    /**
     * Add coordinate
     *
     * Query for `a` tag.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
open func coordinate(coordinate: Coordinate) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_coordinate(self.uniffiClonePointer(),
        FfiConverterTypeCoordinate_lower(coordinate),$0
    )
})
}
    
    /**
     * Add coordinates
     *
     * Query for `a` tags.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
open func coordinates(coordinates: [Coordinate]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_coordinates(self.uniffiClonePointer(),
        FfiConverterSequenceTypeCoordinate.lower(coordinates),$0
    )
})
}
    
open func customTag(tag: SingleLetterTag, content: String) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_custom_tag(self.uniffiClonePointer(),
        FfiConverterTypeSingleLetterTag_lower(tag),
        FfiConverterString.lower(content),$0
    )
})
}
    
open func customTags(tag: SingleLetterTag, contents: [String]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_custom_tags(self.uniffiClonePointer(),
        FfiConverterTypeSingleLetterTag_lower(tag),
        FfiConverterSequenceString.lower(contents),$0
    )
})
}
    
    /**
     * Add event ID (`e` tag)
     */
open func event(eventId: EventId) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_event(self.uniffiClonePointer(),
        FfiConverterTypeEventId_lower(eventId),$0
    )
})
}
    
    /**
     * Add event IDs (`e` tag)
     */
open func events(ids: [EventId]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_events(self.uniffiClonePointer(),
        FfiConverterSequenceTypeEventId.lower(ids),$0
    )
})
}
    
open func hashtag(hashtag: String) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_hashtag(self.uniffiClonePointer(),
        FfiConverterString.lower(hashtag),$0
    )
})
}
    
open func hashtags(hashtags: [String]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_hashtags(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(hashtags),$0
    )
})
}
    
open func id(id: EventId) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_id(self.uniffiClonePointer(),
        FfiConverterTypeEventId_lower(id),$0
    )
})
}
    
open func identifier(identifier: String) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_identifier(self.uniffiClonePointer(),
        FfiConverterString.lower(identifier),$0
    )
})
}
    
open func identifiers(identifiers: [String]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_identifiers(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(identifiers),$0
    )
})
}
    
open func ids(ids: [EventId]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_ids(self.uniffiClonePointer(),
        FfiConverterSequenceTypeEventId.lower(ids),$0
    )
})
}
    
open func isEmpty() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_is_empty(self.uniffiClonePointer(),$0
    )
})
}
    
open func kind(kind: Kind) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_kind(self.uniffiClonePointer(),
        FfiConverterTypeKind_lower(kind),$0
    )
})
}
    
open func kinds(kinds: [Kind]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_kinds(self.uniffiClonePointer(),
        FfiConverterSequenceTypeKind.lower(kinds),$0
    )
})
}
    
open func limit(limit: UInt64) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_limit(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(limit),$0
    )
})
}
    
    /**
     * Determine if `Filter` match given `Event`.
     */
open func matchEvent(event: Event) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_match_event(self.uniffiClonePointer(),
        FfiConverterTypeEvent_lower(event),$0
    )
})
}
    
    /**
     * Add Public Key (`p` tag)
     */
open func pubkey(pubkey: PublicKey) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_pubkey(self.uniffiClonePointer(),
        FfiConverterTypePublicKey_lower(pubkey),$0
    )
})
}
    
    /**
     * Add Public Keys (`p` tag)
     */
open func pubkeys(pubkeys: [PublicKey]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_pubkeys(self.uniffiClonePointer(),
        FfiConverterSequenceTypePublicKey.lower(pubkeys),$0
    )
})
}
    
open func reference(reference: String) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_reference(self.uniffiClonePointer(),
        FfiConverterString.lower(reference),$0
    )
})
}
    
open func references(references: [String]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_references(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(references),$0
    )
})
}
    
open func removeAuthors(authors: [PublicKey]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_remove_authors(self.uniffiClonePointer(),
        FfiConverterSequenceTypePublicKey.lower(authors),$0
    )
})
}
    
    /**
     * Remove coordinates
     *
     * Remove `a` tags.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
open func removeCoordinates(coordinates: [Coordinate]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_remove_coordinates(self.uniffiClonePointer(),
        FfiConverterSequenceTypeCoordinate.lower(coordinates),$0
    )
})
}
    
open func removeCustomTags(tag: SingleLetterTag, contents: [String]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_remove_custom_tags(self.uniffiClonePointer(),
        FfiConverterTypeSingleLetterTag_lower(tag),
        FfiConverterSequenceString.lower(contents),$0
    )
})
}
    
open func removeEvents(ids: [EventId]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_remove_events(self.uniffiClonePointer(),
        FfiConverterSequenceTypeEventId.lower(ids),$0
    )
})
}
    
open func removeHashtags(hashtags: [String]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_remove_hashtags(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(hashtags),$0
    )
})
}
    
open func removeIdentifiers(identifiers: [String]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_remove_identifiers(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(identifiers),$0
    )
})
}
    
open func removeIds(ids: [EventId]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_remove_ids(self.uniffiClonePointer(),
        FfiConverterSequenceTypeEventId.lower(ids),$0
    )
})
}
    
open func removeKinds(kinds: [Kind]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_remove_kinds(self.uniffiClonePointer(),
        FfiConverterSequenceTypeKind.lower(kinds),$0
    )
})
}
    
open func removeLimit() -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_remove_limit(self.uniffiClonePointer(),$0
    )
})
}
    
open func removePubkeys(pubkeys: [PublicKey]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_remove_pubkeys(self.uniffiClonePointer(),
        FfiConverterSequenceTypePublicKey.lower(pubkeys),$0
    )
})
}
    
open func removeReferences(references: [String]) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_remove_references(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(references),$0
    )
})
}
    
open func removeSearch() -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_remove_search(self.uniffiClonePointer(),$0
    )
})
}
    
open func removeSince() -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_remove_since(self.uniffiClonePointer(),$0
    )
})
}
    
open func removeUntil() -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_remove_until(self.uniffiClonePointer(),$0
    )
})
}
    
open func search(text: String) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_search(self.uniffiClonePointer(),
        FfiConverterString.lower(text),$0
    )
})
}
    
open func since(timestamp: Timestamp) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_since(self.uniffiClonePointer(),
        FfiConverterTypeTimestamp_lower(timestamp),$0
    )
})
}
    
open func until(timestamp: Timestamp) -> Filter  {
    return try!  FfiConverterTypeFilter_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_until(self.uniffiClonePointer(),
        FfiConverterTypeTimestamp_lower(timestamp),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Filter, other: Filter) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeFilter_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_filter_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Filter: CustomDebugStringConvertible {}
extension Filter: Equatable {}
extension Filter: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFilter: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Filter

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Filter {
        return Filter(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Filter) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Filter {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Filter, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFilter_lift(_ pointer: UnsafeMutableRawPointer) throws -> Filter {
    return try FfiConverterTypeFilter.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFilter_lower(_ value: Filter) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFilter.lower(value)
}






public protocol HandleNotification: AnyObject, Sendable {
    
    func handleMsg(relayUrl: RelayUrl, msg: RelayMessage) async 
    
    func handle(relayUrl: RelayUrl, subscriptionId: String, event: Event) async 
    
}
open class HandleNotificationImpl: HandleNotification, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_handlenotification(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_handlenotification(pointer, $0) }
    }

    

    
open func handleMsg(relayUrl: RelayUrl, msg: RelayMessage)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_handlenotification_handle_msg(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelayUrl_lower(relayUrl),FfiConverterTypeRelayMessage_lower(msg)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func handle(relayUrl: RelayUrl, subscriptionId: String, event: Event)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_handlenotification_handle(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRelayUrl_lower(relayUrl),FfiConverterString.lower(subscriptionId),FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceHandleNotification {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceHandleNotification] = [UniffiVTableCallbackInterfaceHandleNotification(
        handleMsg: { (
            uniffiHandle: UInt64,
            relayUrl: UnsafeMutableRawPointer,
            msg: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeHandleNotification.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.handleMsg(
                     relayUrl: try FfiConverterTypeRelayUrl_lift(relayUrl),
                     msg: try FfiConverterTypeRelayMessage_lift(msg)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        handle: { (
            uniffiHandle: UInt64,
            relayUrl: UnsafeMutableRawPointer,
            subscriptionId: RustBuffer,
            event: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeHandleNotification.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.handle(
                     relayUrl: try FfiConverterTypeRelayUrl_lift(relayUrl),
                     subscriptionId: try FfiConverterString.lift(subscriptionId),
                     event: try FfiConverterTypeEvent_lift(event)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeHandleNotification.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HandleNotification: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitHandleNotification() {
    uniffi_nostr_sdk_ffi_fn_init_callback_vtable_handlenotification(UniffiCallbackInterfaceHandleNotification.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHandleNotification: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<HandleNotification>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HandleNotification

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HandleNotification {
        return HandleNotificationImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HandleNotification) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HandleNotification {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HandleNotification, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHandleNotification_lift(_ pointer: UnsafeMutableRawPointer) throws -> HandleNotification {
    return try FfiConverterTypeHandleNotification.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHandleNotification_lower(_ value: HandleNotification) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHandleNotification.lower(value)
}






/**
 * Data Vending Machine (DVM) - Job Feedback data
 *
 * <https://github.com/nostr-protocol/nips/blob/master/90.md>
 */
public protocol JobFeedbackDataProtocol: AnyObject, Sendable {
    
    /**
     * Add payment amount
     */
    func amount(millisats: UInt64, bolt11: String?)  -> JobFeedbackData
    
    /**
     * Add extra info
     */
    func extraInfo(info: String)  -> JobFeedbackData
    
    /**
     * Add payload
     */
    func payload(payload: String)  -> JobFeedbackData
    
}
/**
 * Data Vending Machine (DVM) - Job Feedback data
 *
 * <https://github.com/nostr-protocol/nips/blob/master/90.md>
 */
open class JobFeedbackData: JobFeedbackDataProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_jobfeedbackdata(self.pointer, $0) }
    }
    /**
     * Construct new Job Feedback
     */
public convenience init(jobRequest: Event, status: DataVendingMachineStatus) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_jobfeedbackdata_new(
        FfiConverterTypeEvent_lower(jobRequest),
        FfiConverterTypeDataVendingMachineStatus_lower(status),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_jobfeedbackdata(pointer, $0) }
    }

    

    
    /**
     * Add payment amount
     */
open func amount(millisats: UInt64, bolt11: String?) -> JobFeedbackData  {
    return try!  FfiConverterTypeJobFeedbackData_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_jobfeedbackdata_amount(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(millisats),
        FfiConverterOptionString.lower(bolt11),$0
    )
})
}
    
    /**
     * Add extra info
     */
open func extraInfo(info: String) -> JobFeedbackData  {
    return try!  FfiConverterTypeJobFeedbackData_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_jobfeedbackdata_extra_info(self.uniffiClonePointer(),
        FfiConverterString.lower(info),$0
    )
})
}
    
    /**
     * Add payload
     */
open func payload(payload: String) -> JobFeedbackData  {
    return try!  FfiConverterTypeJobFeedbackData_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_jobfeedbackdata_payload(self.uniffiClonePointer(),
        FfiConverterString.lower(payload),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJobFeedbackData: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = JobFeedbackData

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> JobFeedbackData {
        return JobFeedbackData(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: JobFeedbackData) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JobFeedbackData {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: JobFeedbackData, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJobFeedbackData_lift(_ pointer: UnsafeMutableRawPointer) throws -> JobFeedbackData {
    return try FfiConverterTypeJobFeedbackData.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJobFeedbackData_lower(_ value: JobFeedbackData) -> UnsafeMutableRawPointer {
    return FfiConverterTypeJobFeedbackData.lower(value)
}






/**
 * Nostr keys
 */
public protocol KeysProtocol: AnyObject, Sendable {
    
    /**
     * Get public key
     */
    func publicKey()  -> PublicKey
    
    /**
     * Get secret key
     */
    func secretKey()  -> SecretKey
    
    /**
     * Creates a schnorr signature of a message.
     *
     * This method use a random number generator that retrieves randomness from the operating system.
     */
    func signSchnorr(message: Data) throws  -> String
    
}
/**
 * Nostr keys
 */
open class Keys: KeysProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_keys(self.pointer, $0) }
    }
    /**
     * Initialize nostr keys from secret key.
     */
public convenience init(secretKey: SecretKey) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_keys_new(
        FfiConverterTypeSecretKey_lower(secretKey),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_keys(pointer, $0) }
    }

    
    /**
     * Derive keys from BIP-39 mnemonics (ENGLISH wordlist).
     *
     * <https://github.com/nostr-protocol/nips/blob/master/06.md>
     */
public static func fromMnemonic(mnemonic: String, passphrase: String? = nil, account: UInt32? = nil, typ: UInt32? = nil, index: UInt32? = nil)throws  -> Keys  {
    return try  FfiConverterTypeKeys_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_keys_from_mnemonic(
        FfiConverterString.lower(mnemonic),
        FfiConverterOptionString.lower(passphrase),
        FfiConverterOptionUInt32.lower(account),
        FfiConverterOptionUInt32.lower(typ),
        FfiConverterOptionUInt32.lower(index),$0
    )
})
}
    
    /**
     * Generate random keys
     *
     * This constructor use a random number generator that retrieves randomness from the operating system.
     *
     * Generate random keys **without** construct the `Keypair`.
     * This allows faster keys generation (i.e. for vanity pubkey mining).
     * The `Keypair` will be automatically created when needed and stored in a cell.
     */
public static func generate() -> Keys  {
    return try!  FfiConverterTypeKeys_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_keys_generate($0
    )
})
}
    
    /**
     * Parse secret key from `hex` or `bech32` and compose keys
     */
public static func parse(secretKey: String)throws  -> Keys  {
    return try  FfiConverterTypeKeys_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_keys_parse(
        FfiConverterString.lower(secretKey),$0
    )
})
}
    

    
    /**
     * Get public key
     */
open func publicKey() -> PublicKey  {
    return try!  FfiConverterTypePublicKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_keys_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get secret key
     */
open func secretKey() -> SecretKey  {
    return try!  FfiConverterTypeSecretKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_keys_secret_key(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Creates a schnorr signature of a message.
     *
     * This method use a random number generator that retrieves randomness from the operating system.
     */
open func signSchnorr(message: Data)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_keys_sign_schnorr(self.uniffiClonePointer(),
        FfiConverterData.lower(message),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Keys, other: Keys) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeKeys_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_keys_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Keys: CustomDebugStringConvertible {}
extension Keys: Equatable {}
extension Keys: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeys: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Keys

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Keys {
        return Keys(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Keys) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Keys {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Keys, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeys_lift(_ pointer: UnsafeMutableRawPointer) throws -> Keys {
    return try FfiConverterTypeKeys.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeys_lower(_ value: Keys) -> UnsafeMutableRawPointer {
    return FfiConverterTypeKeys.lower(value)
}






/**
 * Event Kind
 */
public protocol KindProtocol: AnyObject, Sendable {
    
    func asStd()  -> KindStandard?
    
    /**
     * Get as 16-bit unsigned integer
     */
    func asU16()  -> UInt16
    
    /**
     * Check if it's addressable
     *
     * Addressable means that, for each combination of `pubkey`, `kind` and the `d` tag's first value,
     * only the latest event MUST be stored by relays, older versions MAY be discarded.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func isAddressable()  -> Bool
    
    /**
     * Check if it's ephemeral
     *
     * Ephemeral means that event is not expected to be stored by relays.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func isEphemeral()  -> Bool
    
    /**
     * Check if it's a NIP90 job request
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
    func isJobRequest()  -> Bool
    
    /**
     * Check if it's a NIP90 job result
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
    func isJobResult()  -> Bool
    
    /**
     * Check if it's regular
     *
     * Regular means that event is expected to be stored by relays.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func isRegular()  -> Bool
    
    /**
     * Check if it's replaceable
     *
     * Replaceable means that, for each combination of `pubkey` and `kind`,
     * only the latest event MUST be stored by relays, older versions MAY be discarded.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func isReplaceable()  -> Bool
    
}
/**
 * Event Kind
 */
open class Kind: KindProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_kind(self.pointer, $0) }
    }
public convenience init(kind: UInt16) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_kind_new(
        FfiConverterUInt16.lower(kind),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_kind(pointer, $0) }
    }

    
public static func fromStd(e: KindStandard) -> Kind  {
    return try!  FfiConverterTypeKind_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_kind_from_std(
        FfiConverterTypeKindStandard_lower(e),$0
    )
})
}
    

    
open func asStd() -> KindStandard?  {
    return try!  FfiConverterOptionTypeKindStandard.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_kind_as_std(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get as 16-bit unsigned integer
     */
open func asU16() -> UInt16  {
    return try!  FfiConverterUInt16.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_kind_as_u16(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if it's addressable
     *
     * Addressable means that, for each combination of `pubkey`, `kind` and the `d` tag's first value,
     * only the latest event MUST be stored by relays, older versions MAY be discarded.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
open func isAddressable() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_kind_is_addressable(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if it's ephemeral
     *
     * Ephemeral means that event is not expected to be stored by relays.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
open func isEphemeral() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_kind_is_ephemeral(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if it's a NIP90 job request
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
open func isJobRequest() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_kind_is_job_request(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if it's a NIP90 job result
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
open func isJobResult() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_kind_is_job_result(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if it's regular
     *
     * Regular means that event is expected to be stored by relays.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
open func isRegular() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_kind_is_regular(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if it's replaceable
     *
     * Replaceable means that, for each combination of `pubkey` and `kind`,
     * only the latest event MUST be stored by relays, older versions MAY be discarded.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
open func isReplaceable() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_kind_is_replaceable(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Kind, other: Kind) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeKind_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_kind_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Kind: CustomDebugStringConvertible {}
extension Kind: CustomStringConvertible {}
extension Kind: Equatable {}
extension Kind: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKind: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Kind

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Kind {
        return Kind(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Kind) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Kind {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Kind, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKind_lift(_ pointer: UnsafeMutableRawPointer) throws -> Kind {
    return try FfiConverterTypeKind.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKind_lower(_ value: Kind) -> UnsafeMutableRawPointer {
    return FfiConverterTypeKind.lower(value)
}






/**
 * A local nostr relay
 *
 * This is automatically shutdown when all instances/clones are dropped!
 */
public protocol LocalRelayProtocol: AnyObject, Sendable {
    
    /**
     * Send event to subscribers
     *
     * Return `true` if the event is successfully sent.
     *
     * This method doesn't save the event into the database!
     * It's intended to be used ONLY when the database is shared with other apps (i.e. with the nostr-sdk `Client`).
     */
    func notifyEvent(event: Event)  -> Bool
    
    /**
     * Run the local relay
     */
    func run() async throws 
    
    /**
     * Shutdown relay
     */
    func shutdown() 
    
    /**
     * Get url
     */
    func url() async  -> RelayUrl
    
}
/**
 * A local nostr relay
 *
 * This is automatically shutdown when all instances/clones are dropped!
 */
open class LocalRelay: LocalRelayProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_localrelay(self.pointer, $0) }
    }
    /**
     * Construct a new relay
     */
public convenience init(builder: RelayBuilder) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_localrelay_new(
        FfiConverterTypeRelayBuilder_lower(builder),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_localrelay(pointer, $0) }
    }

    

    
    /**
     * Send event to subscribers
     *
     * Return `true` if the event is successfully sent.
     *
     * This method doesn't save the event into the database!
     * It's intended to be used ONLY when the database is shared with other apps (i.e. with the nostr-sdk `Client`).
     */
open func notifyEvent(event: Event) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_localrelay_notify_event(self.uniffiClonePointer(),
        FfiConverterTypeEvent_lower(event),$0
    )
})
}
    
    /**
     * Run the local relay
     */
open func run()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_localrelay_run(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Shutdown relay
     */
open func shutdown()  {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_localrelay_shutdown(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Get url
     */
open func url()async  -> RelayUrl  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_localrelay_url(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRelayUrl_lift,
            errorHandler: nil
            
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocalRelay: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LocalRelay

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LocalRelay {
        return LocalRelay(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LocalRelay) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalRelay {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LocalRelay, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalRelay_lift(_ pointer: UnsafeMutableRawPointer) throws -> LocalRelay {
    return try FfiConverterTypeLocalRelay.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalRelay_lower(_ value: LocalRelay) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLocalRelay.lower(value)
}






public protocol MetadataProtocol: AnyObject, Sendable {
    
    func asJson() throws  -> String
    
    func asPrettyJson() throws  -> String
    
    func asRecord()  -> MetadataRecord
    
}
open class Metadata: MetadataProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_metadata(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_metadata(pointer, $0) }
    }

    
    /**
     * Parse metadata from JSON
     */
public static func fromJson(json: String)throws  -> Metadata  {
    return try  FfiConverterTypeMetadata_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_metadata_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    
public static func fromRecord(r: MetadataRecord) -> Metadata  {
    return try!  FfiConverterTypeMetadata_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_metadata_from_record(
        FfiConverterTypeMetadataRecord_lower(r),$0
    )
})
}
    

    
open func asJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_metadata_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
open func asPrettyJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_metadata_as_pretty_json(self.uniffiClonePointer(),$0
    )
})
}
    
open func asRecord() -> MetadataRecord  {
    return try!  FfiConverterTypeMetadataRecord_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_metadata_as_record(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Metadata, other: Metadata) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeMetadata_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_metadata_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Metadata: CustomDebugStringConvertible {}
extension Metadata: Equatable {}
extension Metadata: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Metadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Metadata {
        return Metadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Metadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Metadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Metadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> Metadata {
    return try FfiConverterTypeMetadata.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMetadata_lower(_ value: Metadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMetadata.lower(value)
}






/**
 * Nostr Wallet Connect client
 */
public protocol NwcProtocol: AnyObject, Sendable {
    
    /**
     * Get balance
     */
    func getBalance() async throws  -> UInt64
    
    /**
     * Get info
     */
    func getInfo() async throws  -> GetInfoResponse
    
    /**
     * List transactions
     */
    func listTransactions(params: ListTransactionsRequest) async throws  -> [LookupInvoiceResponse]
    
    /**
     * Lookup invoice
     */
    func lookupInvoice(params: LookupInvoiceRequest) async throws  -> LookupInvoiceResponse
    
    /**
     * Create invoice
     */
    func makeInvoice(params: MakeInvoiceRequest) async throws  -> MakeInvoiceResponse
    
    /**
     * Pay invoice
     */
    func payInvoice(params: PayInvoiceRequest) async throws  -> PayInvoiceResponse
    
    /**
     * Pay keysend
     */
    func payKeysend(params: PayKeysendRequest) async throws  -> PayKeysendResponse
    
    /**
     * Get relays status
     */
    func status() async  -> [RelayUrl: RelayStatus]
    
}
/**
 * Nostr Wallet Connect client
 */
open class Nwc: NwcProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nwc(self.pointer, $0) }
    }
    /**
     * Compose new `NWC` client
     */
public convenience init(uri: NostrWalletConnectUri) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nwc_new(
        FfiConverterTypeNostrWalletConnectURI_lower(uri),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nwc(pointer, $0) }
    }

    
    /**
     * Compose new `NWC` client with `NostrWalletConnectOptions`
     */
public static func withOpts(uri: NostrWalletConnectUri, opts: NostrWalletConnectOptions) -> Nwc  {
    return try!  FfiConverterTypeNWC_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nwc_with_opts(
        FfiConverterTypeNostrWalletConnectURI_lower(uri),
        FfiConverterTypeNostrWalletConnectOptions_lower(opts),$0
    )
})
}
    

    
    /**
     * Get balance
     */
open func getBalance()async throws  -> UInt64  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_get_balance(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Get info
     */
open func getInfo()async throws  -> GetInfoResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_get_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetInfoResponse_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * List transactions
     */
open func listTransactions(params: ListTransactionsRequest)async throws  -> [LookupInvoiceResponse]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_list_transactions(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListTransactionsRequest_lower(params)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeLookupInvoiceResponse.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Lookup invoice
     */
open func lookupInvoice(params: LookupInvoiceRequest)async throws  -> LookupInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_lookup_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLookupInvoiceRequest_lower(params)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLookupInvoiceResponse_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Create invoice
     */
open func makeInvoice(params: MakeInvoiceRequest)async throws  -> MakeInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_make_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMakeInvoiceRequest_lower(params)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMakeInvoiceResponse_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Pay invoice
     */
open func payInvoice(params: PayInvoiceRequest)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_pay_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayInvoiceRequest_lower(params)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Pay keysend
     */
open func payKeysend(params: PayKeysendRequest)async throws  -> PayKeysendResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_pay_keysend(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayKeysendRequest_lower(params)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayKeysendResponse_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Get relays status
     */
open func status()async  -> [RelayUrl: RelayStatus]  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nwc_status(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryTypeRelayUrlTypeRelayStatus.lift,
            errorHandler: nil
            
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNWC: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nwc

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nwc {
        return Nwc(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nwc) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nwc {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nwc, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNWC_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nwc {
    return try FfiConverterTypeNWC.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNWC_lower(_ value: Nwc) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNWC.lower(value)
}






/**
 * NIP-05 address
 */
public protocol Nip05AddressProtocol: AnyObject, Sendable {
    
    /**
     * Get the domain value
     */
    func domain()  -> String
    
    /**
     * Get the name value
     */
    func name()  -> String
    
    /**
     * Get url for NIP05 address
     *
     * This can be used to make a `GET` HTTP request and get the NIP-05 JSON.
     */
    func url()  -> String
    
}
/**
 * NIP-05 address
 */
open class Nip05Address: Nip05AddressProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nip05address(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nip05address(pointer, $0) }
    }

    
    /**
     * Parse a NIP-05 address (i.e., `yuki@yukikishimoto.com`).
     */
public static func parse(address: String)throws  -> Nip05Address  {
    return try  FfiConverterTypeNip05Address_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nip05address_parse(
        FfiConverterString.lower(address),$0
    )
})
}
    

    
    /**
     * Get the domain value
     */
open func domain() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip05address_domain(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the name value
     */
open func name() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip05address_name(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get url for NIP05 address
     *
     * This can be used to make a `GET` HTTP request and get the NIP-05 JSON.
     */
open func url() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip05address_url(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Nip05Address, other: Nip05Address) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNip05Address_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip05address_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Nip05Address: CustomDebugStringConvertible {}
extension Nip05Address: CustomStringConvertible {}
extension Nip05Address: Equatable {}
extension Nip05Address: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNip05Address: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip05Address

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip05Address {
        return Nip05Address(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip05Address) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip05Address {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip05Address, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip05Address_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip05Address {
    return try FfiConverterTypeNip05Address.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip05Address_lower(_ value: Nip05Address) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip05Address.lower(value)
}






public protocol Nip05ProfileProtocol: AnyObject, Sendable {
    
    /**
     * Get NIP46 relays
     */
    func nip46()  -> [RelayUrl]
    
    func publicKey()  -> PublicKey
    
    /**
     * Get relays
     */
    func relays()  -> [RelayUrl]
    
}
open class Nip05Profile: Nip05ProfileProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nip05profile(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nip05profile(pointer, $0) }
    }

    
    /**
     * Extract a NIP-05 profile from raw JSON
     *
     * <https://github.com/nostr-protocol/nips/blob/master/05.md>
     */
public static func fromJson(address: Nip05Address, json: String)throws  -> Nip05Profile  {
    return try  FfiConverterTypeNip05Profile_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nip05profile_from_json(
        FfiConverterTypeNip05Address_lower(address),
        FfiConverterString.lower(json),$0
    )
})
}
    

    
    /**
     * Get NIP46 relays
     */
open func nip46() -> [RelayUrl]  {
    return try!  FfiConverterSequenceTypeRelayUrl.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip05profile_nip46(self.uniffiClonePointer(),$0
    )
})
}
    
open func publicKey() -> PublicKey  {
    return try!  FfiConverterTypePublicKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip05profile_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get relays
     */
open func relays() -> [RelayUrl]  {
    return try!  FfiConverterSequenceTypeRelayUrl.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip05profile_relays(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip05profile_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Nip05Profile, other: Nip05Profile) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip05profile_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNip05Profile_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip05profile_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Nip05Profile: CustomDebugStringConvertible {}
extension Nip05Profile: Equatable {}
extension Nip05Profile: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNip05Profile: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip05Profile

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip05Profile {
        return Nip05Profile(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip05Profile) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip05Profile {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip05Profile, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip05Profile_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip05Profile {
    return try FfiConverterTypeNip05Profile.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip05Profile_lower(_ value: Nip05Profile) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip05Profile.lower(value)
}






public protocol Nip19Protocol: AnyObject, Sendable {
    
    func asEnum()  -> Nip19Enum
    
}
open class Nip19: Nip19Protocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nip19(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nip19(pointer, $0) }
    }

    
public static func fromBech32(bech32: String)throws  -> Nip19  {
    return try  FfiConverterTypeNip19_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nip19_from_bech32(
        FfiConverterString.lower(bech32),$0
    )
})
}
    

    
open func asEnum() -> Nip19Enum  {
    return try!  FfiConverterTypeNip19Enum_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19_as_enum(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Nip19, other: Nip19) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNip19_lower(other),$0
    )
}
        )
    }

}
extension Nip19: CustomDebugStringConvertible {}
extension Nip19: Equatable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNip19: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip19

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19 {
        return Nip19(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip19) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip19 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip19, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip19_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19 {
    return try FfiConverterTypeNip19.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip19_lower(_ value: Nip19) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip19.lower(value)
}






public protocol Nip19CoordinateProtocol: AnyObject, Sendable {
    
    func coordinate()  -> Coordinate
    
    func relays()  -> [RelayUrl]
    
    func toBech32() throws  -> String
    
    func toNostrUri() throws  -> String
    
}
open class Nip19Coordinate: Nip19CoordinateProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nip19coordinate(self.pointer, $0) }
    }
public convenience init(coordinate: Coordinate, relays: [RelayUrl] = []) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nip19coordinate_new(
        FfiConverterTypeCoordinate_lower(coordinate),
        FfiConverterSequenceTypeRelayUrl.lower(relays),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nip19coordinate(pointer, $0) }
    }

    
public static func fromBech32(bech32: String)throws  -> Nip19Coordinate  {
    return try  FfiConverterTypeNip19Coordinate_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nip19coordinate_from_bech32(
        FfiConverterString.lower(bech32),$0
    )
})
}
    
public static func fromNostrUri(uri: String)throws  -> Nip19Coordinate  {
    return try  FfiConverterTypeNip19Coordinate_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nip19coordinate_from_nostr_uri(
        FfiConverterString.lower(uri),$0
    )
})
}
    

    
open func coordinate() -> Coordinate  {
    return try!  FfiConverterTypeCoordinate_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_coordinate(self.uniffiClonePointer(),$0
    )
})
}
    
open func relays() -> [RelayUrl]  {
    return try!  FfiConverterSequenceTypeRelayUrl.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_relays(self.uniffiClonePointer(),$0
    )
})
}
    
open func toBech32()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_to_bech32(self.uniffiClonePointer(),$0
    )
})
}
    
open func toNostrUri()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_to_nostr_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Nip19Coordinate, other: Nip19Coordinate) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNip19Coordinate_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19coordinate_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Nip19Coordinate: CustomDebugStringConvertible {}
extension Nip19Coordinate: Equatable {}
extension Nip19Coordinate: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNip19Coordinate: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip19Coordinate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19Coordinate {
        return Nip19Coordinate(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip19Coordinate) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip19Coordinate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip19Coordinate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip19Coordinate_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19Coordinate {
    return try FfiConverterTypeNip19Coordinate.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip19Coordinate_lower(_ value: Nip19Coordinate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip19Coordinate.lower(value)
}






public protocol Nip19EventProtocol: AnyObject, Sendable {
    
    func author()  -> PublicKey?
    
    func eventId()  -> EventId
    
    func kind()  -> Kind?
    
    func relays()  -> [RelayUrl]
    
    func toBech32() throws  -> String
    
    func toNostrUri() throws  -> String
    
}
open class Nip19Event: Nip19EventProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nip19event(self.pointer, $0) }
    }
public convenience init(eventId: EventId, author: PublicKey? = nil, kind: Kind? = nil, relays: [RelayUrl] = []) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nip19event_new(
        FfiConverterTypeEventId_lower(eventId),
        FfiConverterOptionTypePublicKey.lower(author),
        FfiConverterOptionTypeKind.lower(kind),
        FfiConverterSequenceTypeRelayUrl.lower(relays),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nip19event(pointer, $0) }
    }

    
public static func fromBech32(bech32: String)throws  -> Nip19Event  {
    return try  FfiConverterTypeNip19Event_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nip19event_from_bech32(
        FfiConverterString.lower(bech32),$0
    )
})
}
    
public static func fromEvent(event: Event) -> Nip19Event  {
    return try!  FfiConverterTypeNip19Event_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nip19event_from_event(
        FfiConverterTypeEvent_lower(event),$0
    )
})
}
    
public static func fromNostrUri(uri: String)throws  -> Nip19Event  {
    return try  FfiConverterTypeNip19Event_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nip19event_from_nostr_uri(
        FfiConverterString.lower(uri),$0
    )
})
}
    

    
open func author() -> PublicKey?  {
    return try!  FfiConverterOptionTypePublicKey.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19event_author(self.uniffiClonePointer(),$0
    )
})
}
    
open func eventId() -> EventId  {
    return try!  FfiConverterTypeEventId_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19event_event_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func kind() -> Kind?  {
    return try!  FfiConverterOptionTypeKind.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19event_kind(self.uniffiClonePointer(),$0
    )
})
}
    
open func relays() -> [RelayUrl]  {
    return try!  FfiConverterSequenceTypeRelayUrl.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19event_relays(self.uniffiClonePointer(),$0
    )
})
}
    
open func toBech32()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_nip19event_to_bech32(self.uniffiClonePointer(),$0
    )
})
}
    
open func toNostrUri()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_nip19event_to_nostr_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Nip19Event, other: Nip19Event) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNip19Event_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19event_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Nip19Event: CustomDebugStringConvertible {}
extension Nip19Event: Equatable {}
extension Nip19Event: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNip19Event: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip19Event

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19Event {
        return Nip19Event(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip19Event) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip19Event {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip19Event, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip19Event_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19Event {
    return try FfiConverterTypeNip19Event.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip19Event_lower(_ value: Nip19Event) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip19Event.lower(value)
}






public protocol Nip19ProfileProtocol: AnyObject, Sendable {
    
    func publicKey()  -> PublicKey
    
    func relays()  -> [RelayUrl]
    
    func toBech32() throws  -> String
    
    func toNostrUri() throws  -> String
    
}
open class Nip19Profile: Nip19ProfileProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nip19profile(self.pointer, $0) }
    }
    /**
     * New NIP19 profile
     */
public convenience init(publicKey: PublicKey, relays: [RelayUrl] = []) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nip19profile_new(
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterSequenceTypeRelayUrl.lower(relays),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nip19profile(pointer, $0) }
    }

    
public static func fromBech32(bech32: String)throws  -> Nip19Profile  {
    return try  FfiConverterTypeNip19Profile_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nip19profile_from_bech32(
        FfiConverterString.lower(bech32),$0
    )
})
}
    
public static func fromNostrUri(uri: String)throws  -> Nip19Profile  {
    return try  FfiConverterTypeNip19Profile_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nip19profile_from_nostr_uri(
        FfiConverterString.lower(uri),$0
    )
})
}
    

    
open func publicKey() -> PublicKey  {
    return try!  FfiConverterTypePublicKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19profile_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
open func relays() -> [RelayUrl]  {
    return try!  FfiConverterSequenceTypeRelayUrl.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19profile_relays(self.uniffiClonePointer(),$0
    )
})
}
    
open func toBech32()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_nip19profile_to_bech32(self.uniffiClonePointer(),$0
    )
})
}
    
open func toNostrUri()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_nip19profile_to_nostr_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Nip19Profile, other: Nip19Profile) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNip19Profile_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip19profile_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Nip19Profile: CustomDebugStringConvertible {}
extension Nip19Profile: Equatable {}
extension Nip19Profile: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNip19Profile: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip19Profile

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19Profile {
        return Nip19Profile(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip19Profile) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip19Profile {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip19Profile, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip19Profile_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19Profile {
    return try FfiConverterTypeNip19Profile.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip19Profile_lower(_ value: Nip19Profile) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip19Profile.lower(value)
}






public protocol Nip21Protocol: AnyObject, Sendable {
    
    func asEnum()  -> Nip21Enum
    
    /**
     * Serialize to NIP21 nostr URI
     */
    func toNostrUri() throws  -> String
    
}
open class Nip21: Nip21Protocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nip21(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nip21(pointer, $0) }
    }

    
    /**
     * Parse NIP21 string
     */
public static func parse(uri: String)throws  -> Nip21  {
    return try  FfiConverterTypeNip21_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nip21_parse(
        FfiConverterString.lower(uri),$0
    )
})
}
    

    
open func asEnum() -> Nip21Enum  {
    return try!  FfiConverterTypeNip21Enum_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip21_as_enum(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Serialize to NIP21 nostr URI
     */
open func toNostrUri()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_nip21_to_nostr_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Nip21, other: Nip21) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNip21_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip21_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Nip21: CustomDebugStringConvertible {}
extension Nip21: Equatable {}
extension Nip21: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNip21: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip21

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip21 {
        return Nip21(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip21) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip21 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip21, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip21_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip21 {
    return try FfiConverterTypeNip21.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip21_lower(_ value: Nip21) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip21.lower(value)
}






/**
 * NIP-96 server config
 */
public protocol Nip96ServerConfigProtocol: AnyObject, Sendable {
    
    /**
     * API URL
     */
    func apiUrl()  -> String
    
    /**
     * Serialize as JSON
     */
    func asJson() throws  -> String
    
    /**
     * Allowed content types
     */
    func contentTypes()  -> [String]?
    
    /**
     * Delegated URL
     */
    func delegatedToUrl()  -> String?
    
    /**
     * Download URL
     */
    func downloadUrl()  -> String
    
}
/**
 * NIP-96 server config
 */
open class Nip96ServerConfig: Nip96ServerConfigProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nip96serverconfig(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nip96serverconfig(pointer, $0) }
    }

    
    /**
     * Parse NIP-96 server config from JSON
     */
public static func fromJson(json: String)throws  -> Nip96ServerConfig  {
    return try  FfiConverterTypeNip96ServerConfig_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nip96serverconfig_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    

    
    /**
     * API URL
     */
open func apiUrl() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_api_url(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Serialize as JSON
     */
open func asJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Allowed content types
     */
open func contentTypes() -> [String]?  {
    return try!  FfiConverterOptionSequenceString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_content_types(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Delegated URL
     */
open func delegatedToUrl() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_delegated_to_url(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Download URL
     */
open func downloadUrl() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_download_url(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Nip96ServerConfig, other: Nip96ServerConfig) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNip96ServerConfig_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96serverconfig_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Nip96ServerConfig: CustomDebugStringConvertible {}
extension Nip96ServerConfig: Equatable {}
extension Nip96ServerConfig: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNip96ServerConfig: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip96ServerConfig

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip96ServerConfig {
        return Nip96ServerConfig(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip96ServerConfig) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip96ServerConfig {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip96ServerConfig, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip96ServerConfig_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip96ServerConfig {
    return try FfiConverterTypeNip96ServerConfig.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip96ServerConfig_lower(_ value: Nip96ServerConfig) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip96ServerConfig.lower(value)
}






/**
 * NIP96 upload request information
 * Contains all data needed to make a file upload request
 */
public protocol Nip96UploadRequestProtocol: AnyObject, Sendable {
    
    /**
     * Get the Authorization header value
     */
    func authorization()  -> String
    
    /**
     * Get the URL to POST to
     */
    func url()  -> String
    
}
/**
 * NIP96 upload request information
 * Contains all data needed to make a file upload request
 */
open class Nip96UploadRequest: Nip96UploadRequestProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nip96uploadrequest(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nip96uploadrequest(pointer, $0) }
    }

    
    /**
     * Prepare upload request data
     *
     * This function prepares the authorization header and returns all the data
     * needed to make an upload request with the HTTP client.
     *
     * Note: please create the multipart form data yourself using your
     * preferred HTTP client's multipart impl.
     */
public static func create(signer: NostrSigner, config: Nip96ServerConfig, fileData: Data)async throws  -> Nip96UploadRequest  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_constructor_nip96uploadrequest_create(FfiConverterTypeNostrSigner_lower(signer),FfiConverterTypeNip96ServerConfig_lower(config),FfiConverterData.lower(fileData)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNip96UploadRequest_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    

    
    /**
     * Get the Authorization header value
     */
open func authorization() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_authorization(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the URL to POST to
     */
open func url() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_url(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Nip96UploadRequest, other: Nip96UploadRequest) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNip96UploadRequest_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96uploadrequest_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Nip96UploadRequest: CustomDebugStringConvertible {}
extension Nip96UploadRequest: Equatable {}
extension Nip96UploadRequest: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNip96UploadRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip96UploadRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip96UploadRequest {
        return Nip96UploadRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip96UploadRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip96UploadRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip96UploadRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip96UploadRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip96UploadRequest {
    return try FfiConverterTypeNip96UploadRequest.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip96UploadRequest_lower(_ value: Nip96UploadRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip96UploadRequest.lower(value)
}






/**
 * NIP-96 upload response
 */
public protocol Nip96UploadResponseProtocol: AnyObject, Sendable {
    
    /**
     * Serialize as JSON
     */
    func asJson() throws  -> String
    
    /**
     * Extract the download URL from the upload response
     *
     * Returns an error if the upload was unsuccessful or if the URL cannot be found
     */
    func downloadUrl() throws  -> String
    
    /**
     * Check if success
     */
    func isSuccess()  -> Bool
    
    /**
     * Free text success, failure or info message
     */
    func message()  -> String
    
}
/**
 * NIP-96 upload response
 */
open class Nip96UploadResponse: Nip96UploadResponseProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nip96uploadresponse(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nip96uploadresponse(pointer, $0) }
    }

    
    /**
     * Parse NIP-96 upload response from JSON
     */
public static func fromJson(json: String)throws  -> Nip96UploadResponse  {
    return try  FfiConverterTypeNip96UploadResponse_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nip96uploadresponse_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    

    
    /**
     * Serialize as JSON
     */
open func asJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Extract the download URL from the upload response
     *
     * Returns an error if the upload was unsuccessful or if the URL cannot be found
     */
open func downloadUrl()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_download_url(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if success
     */
open func isSuccess() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_is_success(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Free text success, failure or info message
     */
open func message() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_message(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Nip96UploadResponse, other: Nip96UploadResponse) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNip96UploadResponse_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nip96uploadresponse_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Nip96UploadResponse: CustomDebugStringConvertible {}
extension Nip96UploadResponse: Equatable {}
extension Nip96UploadResponse: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNip96UploadResponse: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip96UploadResponse

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip96UploadResponse {
        return Nip96UploadResponse(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip96UploadResponse) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip96UploadResponse {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip96UploadResponse, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip96UploadResponse_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip96UploadResponse {
    return try FfiConverterTypeNip96UploadResponse.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip96UploadResponse_lower(_ value: Nip96UploadResponse) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip96UploadResponse.lower(value)
}






public protocol NostrConnectProtocol: AnyObject, Sendable {
    
    /**
     * Get `bunker` URI
     */
    func bunkerUri() async throws  -> NostrConnectUri
    
    func getPublicKey() async throws  -> PublicKey
    
    func nip04Decrypt(publicKey: PublicKey, encryptedContent: String) async throws  -> String
    
    func nip04Encrypt(publicKey: PublicKey, content: String) async throws  -> String
    
    func nip44Decrypt(publicKey: PublicKey, payload: String) async throws  -> String
    
    func nip44Encrypt(publicKey: PublicKey, content: String) async throws  -> String
    
    /**
     * Get signer relays
     */
    func relays()  -> [RelayUrl]
    
    func signEvent(unsignedEvent: UnsignedEvent) async throws  -> Event
    
}
open class NostrConnect: NostrConnectProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrconnect(self.pointer, $0) }
    }
    /**
     * Construct Nostr Connect client
     */
public convenience init(uri: NostrConnectUri, appKeys: Keys, timeout: TimeInterval, opts: RelayOptions?)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrconnect_new(
        FfiConverterTypeNostrConnectURI_lower(uri),
        FfiConverterTypeKeys_lower(appKeys),
        FfiConverterDuration.lower(timeout),
        FfiConverterOptionTypeRelayOptions.lower(opts),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrconnect(pointer, $0) }
    }

    

    
    /**
     * Get `bunker` URI
     */
open func bunkerUri()async throws  -> NostrConnectUri  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrconnect_bunker_uri(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNostrConnectURI_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func getPublicKey()async throws  -> PublicKey  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrconnect_get_public_key(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypePublicKey_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func nip04Decrypt(publicKey: PublicKey, encryptedContent: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip04_decrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(encryptedContent)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func nip04Encrypt(publicKey: PublicKey, content: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip04_encrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func nip44Decrypt(publicKey: PublicKey, payload: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip44_decrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(payload)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func nip44Encrypt(publicKey: PublicKey, content: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrconnect_nip44_encrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Get signer relays
     */
open func relays() -> [RelayUrl]  {
    return try!  FfiConverterSequenceTypeRelayUrl.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrconnect_relays(self.uniffiClonePointer(),$0
    )
})
}
    
open func signEvent(unsignedEvent: UnsignedEvent)async throws  -> Event  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrconnect_sign_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUnsignedEvent_lower(unsignedEvent)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvent_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNostrConnect: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrConnect

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnect {
        return NostrConnect(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrConnect) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnect {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrConnect, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrConnect_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnect {
    return try FfiConverterTypeNostrConnect.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrConnect_lower(_ value: NostrConnect) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrConnect.lower(value)
}






public protocol NostrConnectMetadataProtocol: AnyObject, Sendable {
    
    /**
     * Serialize as JSON string
     */
    func asJson() throws  -> String
    
    /**
     * Description of the `App`
     */
    func description(description: String)  -> NostrConnectMetadata
    
    /**
     * List of URLs for icons of the `App`
     */
    func icons(icons: [String])  -> NostrConnectMetadata
    
    /**
     * URL of the website requesting the connection
     */
    func url(url: String) throws  -> NostrConnectMetadata
    
}
open class NostrConnectMetadata: NostrConnectMetadataProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrconnectmetadata(self.pointer, $0) }
    }
    /**
     * New Nostr Connect Metadata
     */
public convenience init(name: String) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrconnectmetadata_new(
        FfiConverterString.lower(name),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrconnectmetadata(pointer, $0) }
    }

    

    
    /**
     * Serialize as JSON string
     */
open func asJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Description of the `App`
     */
open func description(description: String) -> NostrConnectMetadata  {
    return try!  FfiConverterTypeNostrConnectMetadata_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_description(self.uniffiClonePointer(),
        FfiConverterString.lower(description),$0
    )
})
}
    
    /**
     * List of URLs for icons of the `App`
     */
open func icons(icons: [String]) -> NostrConnectMetadata  {
    return try!  FfiConverterTypeNostrConnectMetadata_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_icons(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(icons),$0
    )
})
}
    
    /**
     * URL of the website requesting the connection
     */
open func url(url: String)throws  -> NostrConnectMetadata  {
    return try  FfiConverterTypeNostrConnectMetadata_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_url(self.uniffiClonePointer(),
        FfiConverterString.lower(url),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: NostrConnectMetadata, other: NostrConnectMetadata) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNostrConnectMetadata_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrconnectmetadata_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension NostrConnectMetadata: CustomDebugStringConvertible {}
extension NostrConnectMetadata: Equatable {}
extension NostrConnectMetadata: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNostrConnectMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrConnectMetadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectMetadata {
        return NostrConnectMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrConnectMetadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrConnectMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrConnectMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectMetadata {
    return try FfiConverterTypeNostrConnectMetadata.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrConnectMetadata_lower(_ value: NostrConnectMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrConnectMetadata.lower(value)
}






public protocol NostrConnectUriProtocol: AnyObject, Sendable {
    
}
open class NostrConnectUri: NostrConnectUriProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrconnecturi(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrconnecturi(pointer, $0) }
    }

    
public static func parse(uri: String)throws  -> NostrConnectUri  {
    return try  FfiConverterTypeNostrConnectURI_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrconnecturi_parse(
        FfiConverterString.lower(uri),$0
    )
})
}
    

    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: NostrConnectUri, other: NostrConnectUri) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNostrConnectURI_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrconnecturi_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension NostrConnectUri: CustomDebugStringConvertible {}
extension NostrConnectUri: CustomStringConvertible {}
extension NostrConnectUri: Equatable {}
extension NostrConnectUri: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNostrConnectURI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrConnectUri

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectUri {
        return NostrConnectUri(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrConnectUri) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectUri {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrConnectUri, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrConnectURI_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectUri {
    return try FfiConverterTypeNostrConnectURI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrConnectURI_lower(_ value: NostrConnectUri) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrConnectURI.lower(value)
}






public protocol NostrDatabaseProtocol: AnyObject, Sendable {
    
    func count(filter: Filter) async throws  -> UInt64
    
    /**
     * Delete all events that match the `Filter`
     */
    func delete(filter: Filter) async throws 
    
    /**
     * Get [`Event`] by [`EventId`]
     */
    func eventById(eventId: EventId) async throws  -> Event?
    
    func metadata(publicKey: PublicKey) async throws  -> Metadata?
    
    func query(filter: Filter) async throws  -> Events
    
    /**
     * Save [`Event`] into store
     */
    func saveEvent(event: Event) async throws  -> SaveEventStatus
    
    /**
     * Wipe all data
     */
    func wipe() async throws 
    
}
open class NostrDatabase: NostrDatabaseProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrdatabase(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrdatabase(pointer, $0) }
    }

    
    /**
     * Open a custom nostr database
     */
public static func custom(database: CustomNostrDatabase) -> NostrDatabase  {
    return try!  FfiConverterTypeNostrDatabase_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_custom(
        FfiConverterTypeCustomNostrDatabase_lower(database),$0
    )
})
}
    
    /**
     * LMDB backend
     */
public static func lmdb(path: String)throws  -> NostrDatabase  {
    return try  FfiConverterTypeNostrDatabase_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrdatabase_lmdb(
        FfiConverterString.lower(path),$0
    )
})
}
    

    
open func count(filter: Filter)async throws  -> UInt64  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_count(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Delete all events that match the `Filter`
     */
open func delete(filter: Filter)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_delete(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Get [`Event`] by [`EventId`]
     */
open func eventById(eventId: EventId)async throws  -> Event?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_event_by_id(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventId_lower(eventId)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeEvent.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func metadata(publicKey: PublicKey)async throws  -> Metadata?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeMetadata.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func query(filter: Filter)async throws  -> Events  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_query(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvents_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Save [`Event`] into store
     */
open func saveEvent(event: Event)async throws  -> SaveEventStatus  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_save_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeSaveEventStatus_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Wipe all data
     */
open func wipe()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrdatabase_wipe(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNostrDatabase: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrDatabase

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrDatabase {
        return NostrDatabase(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrDatabase) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrDatabase {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrDatabase, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrDatabase_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrDatabase {
    return try FfiConverterTypeNostrDatabase.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrDatabase_lower(_ value: NostrDatabase) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrDatabase.lower(value)
}






public protocol NostrGossipProtocol: AnyObject, Sendable {
    
}
open class NostrGossip: NostrGossipProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrgossip(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrgossip(pointer, $0) }
    }

    
    /**
     * Construct a new in-memory gossip store
     */
public static func inMemory() -> NostrGossip  {
    return try!  FfiConverterTypeNostrGossip_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrgossip_in_memory($0
    )
})
}
    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNostrGossip: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrGossip

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrGossip {
        return NostrGossip(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrGossip) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrGossip {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrGossip, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrGossip_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrGossip {
    return try FfiConverterTypeNostrGossip.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrGossip_lower(_ value: NostrGossip) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrGossip.lower(value)
}






/**
 * Nostr parser
 */
public protocol NostrParserProtocol: AnyObject, Sendable {
    
    /**
     * Parse text into tokens
     */
    func parse(text: String, opts: NostrParserOptions?)  -> [NostrParserToken]
    
}
/**
 * Nostr parser
 */
open class NostrParser: NostrParserProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrparser(self.pointer, $0) }
    }
    /**
     * Construct a new nostr parser
     *
     * It's suggested to construct this once and reuse it, to avoid regex re-compilation.
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrparser_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrparser(pointer, $0) }
    }

    

    
    /**
     * Parse text into tokens
     */
open func parse(text: String, opts: NostrParserOptions? = nil) -> [NostrParserToken]  {
    return try!  FfiConverterSequenceTypeNostrParserToken.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrparser_parse(self.uniffiClonePointer(),
        FfiConverterString.lower(text),
        FfiConverterOptionTypeNostrParserOptions.lower(opts),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNostrParser: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrParser

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrParser {
        return NostrParser(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrParser) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrParser {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrParser, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrParser_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrParser {
    return try FfiConverterTypeNostrParser.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrParser_lower(_ value: NostrParser) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrParser.lower(value)
}






public protocol NostrSignerProtocol: AnyObject, Sendable {
    
    func backend()  -> SignerBackend
    
    func getPublicKey() async throws  -> PublicKey
    
    func nip04Decrypt(publicKey: PublicKey, encryptedContent: String) async throws  -> String
    
    func nip04Encrypt(publicKey: PublicKey, content: String) async throws  -> String
    
    func nip44Decrypt(publicKey: PublicKey, payload: String) async throws  -> String
    
    func nip44Encrypt(publicKey: PublicKey, content: String) async throws  -> String
    
    func signEvent(unsignedEvent: UnsignedEvent) async throws  -> Event
    
}
open class NostrSigner: NostrSignerProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrsigner(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrsigner(pointer, $0) }
    }

    
public static func custom(custom: CustomNostrSigner) -> NostrSigner  {
    return try!  FfiConverterTypeNostrSigner_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_custom(
        FfiConverterTypeCustomNostrSigner_lower(custom),$0
    )
})
}
    
public static func keys(keys: Keys) -> NostrSigner  {
    return try!  FfiConverterTypeNostrSigner_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_keys(
        FfiConverterTypeKeys_lower(keys),$0
    )
})
}
    
public static func nostrConnect(connect: NostrConnect) -> NostrSigner  {
    return try!  FfiConverterTypeNostrSigner_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrsigner_nostr_connect(
        FfiConverterTypeNostrConnect_lower(connect),$0
    )
})
}
    

    
open func backend() -> SignerBackend  {
    return try!  FfiConverterTypeSignerBackend_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrsigner_backend(self.uniffiClonePointer(),$0
    )
})
}
    
open func getPublicKey()async throws  -> PublicKey  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_get_public_key(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypePublicKey_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func nip04Decrypt(publicKey: PublicKey, encryptedContent: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_decrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(encryptedContent)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func nip04Encrypt(publicKey: PublicKey, content: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip04_encrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func nip44Decrypt(publicKey: PublicKey, payload: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_decrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(payload)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func nip44Encrypt(publicKey: PublicKey, content: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_nip44_encrypt(
                    self.uniffiClonePointer(),
                    FfiConverterTypePublicKey_lower(publicKey),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
open func signEvent(unsignedEvent: UnsignedEvent)async throws  -> Event  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_nostrsigner_sign_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUnsignedEvent_lower(unsignedEvent)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvent_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNostrSigner: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrSigner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrSigner {
        return NostrSigner(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrSigner) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrSigner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrSigner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrSigner_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrSigner {
    return try FfiConverterTypeNostrSigner.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrSigner_lower(_ value: NostrSigner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrSigner.lower(value)
}






/**
 * NWC options
 */
public protocol NostrWalletConnectOptionsProtocol: AnyObject, Sendable {
    
    /**
     * Set relay options
     */
    func relay(opts: RelayOptions) throws  -> NostrWalletConnectOptions
    
    /**
     * Set NWC requests timeout (default: 10 secs)
     */
    func timeout(timeout: TimeInterval)  -> NostrWalletConnectOptions
    
}
/**
 * NWC options
 */
open class NostrWalletConnectOptions: NostrWalletConnectOptionsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrwalletconnectoptions(self.pointer, $0) }
    }
    /**
     * New default NWC options
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnectoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrwalletconnectoptions(pointer, $0) }
    }

    

    
    /**
     * Set relay options
     */
open func relay(opts: RelayOptions)throws  -> NostrWalletConnectOptions  {
    return try  FfiConverterTypeNostrWalletConnectOptions_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_relay(self.uniffiClonePointer(),
        FfiConverterTypeRelayOptions_lower(opts),$0
    )
})
}
    
    /**
     * Set NWC requests timeout (default: 10 secs)
     */
open func timeout(timeout: TimeInterval) -> NostrWalletConnectOptions  {
    return try!  FfiConverterTypeNostrWalletConnectOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnectoptions_timeout(self.uniffiClonePointer(),
        FfiConverterDuration.lower(timeout),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNostrWalletConnectOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrWalletConnectOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrWalletConnectOptions {
        return NostrWalletConnectOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrWalletConnectOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrWalletConnectOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrWalletConnectOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrWalletConnectOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrWalletConnectOptions {
    return try FfiConverterTypeNostrWalletConnectOptions.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrWalletConnectOptions_lower(_ value: NostrWalletConnectOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrWalletConnectOptions.lower(value)
}






/**
 * Nostr Connect URI
 */
public protocol NostrWalletConnectUriProtocol: AnyObject, Sendable {
    
    /**
     * A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured.
     */
    func lud16()  -> String?
    
    /**
     * App Pubkey
     */
    func publicKey()  -> PublicKey
    
    /**
     * URLs of the relays of choice where the `App` is connected and the `Signer` must send and listen for messages.
     */
    func relays()  -> [RelayUrl]
    
    /**
     * 32-byte randomly generated hex encoded string
     */
    func secret()  -> SecretKey
    
}
/**
 * Nostr Connect URI
 */
open class NostrWalletConnectUri: NostrWalletConnectUriProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_nostrwalletconnecturi(self.pointer, $0) }
    }
    /**
     * Create new Nostr Wallet Connect URI
     */
public convenience init(publicKey: PublicKey, relays: [RelayUrl], randomSecretKey: SecretKey, lud16: String?)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnecturi_new(
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterSequenceTypeRelayUrl.lower(relays),
        FfiConverterTypeSecretKey_lower(randomSecretKey),
        FfiConverterOptionString.lower(lud16),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_nostrwalletconnecturi(pointer, $0) }
    }

    
public static func parse(uri: String)throws  -> NostrWalletConnectUri  {
    return try  FfiConverterTypeNostrWalletConnectURI_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_nostrwalletconnecturi_parse(
        FfiConverterString.lower(uri),$0
    )
})
}
    

    
    /**
     * A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured.
     */
open func lud16() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_lud16(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * App Pubkey
     */
open func publicKey() -> PublicKey  {
    return try!  FfiConverterTypePublicKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * URLs of the relays of choice where the `App` is connected and the `Signer` must send and listen for messages.
     */
open func relays() -> [RelayUrl]  {
    return try!  FfiConverterSequenceTypeRelayUrl.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_relays(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * 32-byte randomly generated hex encoded string
     */
open func secret() -> SecretKey  {
    return try!  FfiConverterTypeSecretKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_secret(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: NostrWalletConnectUri, other: NostrWalletConnectUri) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNostrWalletConnectURI_lower(other),$0
    )
}
        )
    }

}
extension NostrWalletConnectUri: CustomDebugStringConvertible {}
extension NostrWalletConnectUri: CustomStringConvertible {}
extension NostrWalletConnectUri: Equatable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNostrWalletConnectURI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrWalletConnectUri

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrWalletConnectUri {
        return NostrWalletConnectUri(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrWalletConnectUri) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrWalletConnectUri {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrWalletConnectUri, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrWalletConnectURI_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrWalletConnectUri {
    return try FfiConverterTypeNostrWalletConnectURI.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrWalletConnectURI_lower(_ value: NostrWalletConnectUri) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrWalletConnectURI.lower(value)
}






public protocol PublicKeyProtocol: AnyObject, Sendable {
    
    func toBech32() throws  -> String
    
    func toHex()  -> String
    
    func toNostrUri() throws  -> String
    
}
open class PublicKey: PublicKeyProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_publickey(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_publickey(pointer, $0) }
    }

    
public static func fromBytes(bytes: Data)throws  -> PublicKey  {
    return try  FfiConverterTypePublicKey_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_publickey_from_bytes(
        FfiConverterData.lower(bytes),$0
    )
})
}
    
    /**
     * Try to parse public key from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
     */
public static func parse(publicKey: String)throws  -> PublicKey  {
    return try  FfiConverterTypePublicKey_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_publickey_parse(
        FfiConverterString.lower(publicKey),$0
    )
})
}
    

    
open func toBech32()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_publickey_to_bech32(self.uniffiClonePointer(),$0
    )
})
}
    
open func toHex() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_publickey_to_hex(self.uniffiClonePointer(),$0
    )
})
}
    
open func toNostrUri()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_publickey_to_nostr_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: PublicKey, other: PublicKey) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypePublicKey_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_publickey_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension PublicKey: CustomDebugStringConvertible {}
extension PublicKey: Equatable {}
extension PublicKey: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePublicKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PublicKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PublicKey {
        return PublicKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PublicKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypePublicKey.lower(value)
}






/**
 * Filters REQ's to the internal relay database
 */
public protocol QueryPolicy: AnyObject, Sendable {
    
    /**
     * Check if the policy should accept a query
     */
    func admitQuery(query: Filter, socketAddr: String) async  -> PolicyResult
    
}
/**
 * Filters REQ's to the internal relay database
 */
open class QueryPolicyImpl: QueryPolicy, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_querypolicy(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_querypolicy(pointer, $0) }
    }

    

    
    /**
     * Check if the policy should accept a query
     */
open func admitQuery(query: Filter, socketAddr: String)async  -> PolicyResult  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_querypolicy_admit_query(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(query),FfiConverterString.lower(socketAddr)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePolicyResult_lift,
            errorHandler: nil
            
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceQueryPolicy {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceQueryPolicy] = [UniffiVTableCallbackInterfaceQueryPolicy(
        admitQuery: { (
            uniffiHandle: UInt64,
            query: UnsafeMutableRawPointer,
            socketAddr: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> PolicyResult in
                guard let uniffiObj = try? FfiConverterTypeQueryPolicy.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.admitQuery(
                     query: try FfiConverterTypeFilter_lift(query),
                     socketAddr: try FfiConverterString.lift(socketAddr)
                )
            }

            let uniffiHandleSuccess = { (returnValue: PolicyResult) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypePolicyResult_lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeQueryPolicy.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface QueryPolicy: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitQueryPolicy() {
    uniffi_nostr_sdk_ffi_fn_init_callback_vtable_querypolicy(UniffiCallbackInterfaceQueryPolicy.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeQueryPolicy: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<QueryPolicy>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = QueryPolicy

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> QueryPolicy {
        return QueryPolicyImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: QueryPolicy) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QueryPolicy {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: QueryPolicy, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQueryPolicy_lift(_ pointer: UnsafeMutableRawPointer) throws -> QueryPolicy {
    return try FfiConverterTypeQueryPolicy.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQueryPolicy_lower(_ value: QueryPolicy) -> UnsafeMutableRawPointer {
    return FfiConverterTypeQueryPolicy.lower(value)
}






public protocol RelayProtocol: AnyObject, Sendable {
    
    /**
     * Ban relay and set status to `Banned`.
     *
     * A banned relay can't reconnect again.
     */
    func ban() 
    
    /**
     * Send multiple `ClientMessage` at once
     */
    func batchMsg(msgs: [ClientMessage]) throws 
    
    /**
     * Connect to the relay
     *
     * # Overview
     *
     * If the relays status is not [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`],
     * this method returns immediately without doing anything.
     * Otherwise, the connection task will be spawned, which will attempt to connect to relay.
     *
     * This method returns immediately and doesn't provide any information on if the connection was successful or not.
     *
     * # Automatic reconnection
     *
     * By default, in case of disconnection, the connection task will automatically attempt to reconnect.
     * This behavior can be disabled by changing [`RelayOptions::reconnect`] option.
     */
    func connect() 
    
    /**
     * Get connection mode
     */
    func connectionMode()  -> ConnectionMode
    
    /**
     * Count events
     */
    func countEvents(filter: Filter, timeout: TimeInterval) async throws  -> UInt64
    
    /**
     * Disconnect from relay and set status to `Terminated`
     */
    func disconnect() 
    
    /**
     * Fetch events
     */
    func fetchEvents(filter: Filter, timeout: TimeInterval, policy: ReqExitPolicy) async throws  -> Events
    
    /**
     * Check if `Relay` is connected
     */
    func isConnected()  -> Bool
    
    func opts()  -> RelayOptions
    
    /**
     * Get number of messages in queue
     */
    func queue()  -> UInt64
    
    /**
     * Send event and wait for `OK` relay msg
     */
    func sendEvent(event: Event) async throws  -> EventId
    
    /**
     * Send msg to relay
     */
    func sendMsg(msg: ClientMessage) throws 
    
    func stats()  -> RelayConnectionStats
    
    /**
     * Get status
     */
    func status()  -> RelayStatus
    
    /**
     * Subscribe to filters
     *
     * Internally generate a new random subscription ID. Check `subscribe_with_id` method to use a custom subscription ID.
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
    func subscribe(filter: Filter, opts: SubscribeOptions) async throws  -> String
    
    /**
     * Subscribe with custom subscription ID
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
    func subscribeWithId(id: String, filter: Filter, opts: SubscribeOptions) async throws 
    
    /**
     * Get filters by subscription ID
     */
    func subscription(id: String) async  -> [Filter]?
    
    func subscriptions() async  -> [String: [Filter]]
    
    /**
     * Sync events with relays (negentropy reconciliation)
     */
    func sync(filter: Filter, opts: SyncOptions) async throws  -> Reconciliation
    
    /**
     * Sync events with relays (negentropy reconciliation)
     */
    func syncWithItems(filter: Filter, items: [NegentropyItem], opts: SyncOptions) async throws  -> Reconciliation
    
    /**
     * Try to establish a connection with the relay.
     *
     * # Overview
     *
     * If the relays status is not [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`],
     * this method returns immediately without doing anything.
     * Otherwise, attempts to establish a connection without spawning the connection task if it fails.
     * This means that if the connection fails, no automatic retries are scheduled.
     * Use [`Relay::connect`] if you want to immediately spawn a connection task,
     * regardless of whether the initial connection succeeds.
     *
     * Returns an error if the connection fails.
     *
     * # Automatic reconnection
     *
     * By default, in case of disconnection (after a first successful connection),
     * the connection task will automatically attempt to reconnect.
     * This behavior can be disabled by changing [`RelayOptions::reconnect`] option.
     */
    func tryConnect(timeout: TimeInterval) async throws 
    
    /**
     * Unsubscribe
     */
    func unsubscribe(id: String) async throws 
    
    /**
     * Unsubscribe from all subscriptions
     */
    func unsubscribeAll() async throws 
    
    /**
     * Get relay url
     */
    func url()  -> RelayUrl
    
}
open class Relay: RelayProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relay(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relay(pointer, $0) }
    }

    

    
    /**
     * Ban relay and set status to `Banned`.
     *
     * A banned relay can't reconnect again.
     */
open func ban()  {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_ban(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Send multiple `ClientMessage` at once
     */
open func batchMsg(msgs: [ClientMessage])throws   {try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_batch_msg(self.uniffiClonePointer(),
        FfiConverterSequenceTypeClientMessage.lower(msgs),$0
    )
}
}
    
    /**
     * Connect to the relay
     *
     * # Overview
     *
     * If the relays status is not [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`],
     * this method returns immediately without doing anything.
     * Otherwise, the connection task will be spawned, which will attempt to connect to relay.
     *
     * This method returns immediately and doesn't provide any information on if the connection was successful or not.
     *
     * # Automatic reconnection
     *
     * By default, in case of disconnection, the connection task will automatically attempt to reconnect.
     * This behavior can be disabled by changing [`RelayOptions::reconnect`] option.
     */
open func connect()  {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_connect(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Get connection mode
     */
open func connectionMode() -> ConnectionMode  {
    return try!  FfiConverterTypeConnectionMode_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_connection_mode(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Count events
     */
open func countEvents(filter: Filter, timeout: TimeInterval)async throws  -> UInt64  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_count_events(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Disconnect from relay and set status to `Terminated`
     */
open func disconnect()  {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_disconnect(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Fetch events
     */
open func fetchEvents(filter: Filter, timeout: TimeInterval, policy: ReqExitPolicy)async throws  -> Events  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_fetch_events(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterDuration.lower(timeout),FfiConverterTypeReqExitPolicy_lower(policy)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvents_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Check if `Relay` is connected
     */
open func isConnected() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_is_connected(self.uniffiClonePointer(),$0
    )
})
}
    
open func opts() -> RelayOptions  {
    return try!  FfiConverterTypeRelayOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_opts(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get number of messages in queue
     */
open func queue() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_queue(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Send event and wait for `OK` relay msg
     */
open func sendEvent(event: Event)async throws  -> EventId  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_send_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEventId_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Send msg to relay
     */
open func sendMsg(msg: ClientMessage)throws   {try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_relay_send_msg(self.uniffiClonePointer(),
        FfiConverterTypeClientMessage_lower(msg),$0
    )
}
}
    
open func stats() -> RelayConnectionStats  {
    return try!  FfiConverterTypeRelayConnectionStats_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_stats(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get status
     */
open func status() -> RelayStatus  {
    return try!  FfiConverterTypeRelayStatus_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_status(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Subscribe to filters
     *
     * Internally generate a new random subscription ID. Check `subscribe_with_id` method to use a custom subscription ID.
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
open func subscribe(filter: Filter, opts: SubscribeOptions)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_subscribe(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterTypeSubscribeOptions_lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Subscribe with custom subscription ID
     *
     * ### Auto-closing subscription
     *
     * It's possible to automatically close a subscription by configuring the `SubscribeOptions`.
     *
     * Note: auto-closing subscriptions aren't saved in subscriptions map!
     */
open func subscribeWithId(id: String, filter: Filter, opts: SubscribeOptions)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_subscribe_with_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id),FfiConverterTypeFilter_lower(filter),FfiConverterTypeSubscribeOptions_lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Get filters by subscription ID
     */
open func subscription(id: String)async  -> [Filter]?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_subscription(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
open func subscriptions()async  -> [String: [Filter]]  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_subscriptions(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringSequenceTypeFilter.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Sync events with relays (negentropy reconciliation)
     */
open func sync(filter: Filter, opts: SyncOptions)async throws  -> Reconciliation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_sync(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterTypeSyncOptions_lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeReconciliation_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Sync events with relays (negentropy reconciliation)
     */
open func syncWithItems(filter: Filter, items: [NegentropyItem], opts: SyncOptions)async throws  -> Reconciliation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_sync_with_items(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFilter_lower(filter),FfiConverterSequenceTypeNegentropyItem.lower(items),FfiConverterTypeSyncOptions_lower(opts)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeReconciliation_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Try to establish a connection with the relay.
     *
     * # Overview
     *
     * If the relays status is not [`RelayStatus::Initialized`] or [`RelayStatus::Terminated`],
     * this method returns immediately without doing anything.
     * Otherwise, attempts to establish a connection without spawning the connection task if it fails.
     * This means that if the connection fails, no automatic retries are scheduled.
     * Use [`Relay::connect`] if you want to immediately spawn a connection task,
     * regardless of whether the initial connection succeeds.
     *
     * Returns an error if the connection fails.
     *
     * # Automatic reconnection
     *
     * By default, in case of disconnection (after a first successful connection),
     * the connection task will automatically attempt to reconnect.
     * This behavior can be disabled by changing [`RelayOptions::reconnect`] option.
     */
open func tryConnect(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_try_connect(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Unsubscribe
     */
open func unsubscribe(id: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Unsubscribe from all subscriptions
     */
open func unsubscribeAll()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_relay_unsubscribe_all(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Get relay url
     */
open func url() -> RelayUrl  {
    return try!  FfiConverterTypeRelayUrl_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relay_url(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRelay: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Relay

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Relay {
        return Relay(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Relay) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Relay {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Relay, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelay_lift(_ pointer: UnsafeMutableRawPointer) throws -> Relay {
    return try FfiConverterTypeRelay.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelay_lower(_ value: Relay) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelay.lower(value)
}






/**
 * Relay builder
 */
public protocol RelayBuilderProtocol: AnyObject, Sendable {
    
    /**
     * Set IP address
     */
    func addr(ipAddr: String) throws  -> RelayBuilder
    
    /**
     * If enabled, NIP-42 will be used for DMs, returning GiftWrap events for
     * the mentioned public key only.
     */
    func authDm(enable: Bool)  -> RelayBuilder
    
    /**
     * Set database
     */
    func database(database: NostrDatabase)  -> RelayBuilder
    
    /**
     * Sets the default filter limit when no limit is specified. Defaults 500.
     */
    func defaultFilterLimit(limit: UInt64)  -> RelayBuilder
    
    /**
     * Set number of max connections allowed
     */
    func maxConnections(max: UInt64)  -> RelayBuilder
    
    /**
     * Sets the maximum limit for the filter. If the filter's limit exceeds
     * this value, it will fallback to this number.
     */
    func maxFilterLimit(max: UInt64)  -> RelayBuilder
    
    /**
     * Sets the maximum subscription ID length. Defaults 250.
     */
    func maxSubidLength(max: UInt64)  -> RelayBuilder
    
    /**
     * Sets the minimum Proof of Work difficulty.
     *
     * Only values `> 0` are accepted!
     */
    func minPow(difficulty: UInt8)  -> RelayBuilder
    
    /**
     * Require NIP42 authentication
     */
    func nip42(opts: RelayBuilderNip42)  -> RelayBuilder
    
    /**
     * Set port
     */
    func port(port: UInt16)  -> RelayBuilder
    
    /**
     * Add a query policy plugin
     */
    func queryPolicy(policy: QueryPolicy)  -> RelayBuilder
    
    /**
     * Set rate limit
     */
    func rateLimit(limit: RateLimit)  -> RelayBuilder
    
    /**
     * Add a write policy plugin
     */
    func writePolicy(policy: WritePolicy)  -> RelayBuilder
    
}
/**
 * Relay builder
 */
open class RelayBuilder: RelayBuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relaybuilder(self.pointer, $0) }
    }
    /**
     * Construct new default relay builder
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaybuilder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relaybuilder(pointer, $0) }
    }

    

    
    /**
     * Set IP address
     */
open func addr(ipAddr: String)throws  -> RelayBuilder  {
    return try  FfiConverterTypeRelayBuilder_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaybuilder_addr(self.uniffiClonePointer(),
        FfiConverterString.lower(ipAddr),$0
    )
})
}
    
    /**
     * If enabled, NIP-42 will be used for DMs, returning GiftWrap events for
     * the mentioned public key only.
     */
open func authDm(enable: Bool) -> RelayBuilder  {
    return try!  FfiConverterTypeRelayBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaybuilder_auth_dm(self.uniffiClonePointer(),
        FfiConverterBool.lower(enable),$0
    )
})
}
    
    /**
     * Set database
     */
open func database(database: NostrDatabase) -> RelayBuilder  {
    return try!  FfiConverterTypeRelayBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaybuilder_database(self.uniffiClonePointer(),
        FfiConverterTypeNostrDatabase_lower(database),$0
    )
})
}
    
    /**
     * Sets the default filter limit when no limit is specified. Defaults 500.
     */
open func defaultFilterLimit(limit: UInt64) -> RelayBuilder  {
    return try!  FfiConverterTypeRelayBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaybuilder_default_filter_limit(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(limit),$0
    )
})
}
    
    /**
     * Set number of max connections allowed
     */
open func maxConnections(max: UInt64) -> RelayBuilder  {
    return try!  FfiConverterTypeRelayBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaybuilder_max_connections(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(max),$0
    )
})
}
    
    /**
     * Sets the maximum limit for the filter. If the filter's limit exceeds
     * this value, it will fallback to this number.
     */
open func maxFilterLimit(max: UInt64) -> RelayBuilder  {
    return try!  FfiConverterTypeRelayBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaybuilder_max_filter_limit(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(max),$0
    )
})
}
    
    /**
     * Sets the maximum subscription ID length. Defaults 250.
     */
open func maxSubidLength(max: UInt64) -> RelayBuilder  {
    return try!  FfiConverterTypeRelayBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaybuilder_max_subid_length(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(max),$0
    )
})
}
    
    /**
     * Sets the minimum Proof of Work difficulty.
     *
     * Only values `> 0` are accepted!
     */
open func minPow(difficulty: UInt8) -> RelayBuilder  {
    return try!  FfiConverterTypeRelayBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaybuilder_min_pow(self.uniffiClonePointer(),
        FfiConverterUInt8.lower(difficulty),$0
    )
})
}
    
    /**
     * Require NIP42 authentication
     */
open func nip42(opts: RelayBuilderNip42) -> RelayBuilder  {
    return try!  FfiConverterTypeRelayBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaybuilder_nip42(self.uniffiClonePointer(),
        FfiConverterTypeRelayBuilderNip42_lower(opts),$0
    )
})
}
    
    /**
     * Set port
     */
open func port(port: UInt16) -> RelayBuilder  {
    return try!  FfiConverterTypeRelayBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaybuilder_port(self.uniffiClonePointer(),
        FfiConverterUInt16.lower(port),$0
    )
})
}
    
    /**
     * Add a query policy plugin
     */
open func queryPolicy(policy: QueryPolicy) -> RelayBuilder  {
    return try!  FfiConverterTypeRelayBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaybuilder_query_policy(self.uniffiClonePointer(),
        FfiConverterTypeQueryPolicy_lower(policy),$0
    )
})
}
    
    /**
     * Set rate limit
     */
open func rateLimit(limit: RateLimit) -> RelayBuilder  {
    return try!  FfiConverterTypeRelayBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaybuilder_rate_limit(self.uniffiClonePointer(),
        FfiConverterTypeRateLimit_lower(limit),$0
    )
})
}
    
    /**
     * Add a write policy plugin
     */
open func writePolicy(policy: WritePolicy) -> RelayBuilder  {
    return try!  FfiConverterTypeRelayBuilder_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaybuilder_write_policy(self.uniffiClonePointer(),
        FfiConverterTypeWritePolicy_lower(policy),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRelayBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayBuilder {
        return RelayBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayBuilder {
    return try FfiConverterTypeRelayBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayBuilder_lower(_ value: RelayBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayBuilder.lower(value)
}






public protocol RelayConnectionStatsProtocol: AnyObject, Sendable {
    
    /**
     * The number of times a connection has been attempted
     */
    func attempts()  -> UInt64
    
    /**
     * Bytes received
     */
    func bytesReceived()  -> UInt64
    
    /**
     * Bytes sent
     */
    func bytesSent()  -> UInt64
    
    /**
     * Get UNIX timestamp of the last connection
     */
    func connectedAt()  -> Timestamp
    
    /**
     * Get UNIX timestamp of the first connection
     */
    func firstConnectionTimestamp()  -> Timestamp
    
    func latency()  -> TimeInterval?
    
    /**
     * The number of times a connection has been successfully established
     */
    func success()  -> UInt64
    
    /**
     * Success rate
     */
    func successRate()  -> Double
    
}
open class RelayConnectionStats: RelayConnectionStatsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relayconnectionstats(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relayconnectionstats(pointer, $0) }
    }

    

    
    /**
     * The number of times a connection has been attempted
     */
open func attempts() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_attempts(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Bytes received
     */
open func bytesReceived() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_received(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Bytes sent
     */
open func bytesSent() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_bytes_sent(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get UNIX timestamp of the last connection
     */
open func connectedAt() -> Timestamp  {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_connected_at(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get UNIX timestamp of the first connection
     */
open func firstConnectionTimestamp() -> Timestamp  {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_first_connection_timestamp(self.uniffiClonePointer(),$0
    )
})
}
    
open func latency() -> TimeInterval?  {
    return try!  FfiConverterOptionDuration.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_latency(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The number of times a connection has been successfully established
     */
open func success() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_success(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Success rate
     */
open func successRate() -> Double  {
    return try!  FfiConverterDouble.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayconnectionstats_success_rate(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRelayConnectionStats: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayConnectionStats

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayConnectionStats {
        return RelayConnectionStats(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayConnectionStats) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayConnectionStats {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayConnectionStats, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayConnectionStats_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayConnectionStats {
    return try FfiConverterTypeRelayConnectionStats.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayConnectionStats_lower(_ value: RelayConnectionStats) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayConnectionStats.lower(value)
}






public protocol RelayInformationDocumentProtocol: AnyObject, Sendable {
    
    /**
     * Serialize as JSON
     */
    func asJson() throws  -> String
    
    func contact()  -> String?
    
    func description()  -> String?
    
    func fees()  -> FeeSchedules?
    
    func icon()  -> String?
    
    func languageTags()  -> [String]
    
    func limitation()  -> Limitation?
    
    func name()  -> String?
    
    func paymentsUrl()  -> String?
    
    func postingPolicy()  -> String?
    
    func pubkey()  -> String?
    
    func relayCountries()  -> [String]
    
    func retention()  -> [Retention]
    
    func software()  -> String?
    
    func supportedNips()  -> [UInt16]?
    
    func tags()  -> [String]
    
    func version()  -> String?
    
}
open class RelayInformationDocument: RelayInformationDocumentProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relayinformationdocument(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relayinformationdocument(pointer, $0) }
    }

    
    /**
     * Parse NIP-11 relay information document from JSON
     */
public static func fromJson(json: String)throws  -> RelayInformationDocument  {
    return try  FfiConverterTypeRelayInformationDocument_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_relayinformationdocument_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    

    
    /**
     * Serialize as JSON
     */
open func asJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
open func contact() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_contact(self.uniffiClonePointer(),$0
    )
})
}
    
open func description() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_description(self.uniffiClonePointer(),$0
    )
})
}
    
open func fees() -> FeeSchedules?  {
    return try!  FfiConverterOptionTypeFeeSchedules.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_fees(self.uniffiClonePointer(),$0
    )
})
}
    
open func icon() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_icon(self.uniffiClonePointer(),$0
    )
})
}
    
open func languageTags() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_language_tags(self.uniffiClonePointer(),$0
    )
})
}
    
open func limitation() -> Limitation?  {
    return try!  FfiConverterOptionTypeLimitation.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_limitation(self.uniffiClonePointer(),$0
    )
})
}
    
open func name() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_name(self.uniffiClonePointer(),$0
    )
})
}
    
open func paymentsUrl() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_payments_url(self.uniffiClonePointer(),$0
    )
})
}
    
open func postingPolicy() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_posting_policy(self.uniffiClonePointer(),$0
    )
})
}
    
open func pubkey() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_pubkey(self.uniffiClonePointer(),$0
    )
})
}
    
open func relayCountries() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_relay_countries(self.uniffiClonePointer(),$0
    )
})
}
    
open func retention() -> [Retention]  {
    return try!  FfiConverterSequenceTypeRetention.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_retention(self.uniffiClonePointer(),$0
    )
})
}
    
open func software() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_software(self.uniffiClonePointer(),$0
    )
})
}
    
open func supportedNips() -> [UInt16]?  {
    return try!  FfiConverterOptionSequenceUInt16.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_supported_nips(self.uniffiClonePointer(),$0
    )
})
}
    
open func tags() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_tags(self.uniffiClonePointer(),$0
    )
})
}
    
open func version() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_version(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: RelayInformationDocument, other: RelayInformationDocument) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeRelayInformationDocument_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayinformationdocument_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension RelayInformationDocument: CustomDebugStringConvertible {}
extension RelayInformationDocument: Equatable {}
extension RelayInformationDocument: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRelayInformationDocument: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayInformationDocument

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayInformationDocument {
        return RelayInformationDocument(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayInformationDocument) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayInformationDocument {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayInformationDocument, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayInformationDocument_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayInformationDocument {
    return try FfiConverterTypeRelayInformationDocument.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayInformationDocument_lower(_ value: RelayInformationDocument) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayInformationDocument.lower(value)
}






/**
 * Relay Limits
 */
public protocol RelayLimitsProtocol: AnyObject, Sendable {
    
    /**
     * Maximum number of tags allowed (default: 2_000)
     */
    func eventMaxNumTags(maxNumTags: UInt16?)  -> RelayLimits
    
    /**
     * Maximum number of tags allowed per kind
     */
    func eventMaxNumTagsPerKind(kind: Kind, maxNumTags: UInt16?)  -> RelayLimits
    
    /**
     * Maximum size of normalized JSON, in bytes (default: None)
     */
    func eventMaxSize(maxSize: UInt32?)  -> RelayLimits
    
    /**
     * Maximum size per kind of normalised JSON, in bytes.
     */
    func eventMaxSizePerKind(kind: Kind, maxSize: UInt32?)  -> RelayLimits
    
    /**
     * Maximum size of normalized JSON, in bytes (default: 5MB)
     */
    func messageMaxSize(maxSize: UInt32?)  -> RelayLimits
    
}
/**
 * Relay Limits
 */
open class RelayLimits: RelayLimitsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relaylimits(self.pointer, $0) }
    }
    /**
     * Construct with default limits
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relaylimits(pointer, $0) }
    }

    
    /**
     * Disable all limits
     */
public static func disable() -> RelayLimits  {
    return try!  FfiConverterTypeRelayLimits_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaylimits_disable($0
    )
})
}
    

    
    /**
     * Maximum number of tags allowed (default: 2_000)
     */
open func eventMaxNumTags(maxNumTags: UInt16?) -> RelayLimits  {
    return try!  FfiConverterTypeRelayLimits_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_num_tags(self.uniffiClonePointer(),
        FfiConverterOptionUInt16.lower(maxNumTags),$0
    )
})
}
    
    /**
     * Maximum number of tags allowed per kind
     */
open func eventMaxNumTagsPerKind(kind: Kind, maxNumTags: UInt16?) -> RelayLimits  {
    return try!  FfiConverterTypeRelayLimits_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_num_tags_per_kind(self.uniffiClonePointer(),
        FfiConverterTypeKind_lower(kind),
        FfiConverterOptionUInt16.lower(maxNumTags),$0
    )
})
}
    
    /**
     * Maximum size of normalized JSON, in bytes (default: None)
     */
open func eventMaxSize(maxSize: UInt32?) -> RelayLimits  {
    return try!  FfiConverterTypeRelayLimits_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_size(self.uniffiClonePointer(),
        FfiConverterOptionUInt32.lower(maxSize),$0
    )
})
}
    
    /**
     * Maximum size per kind of normalised JSON, in bytes.
     */
open func eventMaxSizePerKind(kind: Kind, maxSize: UInt32?) -> RelayLimits  {
    return try!  FfiConverterTypeRelayLimits_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_event_max_size_per_kind(self.uniffiClonePointer(),
        FfiConverterTypeKind_lower(kind),
        FfiConverterOptionUInt32.lower(maxSize),$0
    )
})
}
    
    /**
     * Maximum size of normalized JSON, in bytes (default: 5MB)
     */
open func messageMaxSize(maxSize: UInt32?) -> RelayLimits  {
    return try!  FfiConverterTypeRelayLimits_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_message_max_size(self.uniffiClonePointer(),
        FfiConverterOptionUInt32.lower(maxSize),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: RelayLimits, other: RelayLimits) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaylimits_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeRelayLimits_lower(other),$0
    )
}
        )
    }

}
extension RelayLimits: CustomDebugStringConvertible {}
extension RelayLimits: Equatable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRelayLimits: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayLimits

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayLimits {
        return RelayLimits(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayLimits) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayLimits {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayLimits, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayLimits_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayLimits {
    return try FfiConverterTypeRelayLimits.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayLimits_lower(_ value: RelayLimits) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayLimits.lower(value)
}






public protocol RelayMessageProtocol: AnyObject, Sendable {
    
    /**
     * Clone `RelayMessage` and convert it to `RelayMessageEnum`
     */
    func asEnum()  -> RelayMessageEnum
    
    func asJson() throws  -> String
    
}
open class RelayMessage: RelayMessageProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relaymessage(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relaymessage(pointer, $0) }
    }

    
    /**
     * Create new `AUTH` message
     */
public static func auth(challenge: String) -> RelayMessage  {
    return try!  FfiConverterTypeRelayMessage_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_auth(
        FfiConverterString.lower(challenge),$0
    )
})
}
    
    /**
     * Create new `CLOSED` message
     */
public static func closed(subscriptionId: String, message: String) -> RelayMessage  {
    return try!  FfiConverterTypeRelayMessage_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_closed(
        FfiConverterString.lower(subscriptionId),
        FfiConverterString.lower(message),$0
    )
})
}
    
    /**
     * Create new `EVENT` message
     */
public static func count(subscriptionId: String, count: Double) -> RelayMessage  {
    return try!  FfiConverterTypeRelayMessage_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_count(
        FfiConverterString.lower(subscriptionId),
        FfiConverterDouble.lower(count),$0
    )
})
}
    
    /**
     * Create new `EOSE` message
     */
public static func eose(subscriptionId: String) -> RelayMessage  {
    return try!  FfiConverterTypeRelayMessage_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_eose(
        FfiConverterString.lower(subscriptionId),$0
    )
})
}
    
    /**
     * Create new `EVENT` message
     */
public static func event(subscriptionId: String, event: Event) -> RelayMessage  {
    return try!  FfiConverterTypeRelayMessage_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_event(
        FfiConverterString.lower(subscriptionId),
        FfiConverterTypeEvent_lower(event),$0
    )
})
}
    
    /**
     * Convert `RelayMessageEnum` to `RelayMessage`
     */
public static func fromEnum(e: RelayMessageEnum) -> RelayMessage  {
    return try!  FfiConverterTypeRelayMessage_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_from_enum(
        FfiConverterTypeRelayMessageEnum_lower(e),$0
    )
})
}
    
    /**
     * Deserialize `RelayMessage` from JSON string
     *
     * **This method NOT verify the event signature!**
     */
public static func fromJson(json: String)throws  -> RelayMessage  {
    return try  FfiConverterTypeRelayMessage_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    
    /**
     * Create new `NOTICE` message
     */
public static func notice(message: String) -> RelayMessage  {
    return try!  FfiConverterTypeRelayMessage_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_notice(
        FfiConverterString.lower(message),$0
    )
})
}
    
    /**
     * Create new `OK` message
     */
public static func ok(eventId: EventId, status: Bool, message: String) -> RelayMessage  {
    return try!  FfiConverterTypeRelayMessage_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relaymessage_ok(
        FfiConverterTypeEventId_lower(eventId),
        FfiConverterBool.lower(status),
        FfiConverterString.lower(message),$0
    )
})
}
    

    
    /**
     * Clone `RelayMessage` and convert it to `RelayMessageEnum`
     */
open func asEnum() -> RelayMessageEnum  {
    return try!  FfiConverterTypeRelayMessageEnum_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaymessage_as_enum(self.uniffiClonePointer(),$0
    )
})
}
    
open func asJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_relaymessage_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: RelayMessage, other: RelayMessage) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeRelayMessage_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relaymessage_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension RelayMessage: CustomDebugStringConvertible {}
extension RelayMessage: Equatable {}
extension RelayMessage: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRelayMessage: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayMessage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayMessage {
        return RelayMessage(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayMessage) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayMessage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayMessage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayMessage_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayMessage {
    return try FfiConverterTypeRelayMessage.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayMessage_lower(_ value: RelayMessage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayMessage.lower(value)
}






/**
 * `Relay` options
 */
public protocol RelayOptionsProtocol: AnyObject, Sendable {
    
    /**
     * Automatically adjust retry interval based on success/attempts (default: true)
     */
    func adjustRetryInterval(adjustRetryInterval: Bool)  -> RelayOptions
    
    /**
     * If true, ban a relay when it sends an event that doesn't match the subscription filter.
     */
    func banRelayOnMismatch(enable: Bool)  -> RelayOptions
    
    /**
     * Set connection mode
     */
    func connectionMode(mode: ConnectionMode) throws  -> RelayOptions
    
    /**
     * Set custom limits
     */
    func limits(limits: RelayLimits)  -> RelayOptions
    
    /**
     * Set max latency (default: None)
     *
     * Relay with an avg. latency greater that this value will be skipped.
     */
    func maxAvgLatency(max: TimeInterval?)  -> RelayOptions
    
    /**
     * Set ping flag
     */
    func ping(ping: Bool)  -> RelayOptions
    
    /**
     * Set read flag
     */
    func read(read: Bool)  -> RelayOptions
    
    /**
     * Enable/disable auto reconnection (default: true)
     */
    func reconnect(reconnect: Bool)  -> RelayOptions
    
    /**
     * Retry interval (default: 10 sec)
     *
     * Minimum allowed value is `5 secs`
     */
    func retryInterval(interval: TimeInterval)  -> RelayOptions
    
    /**
     * Verify that received events belong to a subscription and match the filter.
     */
    func verifySubscriptions(enable: Bool)  -> RelayOptions
    
    /**
     * Set write flag
     */
    func write(write: Bool)  -> RelayOptions
    
}
/**
 * `Relay` options
 */
open class RelayOptions: RelayOptionsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relayoptions(self.pointer, $0) }
    }
    /**
     * New default relay options
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_relayoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relayoptions(pointer, $0) }
    }

    

    
    /**
     * Automatically adjust retry interval based on success/attempts (default: true)
     */
open func adjustRetryInterval(adjustRetryInterval: Bool) -> RelayOptions  {
    return try!  FfiConverterTypeRelayOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_adjust_retry_interval(self.uniffiClonePointer(),
        FfiConverterBool.lower(adjustRetryInterval),$0
    )
})
}
    
    /**
     * If true, ban a relay when it sends an event that doesn't match the subscription filter.
     */
open func banRelayOnMismatch(enable: Bool) -> RelayOptions  {
    return try!  FfiConverterTypeRelayOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_ban_relay_on_mismatch(self.uniffiClonePointer(),
        FfiConverterBool.lower(enable),$0
    )
})
}
    
    /**
     * Set connection mode
     */
open func connectionMode(mode: ConnectionMode)throws  -> RelayOptions  {
    return try  FfiConverterTypeRelayOptions_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_connection_mode(self.uniffiClonePointer(),
        FfiConverterTypeConnectionMode_lower(mode),$0
    )
})
}
    
    /**
     * Set custom limits
     */
open func limits(limits: RelayLimits) -> RelayOptions  {
    return try!  FfiConverterTypeRelayOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_limits(self.uniffiClonePointer(),
        FfiConverterTypeRelayLimits_lower(limits),$0
    )
})
}
    
    /**
     * Set max latency (default: None)
     *
     * Relay with an avg. latency greater that this value will be skipped.
     */
open func maxAvgLatency(max: TimeInterval?) -> RelayOptions  {
    return try!  FfiConverterTypeRelayOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_max_avg_latency(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(max),$0
    )
})
}
    
    /**
     * Set ping flag
     */
open func ping(ping: Bool) -> RelayOptions  {
    return try!  FfiConverterTypeRelayOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_ping(self.uniffiClonePointer(),
        FfiConverterBool.lower(ping),$0
    )
})
}
    
    /**
     * Set read flag
     */
open func read(read: Bool) -> RelayOptions  {
    return try!  FfiConverterTypeRelayOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_read(self.uniffiClonePointer(),
        FfiConverterBool.lower(read),$0
    )
})
}
    
    /**
     * Enable/disable auto reconnection (default: true)
     */
open func reconnect(reconnect: Bool) -> RelayOptions  {
    return try!  FfiConverterTypeRelayOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_reconnect(self.uniffiClonePointer(),
        FfiConverterBool.lower(reconnect),$0
    )
})
}
    
    /**
     * Retry interval (default: 10 sec)
     *
     * Minimum allowed value is `5 secs`
     */
open func retryInterval(interval: TimeInterval) -> RelayOptions  {
    return try!  FfiConverterTypeRelayOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_retry_interval(self.uniffiClonePointer(),
        FfiConverterDuration.lower(interval),$0
    )
})
}
    
    /**
     * Verify that received events belong to a subscription and match the filter.
     */
open func verifySubscriptions(enable: Bool) -> RelayOptions  {
    return try!  FfiConverterTypeRelayOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_verify_subscriptions(self.uniffiClonePointer(),
        FfiConverterBool.lower(enable),$0
    )
})
}
    
    /**
     * Set write flag
     */
open func write(write: Bool) -> RelayOptions  {
    return try!  FfiConverterTypeRelayOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayoptions_write(self.uniffiClonePointer(),
        FfiConverterBool.lower(write),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRelayOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayOptions {
        return RelayOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayOptions {
    return try FfiConverterTypeRelayOptions.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayOptions_lower(_ value: RelayOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayOptions.lower(value)
}






public protocol RelayUrlProtocol: AnyObject, Sendable {
    
    /**
     * Check if the host is a local network address.
     *
     * IPv4 address ranges:
     * - `127.0.0.0/8`
     * - `10.0.0.0/8`
     * - `172.16.0.0/12`
     * - `192.168.0.0/16`
     *
     * IPv6 address ranges:
     * - `::1`
     */
    func isLocalAddr()  -> Bool
    
    /**
     * Check if the URL is a hidden onion service address
     */
    func isOnion()  -> Bool
    
}
open class RelayUrl: RelayUrlProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_relayurl(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_relayurl(pointer, $0) }
    }

    
    /**
     * Parse a relay URL
     */
public static func parse(url: String)throws  -> RelayUrl  {
    return try  FfiConverterTypeRelayUrl_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_relayurl_parse(
        FfiConverterString.lower(url),$0
    )
})
}
    

    
    /**
     * Check if the host is a local network address.
     *
     * IPv4 address ranges:
     * - `127.0.0.0/8`
     * - `10.0.0.0/8`
     * - `172.16.0.0/12`
     * - `192.168.0.0/16`
     *
     * IPv6 address ranges:
     * - `::1`
     */
open func isLocalAddr() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayurl_is_local_addr(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if the URL is a hidden onion service address
     */
open func isOnion() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayurl_is_onion(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: RelayUrl, other: RelayUrl) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeRelayUrl_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_relayurl_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension RelayUrl: CustomDebugStringConvertible {}
extension RelayUrl: CustomStringConvertible {}
extension RelayUrl: Equatable {}
extension RelayUrl: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRelayUrl: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayUrl

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayUrl {
        return RelayUrl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayUrl) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayUrl {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayUrl, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayUrl_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayUrl {
    return try FfiConverterTypeRelayUrl.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayUrl_lower(_ value: RelayUrl) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayUrl.lower(value)
}






/**
 * NIP47 Request
 */
public protocol RequestProtocol: AnyObject, Sendable {
    
    func method()  -> Method
    
    func params()  -> RequestParams
    
}
/**
 * NIP47 Request
 */
open class Request: RequestProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_request(self.pointer, $0) }
    }
public convenience init(method: Method, params: RequestParams) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_request_new(
        FfiConverterTypeMethod_lower(method),
        FfiConverterTypeRequestParams_lower(params),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_request(pointer, $0) }
    }

    
public static func parse(json: String)throws  -> Request  {
    return try  FfiConverterTypeRequest_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_request_parse(
        FfiConverterString.lower(json),$0
    )
})
}
    

    
open func method() -> Method  {
    return try!  FfiConverterTypeMethod_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_request_method(self.uniffiClonePointer(),$0
    )
})
}
    
open func params() -> RequestParams  {
    return try!  FfiConverterTypeRequestParams_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_request_params(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Request, other: Request) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeRequest_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_request_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Request: CustomDebugStringConvertible {}
extension Request: Equatable {}
extension Request: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Request

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Request {
        return Request(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Request) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Request {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Request, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> Request {
    return try FfiConverterTypeRequest.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequest_lower(_ value: Request) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRequest.lower(value)
}






/**
 * NIP47 Response
 */
public protocol ResponseProtocol: AnyObject, Sendable {
    
}
/**
 * NIP47 Response
 */
open class Response: ResponseProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_response(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_response(pointer, $0) }
    }

    

    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_response_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Response, other: Response) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_response_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeResponse_lower(other),$0
    )
}
        )
    }

}
extension Response: CustomDebugStringConvertible {}
extension Response: Equatable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResponse: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Response

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Response {
        return Response(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Response) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Response {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Response, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResponse_lift(_ pointer: UnsafeMutableRawPointer) throws -> Response {
    return try FfiConverterTypeResponse.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResponse_lower(_ value: Response) -> UnsafeMutableRawPointer {
    return FfiConverterTypeResponse.lower(value)
}






/**
 * Save event status
 */
public protocol SaveEventStatusProtocol: AnyObject, Sendable {
    
    /**
     * The event has been successfully saved
     */
    func isSuccess()  -> Bool
    
    /**
     * Get rejection reason, if the event wasn't saved successfully
     */
    func rejectionReason()  -> RejectedReason?
    
}
/**
 * Save event status
 */
open class SaveEventStatus: SaveEventStatusProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_saveeventstatus(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_saveeventstatus(pointer, $0) }
    }

    
public static func rejected(reason: RejectedReason) -> SaveEventStatus  {
    return try!  FfiConverterTypeSaveEventStatus_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_saveeventstatus_rejected(
        FfiConverterTypeRejectedReason_lower(reason),$0
    )
})
}
    
public static func success() -> SaveEventStatus  {
    return try!  FfiConverterTypeSaveEventStatus_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_saveeventstatus_success($0
    )
})
}
    

    
    /**
     * The event has been successfully saved
     */
open func isSuccess() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_saveeventstatus_is_success(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get rejection reason, if the event wasn't saved successfully
     */
open func rejectionReason() -> RejectedReason?  {
    return try!  FfiConverterOptionTypeRejectedReason.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_saveeventstatus_rejection_reason(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSaveEventStatus: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SaveEventStatus

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SaveEventStatus {
        return SaveEventStatus(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SaveEventStatus) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SaveEventStatus {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SaveEventStatus, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSaveEventStatus_lift(_ pointer: UnsafeMutableRawPointer) throws -> SaveEventStatus {
    return try FfiConverterTypeSaveEventStatus.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSaveEventStatus_lower(_ value: SaveEventStatus) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSaveEventStatus.lower(value)
}






public protocol SecretKeyProtocol: AnyObject, Sendable {
    
    /**
     * Encrypt `SecretKey`
     *
     * By default, `LOG_N` is set to `16` and `KeySecurity` to `Unknown`.
     * To use custom values check `EncryptedSecretKey` constructor.
     */
    func encrypt(password: String) throws  -> EncryptedSecretKey
    
    func toBech32() throws  -> String
    
    func toHex()  -> String
    
}
open class SecretKey: SecretKeyProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_secretkey(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_secretkey(pointer, $0) }
    }

    
public static func fromBytes(bytes: Data)throws  -> SecretKey  {
    return try  FfiConverterTypeSecretKey_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_secretkey_from_bytes(
        FfiConverterData.lower(bytes),$0
    )
})
}
    
    /**
     * Generate random secret key
     */
public static func generate() -> SecretKey  {
    return try!  FfiConverterTypeSecretKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_secretkey_generate($0
    )
})
}
    
    /**
     * Try to parse secret key from `hex` or `bech32`
     */
public static func parse(secretKey: String)throws  -> SecretKey  {
    return try  FfiConverterTypeSecretKey_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_secretkey_parse(
        FfiConverterString.lower(secretKey),$0
    )
})
}
    

    
    /**
     * Encrypt `SecretKey`
     *
     * By default, `LOG_N` is set to `16` and `KeySecurity` to `Unknown`.
     * To use custom values check `EncryptedSecretKey` constructor.
     */
open func encrypt(password: String)throws  -> EncryptedSecretKey  {
    return try  FfiConverterTypeEncryptedSecretKey_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_secretkey_encrypt(self.uniffiClonePointer(),
        FfiConverterString.lower(password),$0
    )
})
}
    
open func toBech32()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_secretkey_to_bech32(self.uniffiClonePointer(),$0
    )
})
}
    
open func toHex() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_secretkey_to_hex(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_secretkey_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: SecretKey, other: SecretKey) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_secretkey_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeSecretKey_lower(other),$0
    )
}
        )
    }

}
extension SecretKey: CustomDebugStringConvertible {}
extension SecretKey: Equatable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecretKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SecretKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SecretKey {
        return SecretKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SecretKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecretKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SecretKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecretKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> SecretKey {
    return try FfiConverterTypeSecretKey.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecretKey_lower(_ value: SecretKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSecretKey.lower(value)
}






public protocol ShippingMethodProtocol: AnyObject, Sendable {
    
    /**
     * Get the product shipping cost of the shipping method
     */
    func getShippingCost()  -> ShippingCost
    
    /**
     * Set the name of the shipping method
     */
    func name(name: String)  -> ShippingMethod
    
    /**
     * Add a region to the shipping method
     */
    func regions(regions: [String])  -> ShippingMethod
    
}
open class ShippingMethod: ShippingMethodProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_shippingmethod(self.pointer, $0) }
    }
    /**
     * Create a new shipping method
     */
public convenience init(id: String, cost: Double) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_shippingmethod_new(
        FfiConverterString.lower(id),
        FfiConverterDouble.lower(cost),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_shippingmethod(pointer, $0) }
    }

    

    
    /**
     * Get the product shipping cost of the shipping method
     */
open func getShippingCost() -> ShippingCost  {
    return try!  FfiConverterTypeShippingCost_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_shippingmethod_get_shipping_cost(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Set the name of the shipping method
     */
open func name(name: String) -> ShippingMethod  {
    return try!  FfiConverterTypeShippingMethod_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_shippingmethod_name(self.uniffiClonePointer(),
        FfiConverterString.lower(name),$0
    )
})
}
    
    /**
     * Add a region to the shipping method
     */
open func regions(regions: [String]) -> ShippingMethod  {
    return try!  FfiConverterTypeShippingMethod_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_shippingmethod_regions(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(regions),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeShippingMethod: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ShippingMethod

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ShippingMethod {
        return ShippingMethod(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ShippingMethod) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShippingMethod {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ShippingMethod, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShippingMethod_lift(_ pointer: UnsafeMutableRawPointer) throws -> ShippingMethod {
    return try FfiConverterTypeShippingMethod.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShippingMethod_lower(_ value: ShippingMethod) -> UnsafeMutableRawPointer {
    return FfiConverterTypeShippingMethod.lower(value)
}






public protocol SingleLetterTagProtocol: AnyObject, Sendable {
    
    func isLowercase()  -> Bool
    
    func isUppercase()  -> Bool
    
}
open class SingleLetterTag: SingleLetterTagProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_singlelettertag(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_singlelettertag(pointer, $0) }
    }

    
public static func lowercase(character: Alphabet) -> SingleLetterTag  {
    return try!  FfiConverterTypeSingleLetterTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_singlelettertag_lowercase(
        FfiConverterTypeAlphabet_lower(character),$0
    )
})
}
    
public static func uppercase(character: Alphabet) -> SingleLetterTag  {
    return try!  FfiConverterTypeSingleLetterTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_singlelettertag_uppercase(
        FfiConverterTypeAlphabet_lower(character),$0
    )
})
}
    

    
open func isLowercase() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_singlelettertag_is_lowercase(self.uniffiClonePointer(),$0
    )
})
}
    
open func isUppercase() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_singlelettertag_is_uppercase(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: SingleLetterTag, other: SingleLetterTag) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeSingleLetterTag_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_singlelettertag_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension SingleLetterTag: CustomDebugStringConvertible {}
extension SingleLetterTag: Equatable {}
extension SingleLetterTag: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSingleLetterTag: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SingleLetterTag

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SingleLetterTag {
        return SingleLetterTag(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SingleLetterTag) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SingleLetterTag {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SingleLetterTag, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSingleLetterTag_lift(_ pointer: UnsafeMutableRawPointer) throws -> SingleLetterTag {
    return try FfiConverterTypeSingleLetterTag.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSingleLetterTag_lower(_ value: SingleLetterTag) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSingleLetterTag.lower(value)
}






public protocol StallDataProtocol: AnyObject, Sendable {
    
    func asJson() throws  -> String
    
    func asRecord()  -> StallDataRecord
    
    func currency()  -> String
    
    func description()  -> String?
    
    func id()  -> String
    
    func name()  -> String
    
    func shipping()  -> [ShippingMethod]
    
}
open class StallData: StallDataProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_stalldata(self.pointer, $0) }
    }
public convenience init(id: String, name: String, description: String?, currency: String, shipping: [ShippingMethod]) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_stalldata_new(
        FfiConverterString.lower(id),
        FfiConverterString.lower(name),
        FfiConverterOptionString.lower(description),
        FfiConverterString.lower(currency),
        FfiConverterSequenceTypeShippingMethod.lower(shipping),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_stalldata(pointer, $0) }
    }

    
public static func fromJson(json: String)throws  -> StallData  {
    return try  FfiConverterTypeStallData_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_stalldata_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    
public static func fromRecord(r: StallDataRecord) -> StallData  {
    return try!  FfiConverterTypeStallData_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_stalldata_from_record(
        FfiConverterTypeStallDataRecord_lower(r),$0
    )
})
}
    

    
open func asJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_stalldata_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
open func asRecord() -> StallDataRecord  {
    return try!  FfiConverterTypeStallDataRecord_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_stalldata_as_record(self.uniffiClonePointer(),$0
    )
})
}
    
open func currency() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_stalldata_currency(self.uniffiClonePointer(),$0
    )
})
}
    
open func description() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_stalldata_description(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_stalldata_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func name() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_stalldata_name(self.uniffiClonePointer(),$0
    )
})
}
    
open func shipping() -> [ShippingMethod]  {
    return try!  FfiConverterSequenceTypeShippingMethod.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_stalldata_shipping(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStallData: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = StallData

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> StallData {
        return StallData(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: StallData) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StallData {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: StallData, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStallData_lift(_ pointer: UnsafeMutableRawPointer) throws -> StallData {
    return try FfiConverterTypeStallData.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStallData_lower(_ value: StallData) -> UnsafeMutableRawPointer {
    return FfiConverterTypeStallData.lower(value)
}






/**
 * Auto-closing subscribe options
 */
public protocol SubscribeAutoCloseOptionsProtocol: AnyObject, Sendable {
    
    /**
     * Close subscription when the policy is satisfied
     */
    func exitPolicy(policy: ReqExitPolicy)  -> SubscribeAutoCloseOptions
    
    /**
     * Automatically close subscription if no notifications/events are received within the duration.
     */
    func idleTimeout(timeout: TimeInterval?)  -> SubscribeAutoCloseOptions
    
    /**
     * Automatically close subscription after duration.
     */
    func timeout(timeout: TimeInterval?)  -> SubscribeAutoCloseOptions
    
}
/**
 * Auto-closing subscribe options
 */
open class SubscribeAutoCloseOptions: SubscribeAutoCloseOptionsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_subscribeautocloseoptions(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_subscribeautocloseoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_subscribeautocloseoptions(pointer, $0) }
    }

    

    
    /**
     * Close subscription when the policy is satisfied
     */
open func exitPolicy(policy: ReqExitPolicy) -> SubscribeAutoCloseOptions  {
    return try!  FfiConverterTypeSubscribeAutoCloseOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_exit_policy(self.uniffiClonePointer(),
        FfiConverterTypeReqExitPolicy_lower(policy),$0
    )
})
}
    
    /**
     * Automatically close subscription if no notifications/events are received within the duration.
     */
open func idleTimeout(timeout: TimeInterval?) -> SubscribeAutoCloseOptions  {
    return try!  FfiConverterTypeSubscribeAutoCloseOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_idle_timeout(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    
    /**
     * Automatically close subscription after duration.
     */
open func timeout(timeout: TimeInterval?) -> SubscribeAutoCloseOptions  {
    return try!  FfiConverterTypeSubscribeAutoCloseOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeautocloseoptions_timeout(self.uniffiClonePointer(),
        FfiConverterOptionDuration.lower(timeout),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSubscribeAutoCloseOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SubscribeAutoCloseOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeAutoCloseOptions {
        return SubscribeAutoCloseOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SubscribeAutoCloseOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubscribeAutoCloseOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SubscribeAutoCloseOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubscribeAutoCloseOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeAutoCloseOptions {
    return try FfiConverterTypeSubscribeAutoCloseOptions.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubscribeAutoCloseOptions_lower(_ value: SubscribeAutoCloseOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSubscribeAutoCloseOptions.lower(value)
}






/**
 * Subscribe options
 */
public protocol SubscribeOptionsProtocol: AnyObject, Sendable {
    
    /**
     * Set auto-close conditions
     */
    func closeOn(opts: SubscribeAutoCloseOptions)  -> SubscribeOptions
    
}
/**
 * Subscribe options
 */
open class SubscribeOptions: SubscribeOptionsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_subscribeoptions(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_subscribeoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_subscribeoptions(pointer, $0) }
    }

    

    
    /**
     * Set auto-close conditions
     */
open func closeOn(opts: SubscribeAutoCloseOptions) -> SubscribeOptions  {
    return try!  FfiConverterTypeSubscribeOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_subscribeoptions_close_on(self.uniffiClonePointer(),
        FfiConverterTypeSubscribeAutoCloseOptions_lower(opts),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSubscribeOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SubscribeOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeOptions {
        return SubscribeOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SubscribeOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubscribeOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SubscribeOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubscribeOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> SubscribeOptions {
    return try FfiConverterTypeSubscribeOptions.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubscribeOptions_lower(_ value: SubscribeOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSubscribeOptions.lower(value)
}






public protocol SyncOptionsProtocol: AnyObject, Sendable {
    
    /**
     * Sync Sync direction (default: down)
     */
    func direction(direction: SyncDirection)  -> SyncOptions
    
    /**
     * Dry run
     *
     * Just check what event are missing: execute reconciliation but WITHOUT
     * getting/sending full events.
     */
    func dryRun()  -> SyncOptions
    
    /**
     * Timeout to check if negentropy it's supported (default: 10 secs)
     */
    func initialTimeout(timeout: TimeInterval)  -> SyncOptions
    
}
open class SyncOptions: SyncOptionsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_syncoptions(self.pointer, $0) }
    }
    /**
     * New default options
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_syncoptions_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_syncoptions(pointer, $0) }
    }

    

    
    /**
     * Sync Sync direction (default: down)
     */
open func direction(direction: SyncDirection) -> SyncOptions  {
    return try!  FfiConverterTypeSyncOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_syncoptions_direction(self.uniffiClonePointer(),
        FfiConverterTypeSyncDirection_lower(direction),$0
    )
})
}
    
    /**
     * Dry run
     *
     * Just check what event are missing: execute reconciliation but WITHOUT
     * getting/sending full events.
     */
open func dryRun() -> SyncOptions  {
    return try!  FfiConverterTypeSyncOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_syncoptions_dry_run(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Timeout to check if negentropy it's supported (default: 10 secs)
     */
open func initialTimeout(timeout: TimeInterval) -> SyncOptions  {
    return try!  FfiConverterTypeSyncOptions_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_syncoptions_initial_timeout(self.uniffiClonePointer(),
        FfiConverterDuration.lower(timeout),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SyncOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncOptions {
        return SyncOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SyncOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SyncOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncOptions {
    return try FfiConverterTypeSyncOptions.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncOptions_lower(_ value: SyncOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSyncOptions.lower(value)
}






/**
 * Tag
 */
public protocol TagProtocol: AnyObject, Sendable {
    
    /**
     * Get standardized tag
     */
    func asStandardized()  -> TagStandard?
    
    /**
     * Get array of strings
     */
    func asVec()  -> [String]
    
    /**
     * Return the **first** tag value (index `1`), if exists.
     */
    func content()  -> String?
    
    /**
     * Check if it's a protected event tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/70.md>
     */
    func isProtected()  -> Bool
    
    /**
     * Check if is a standard event tag with `reply` marker
     */
    func isReply()  -> Bool
    
    /**
     * Check if is a standard event tag with `root` marker
     */
    func isRoot()  -> Bool
    
    /**
     * Get tag kind
     */
    func kind()  -> TagKind
    
    /**
     * Get tag kind as string
     */
    func kindStr()  -> String
    
    /**
     * Get tag len
     */
    func len()  -> UInt64
    
    /**
     * Get `SingleLetterTag`
     */
    func singleLetterTag()  -> SingleLetterTag?
    
}
/**
 * Tag
 */
open class Tag: TagProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_tag(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_tag(pointer, $0) }
    }

    
    /**
     * A short human-readable plaintext summary of what that event is about
     *
     * JSON: `["alt", "<summary>"]`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/31.md>
     */
public static func alt(summary: String) -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_alt(
        FfiConverterString.lower(summary),$0
    )
})
}
    
    /**
     * Construct `["client", "<name>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/89.md>
     */
public static func client(name: String) -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_client(
        FfiConverterString.lower(name),$0
    )
})
}
    
    /**
     * Compose `["a", "<coordinate>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
public static func coordinate(coordinate: Coordinate, relayUrl: RelayUrl? = nil) -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_coordinate(
        FfiConverterTypeCoordinate_lower(coordinate),
        FfiConverterOptionTypeRelayUrl.lower(relayUrl),$0
    )
})
}
    
    /**
     * Compose custom tag
     *
     * JSON: `["<kind>", "<value-1>", "<value-2>", ...]`
     */
public static func custom(kind: TagKind, values: [String]) -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_custom(
        FfiConverterTypeTagKind_lower(kind),
        FfiConverterSequenceString.lower(values),$0
    )
})
}
    
    /**
     * Compose `["description", "<description>"]` tag
     */
public static func description(description: String) -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_description(
        FfiConverterString.lower(description),$0
    )
})
}
    
    /**
     * Compose `["e", "<event-id">]`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
public static func event(eventId: EventId) -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_event(
        FfiConverterTypeEventId_lower(eventId),$0
    )
})
}
    
    /**
     * Compose `["e", "<event-id>", "<report>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/56.md>
     */
public static func eventReport(eventId: EventId, report: Report) -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_event_report(
        FfiConverterTypeEventId_lower(eventId),
        FfiConverterTypeReport_lower(report),$0
    )
})
}
    
    /**
     * Compose `["expiration", "<timestamp>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/40.md>
     */
public static func expiration(timestamp: Timestamp) -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_expiration(
        FfiConverterTypeTimestamp_lower(timestamp),$0
    )
})
}
    
    /**
     * Construct from standardized tag
     */
public static func fromStandardized(standardized: TagStandard)throws  -> Tag  {
    return try  FfiConverterTypeTag_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_from_standardized(
        FfiConverterTypeTagStandard_lower(standardized),$0
    )
})
}
    
    /**
     * Compose `["t", "<hashtag>"]` tag
     *
     * This will convert the hashtag to lowercase.
     */
public static func hashtag(hashtag: String) -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_hashtag(
        FfiConverterString.lower(hashtag),$0
    )
})
}
    
    /**
     * Compose `["d", "<identifier>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
public static func identifier(identifier: String) -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_identifier(
        FfiConverterString.lower(identifier),$0
    )
})
}
    
    /**
     * Compose image tag
     */
public static func image(url: String, dimensions: ImageDimensions? = nil)throws  -> Tag  {
    return try  FfiConverterTypeTag_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_image(
        FfiConverterString.lower(url),
        FfiConverterOptionTypeImageDimensions.lower(dimensions),$0
    )
})
}
    
    /**
     * Parse tag
     *
     * Return error if the tag is empty!
     */
public static func parse(data: [String])throws  -> Tag  {
    return try  FfiConverterTypeTag_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_parse(
        FfiConverterSequenceString.lower(data),$0
    )
})
}
    
    /**
     * Compose `["nonce", "<nonce>", "<difficulty>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/13.md>
     */
public static func pow(nonce: UInt64, difficulty: UInt8) -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_pow(
        FfiConverterUInt64.lower(nonce),
        FfiConverterUInt8.lower(difficulty),$0
    )
})
}
    
    /**
     * Protected event
     *
     * JSON: `["-"]`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/70.md>
     */
public static func protected() -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_protected($0
    )
})
}
    
    /**
     * Compose `["p", "<public-key>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
public static func publicKey(publicKey: PublicKey) -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_public_key(
        FfiConverterTypePublicKey_lower(publicKey),$0
    )
})
}
    
    /**
     * Compose `["p", "<public-key>", "<report>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/56.md>
     */
public static func publicKeyReport(publicKey: PublicKey, report: Report) -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_public_key_report(
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterTypeReport_lower(report),$0
    )
})
}
    
    /**
     * Compose `["r", "<value>"]` tag
     */
public static func reference(reference: String) -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_reference(
        FfiConverterString.lower(reference),$0
    )
})
}
    
    /**
     * Compose `["r", "<relay-url>", "<metadata>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/65.md>
     */
public static func relayMetadata(relayUrl: RelayUrl, metadata: RelayMetadata?)throws  -> Tag  {
    return try  FfiConverterTypeTag_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_relay_metadata(
        FfiConverterTypeRelayUrl_lower(relayUrl),
        FfiConverterOptionTypeRelayMetadata.lower(metadata),$0
    )
})
}
    
    /**
     * Compose `["title", "<title>"]` tag
     */
public static func title(title: String) -> Tag  {
    return try!  FfiConverterTypeTag_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tag_title(
        FfiConverterString.lower(title),$0
    )
})
}
    

    
    /**
     * Get standardized tag
     */
open func asStandardized() -> TagStandard?  {
    return try!  FfiConverterOptionTypeTagStandard.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tag_as_standardized(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get array of strings
     */
open func asVec() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tag_as_vec(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the **first** tag value (index `1`), if exists.
     */
open func content() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tag_content(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if it's a protected event tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/70.md>
     */
open func isProtected() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tag_is_protected(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if is a standard event tag with `reply` marker
     */
open func isReply() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tag_is_reply(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if is a standard event tag with `root` marker
     */
open func isRoot() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tag_is_root(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get tag kind
     */
open func kind() -> TagKind  {
    return try!  FfiConverterTypeTagKind_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tag_kind(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get tag kind as string
     */
open func kindStr() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tag_kind_str(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get tag len
     */
open func len() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tag_len(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get `SingleLetterTag`
     */
open func singleLetterTag() -> SingleLetterTag?  {
    return try!  FfiConverterOptionTypeSingleLetterTag.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tag_single_letter_tag(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Tag, other: Tag) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeTag_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tag_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Tag: CustomDebugStringConvertible {}
extension Tag: Equatable {}
extension Tag: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTag: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Tag

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Tag {
        return Tag(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Tag) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tag {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Tag, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTag_lift(_ pointer: UnsafeMutableRawPointer) throws -> Tag {
    return try FfiConverterTypeTag.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTag_lower(_ value: Tag) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTag.lower(value)
}






public protocol TagsProtocol: AnyObject, Sendable {
    
    /**
     * Extract coordinates from `a` tags.
     *
     * This method extract ONLY supported standard variants
     */
    func coordinates()  -> [Coordinate]
    
    /**
     * Extract event IDs from `e` tags.
     *
     * This method extract ONLY supported standard variants
     */
    func eventIds()  -> [EventId]
    
    /**
     * Get timestamp expiration, if set
     */
    func expiration()  -> Timestamp?
    
    /**
     * Get first tag that match `TagKind`.
     */
    func filter(kind: TagKind)  -> [Tag]
    
    /**
     * Get first tag that match `TagKind` and that is standardized.
     */
    func filterStandardized(kind: TagKind)  -> [TagStandard]
    
    /**
     * /// Get first tag that match `TagKind`.
     */
    func find(kind: TagKind)  -> Tag?
    
    /**
     * Get first tag that match `TagKind` and that is standardized.
     */
    func findStandardized(kind: TagKind)  -> TagStandard?
    
    /**
     * Get first tag
     */
    func first()  -> Tag?
    
    /**
     * Get tag at index
     */
    func get(index: UInt64)  -> Tag?
    
    /**
     * Extract hashtags from `t` tags.
     *
     * This method extract ONLY supported standard variants
     */
    func hashtags()  -> [String]
    
    /**
     * Extract identifier (`d` tag), if exists.
     */
    func identifier()  -> String?
    
    /**
     * Check if contains no tags.
     */
    func isEmpty()  -> Bool
    
    /**
     * Get last tag
     */
    func last()  -> Tag?
    
    /**
     * Get number of tags
     */
    func len()  -> UInt64
    
    /**
     * Extract public keys from `p` tags.
     *
     * This method extract ONLY supported standard variants
     */
    func publicKeys()  -> [PublicKey]
    
    func toVec()  -> [Tag]
    
}
open class Tags: TagsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_tags(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_tags(pointer, $0) }
    }

    
public static func fromList(list: [Tag]) -> Tags  {
    return try!  FfiConverterTypeTags_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_tags_from_list(
        FfiConverterSequenceTypeTag.lower(list),$0
    )
})
}
    
public static func parse(tags: [[String]])throws  -> Tags  {
    return try  FfiConverterTypeTags_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_tags_parse(
        FfiConverterSequenceSequenceString.lower(tags),$0
    )
})
}
    

    
    /**
     * Extract coordinates from `a` tags.
     *
     * This method extract ONLY supported standard variants
     */
open func coordinates() -> [Coordinate]  {
    return try!  FfiConverterSequenceTypeCoordinate.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_coordinates(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Extract event IDs from `e` tags.
     *
     * This method extract ONLY supported standard variants
     */
open func eventIds() -> [EventId]  {
    return try!  FfiConverterSequenceTypeEventId.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_event_ids(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get timestamp expiration, if set
     */
open func expiration() -> Timestamp?  {
    return try!  FfiConverterOptionTypeTimestamp.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_expiration(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get first tag that match `TagKind`.
     */
open func filter(kind: TagKind) -> [Tag]  {
    return try!  FfiConverterSequenceTypeTag.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_filter(self.uniffiClonePointer(),
        FfiConverterTypeTagKind_lower(kind),$0
    )
})
}
    
    /**
     * Get first tag that match `TagKind` and that is standardized.
     */
open func filterStandardized(kind: TagKind) -> [TagStandard]  {
    return try!  FfiConverterSequenceTypeTagStandard.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_filter_standardized(self.uniffiClonePointer(),
        FfiConverterTypeTagKind_lower(kind),$0
    )
})
}
    
    /**
     * /// Get first tag that match `TagKind`.
     */
open func find(kind: TagKind) -> Tag?  {
    return try!  FfiConverterOptionTypeTag.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_find(self.uniffiClonePointer(),
        FfiConverterTypeTagKind_lower(kind),$0
    )
})
}
    
    /**
     * Get first tag that match `TagKind` and that is standardized.
     */
open func findStandardized(kind: TagKind) -> TagStandard?  {
    return try!  FfiConverterOptionTypeTagStandard.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_find_standardized(self.uniffiClonePointer(),
        FfiConverterTypeTagKind_lower(kind),$0
    )
})
}
    
    /**
     * Get first tag
     */
open func first() -> Tag?  {
    return try!  FfiConverterOptionTypeTag.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_first(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get tag at index
     */
open func get(index: UInt64) -> Tag?  {
    return try!  FfiConverterOptionTypeTag.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_get(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(index),$0
    )
})
}
    
    /**
     * Extract hashtags from `t` tags.
     *
     * This method extract ONLY supported standard variants
     */
open func hashtags() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_hashtags(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Extract identifier (`d` tag), if exists.
     */
open func identifier() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_identifier(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if contains no tags.
     */
open func isEmpty() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_is_empty(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get last tag
     */
open func last() -> Tag?  {
    return try!  FfiConverterOptionTypeTag.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_last(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get number of tags
     */
open func len() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_len(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Extract public keys from `p` tags.
     *
     * This method extract ONLY supported standard variants
     */
open func publicKeys() -> [PublicKey]  {
    return try!  FfiConverterSequenceTypePublicKey.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_public_keys(self.uniffiClonePointer(),$0
    )
})
}
    
open func toVec() -> [Tag]  {
    return try!  FfiConverterSequenceTypeTag.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_to_vec(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Tags, other: Tags) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeTags_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_tags_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Tags: CustomDebugStringConvertible {}
extension Tags: Equatable {}
extension Tags: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTags: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Tags

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Tags {
        return Tags(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Tags) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tags {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Tags, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTags_lift(_ pointer: UnsafeMutableRawPointer) throws -> Tags {
    return try FfiConverterTypeTags.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTags_lower(_ value: Tags) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTags.lower(value)
}






public protocol TimestampProtocol: AnyObject, Sendable {
    
    /**
     * Add duration to timestamp
     *
     * This sums the duration to the current timestamp and returns a new timestamp.
     */
    func addDuration(duration: TimeInterval)  -> Timestamp
    
    /**
     * Get timestamp as [`u64`]
     */
    func asSecs()  -> UInt64
    
    /**
     * Subtract duration from timestamp
     *
     * This subtracts the duration from the current timestamp and returns a new timestamp.
     */
    func subDuration(duration: TimeInterval)  -> Timestamp
    
    /**
     * Convert [`Timestamp`] to human datetime
     */
    func toHumanDatetime()  -> String
    
}
open class Timestamp: TimestampProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_timestamp(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_timestamp(pointer, $0) }
    }

    
public static func fromSecs(secs: UInt64) -> Timestamp  {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_timestamp_from_secs(
        FfiConverterUInt64.lower(secs),$0
    )
})
}
    
    /**
     * The maximum representable timestamp
     */
public static func max() -> Timestamp  {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_timestamp_max($0
    )
})
}
    
    /**
     * The minimum representable timestamp
     */
public static func min() -> Timestamp  {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_timestamp_min($0
    )
})
}
    
    /**
     * Get UNIX timestamp
     */
public static func now() -> Timestamp  {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_timestamp_now($0
    )
})
}
    

    
    /**
     * Add duration to timestamp
     *
     * This sums the duration to the current timestamp and returns a new timestamp.
     */
open func addDuration(duration: TimeInterval) -> Timestamp  {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_timestamp_add_duration(self.uniffiClonePointer(),
        FfiConverterDuration.lower(duration),$0
    )
})
}
    
    /**
     * Get timestamp as [`u64`]
     */
open func asSecs() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_timestamp_as_secs(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Subtract duration from timestamp
     *
     * This subtracts the duration from the current timestamp and returns a new timestamp.
     */
open func subDuration(duration: TimeInterval) -> Timestamp  {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_timestamp_sub_duration(self.uniffiClonePointer(),
        FfiConverterDuration.lower(duration),$0
    )
})
}
    
    /**
     * Convert [`Timestamp`] to human datetime
     */
open func toHumanDatetime() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_timestamp_to_human_datetime(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Timestamp, other: Timestamp) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeTimestamp_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_timestamp_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension Timestamp: CustomDebugStringConvertible {}
extension Timestamp: Equatable {}
extension Timestamp: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimestamp: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Timestamp

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Timestamp {
        return Timestamp(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Timestamp) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Timestamp {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Timestamp, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimestamp_lift(_ pointer: UnsafeMutableRawPointer) throws -> Timestamp {
    return try FfiConverterTypeTimestamp.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimestamp_lower(_ value: Timestamp) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimestamp.lower(value)
}






public protocol UnsignedEventProtocol: AnyObject, Sendable {
    
    /**
     * Add signature to unsigned event
     *
     * Internally verify the event.
     */
    func addSignature(sig: String) throws  -> Event
    
    func asJson() throws  -> String
    
    func asPrettyJson() throws  -> String
    
    func author()  -> PublicKey
    
    func content()  -> String
    
    func createdAt()  -> Timestamp
    
    func id()  -> EventId?
    
    func kind()  -> Kind
    
    /**
     * Sign an unsigned event
     */
    func sign(signer: NostrSigner) async throws  -> Event
    
    /**
     * Sign an unsigned event with keys signer
     *
     * Internally: calculate event ID (if not set), sign it, compose and verify event.
     */
    func signWithKeys(keys: Keys) throws  -> Event
    
    func tags()  -> Tags
    
}
open class UnsignedEvent: UnsignedEventProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_unsignedevent(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_unsignedevent(pointer, $0) }
    }

    
public static func fromJson(json: String)throws  -> UnsignedEvent  {
    return try  FfiConverterTypeUnsignedEvent_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_constructor_unsignedevent_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    

    
    /**
     * Add signature to unsigned event
     *
     * Internally verify the event.
     */
open func addSignature(sig: String)throws  -> Event  {
    return try  FfiConverterTypeEvent_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_unsignedevent_add_signature(self.uniffiClonePointer(),
        FfiConverterString.lower(sig),$0
    )
})
}
    
open func asJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_unsignedevent_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
open func asPrettyJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_unsignedevent_as_pretty_json(self.uniffiClonePointer(),$0
    )
})
}
    
open func author() -> PublicKey  {
    return try!  FfiConverterTypePublicKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_unsignedevent_author(self.uniffiClonePointer(),$0
    )
})
}
    
open func content() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_unsignedevent_content(self.uniffiClonePointer(),$0
    )
})
}
    
open func createdAt() -> Timestamp  {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_unsignedevent_created_at(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> EventId?  {
    return try!  FfiConverterOptionTypeEventId.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_unsignedevent_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func kind() -> Kind  {
    return try!  FfiConverterTypeKind_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_unsignedevent_kind(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Sign an unsigned event
     */
open func sign(signer: NostrSigner)async throws  -> Event  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_unsignedevent_sign(
                    self.uniffiClonePointer(),
                    FfiConverterTypeNostrSigner_lower(signer)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvent_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Sign an unsigned event with keys signer
     *
     * Internally: calculate event ID (if not set), sign it, compose and verify event.
     */
open func signWithKeys(keys: Keys)throws  -> Event  {
    return try  FfiConverterTypeEvent_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_method_unsignedevent_sign_with_keys(self.uniffiClonePointer(),
        FfiConverterTypeKeys_lower(keys),$0
    )
})
}
    
open func tags() -> Tags  {
    return try!  FfiConverterTypeTags_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_unsignedevent_tags(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: UnsignedEvent, other: UnsignedEvent) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeUnsignedEvent_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_unsignedevent_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension UnsignedEvent: CustomDebugStringConvertible {}
extension UnsignedEvent: Equatable {}
extension UnsignedEvent: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsignedEvent: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnsignedEvent

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsignedEvent {
        return UnsignedEvent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnsignedEvent) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsignedEvent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnsignedEvent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedEvent_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsignedEvent {
    return try FfiConverterTypeUnsignedEvent.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedEvent_lower(_ value: UnsignedEvent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnsignedEvent.lower(value)
}






/**
 * Unwrapped Gift Wrap
 *
 * <https://github.com/nostr-protocol/nips/blob/master/59.md>
 */
public protocol UnwrappedGiftProtocol: AnyObject, Sendable {
    
    func none() async 
    
    /**
     * Get rumor
     */
    func rumor()  -> UnsignedEvent
    
    /**
     * Get sender public key
     */
    func sender()  -> PublicKey
    
}
/**
 * Unwrapped Gift Wrap
 *
 * <https://github.com/nostr-protocol/nips/blob/master/59.md>
 */
open class UnwrappedGift: UnwrappedGiftProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_unwrappedgift(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_unwrappedgift(pointer, $0) }
    }

    
    /**
     * Unwrap Gift Wrap event
     *
     * Internally verify the `seal` event
     */
public static func fromGiftWrap(signer: NostrSigner, giftWrap: Event)async throws  -> UnwrappedGift  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_constructor_unwrappedgift_from_gift_wrap(FfiConverterTypeNostrSigner_lower(signer),FfiConverterTypeEvent_lower(giftWrap)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeUnwrappedGift_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    

    
open func none()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_unwrappedgift__none(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Get rumor
     */
open func rumor() -> UnsignedEvent  {
    return try!  FfiConverterTypeUnsignedEvent_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_rumor(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get sender public key
     */
open func sender() -> PublicKey  {
    return try!  FfiConverterTypePublicKey_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_sender(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: UnwrappedGift, other: UnwrappedGift) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeUnwrappedGift_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_unwrappedgift_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension UnwrappedGift: CustomDebugStringConvertible {}
extension UnwrappedGift: Equatable {}
extension UnwrappedGift: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnwrappedGift: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnwrappedGift

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnwrappedGift {
        return UnwrappedGift(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnwrappedGift) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnwrappedGift {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnwrappedGift, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnwrappedGift_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnwrappedGift {
    return try FfiConverterTypeUnwrappedGift.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnwrappedGift_lower(_ value: UnwrappedGift) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnwrappedGift.lower(value)
}






public protocol WebSocketAdapter: AnyObject, Sendable {
    
    /**
     * Send a WebSocket message
     */
    func send(msg: WebSocketMessage) async throws 
    
    /**
     * Receive a message
     *
     * This method MUST await for a message.
     *
     * Return `None` to mark the stream as terminated.
     */
    func recv() async throws  -> WebSocketMessage?
    
    /**
     * Close the WebSocket connection
     */
    func closeConnection() async throws 
    
}
open class WebSocketAdapterImpl: WebSocketAdapter, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_websocketadapter(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_websocketadapter(pointer, $0) }
    }

    

    
    /**
     * Send a WebSocket message
     */
open func send(msg: WebSocketMessage)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_websocketadapter_send(
                    self.uniffiClonePointer(),
                    FfiConverterTypeWebSocketMessage_lower(msg)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Receive a message
     *
     * This method MUST await for a message.
     *
     * Return `None` to mark the stream as terminated.
     */
open func recv()async throws  -> WebSocketMessage?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_websocketadapter_recv(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeWebSocketMessage.lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    
    /**
     * Close the WebSocket connection
     */
open func closeConnection()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_websocketadapter_close_connection(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceWebSocketAdapter {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceWebSocketAdapter] = [UniffiVTableCallbackInterfaceWebSocketAdapter(
        send: { (
            uniffiHandle: UInt64,
            msg: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeWebSocketAdapter.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.send(
                     msg: try FfiConverterTypeWebSocketMessage_lift(msg)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        recv: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> WebSocketMessage? in
                guard let uniffiObj = try? FfiConverterTypeWebSocketAdapter.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.recv(
                )
            }

            let uniffiHandleSuccess = { (returnValue: WebSocketMessage?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeWebSocketMessage.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        closeConnection: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeWebSocketAdapter.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.closeConnection(
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeNostrSdkError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeWebSocketAdapter.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface WebSocketAdapter: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitWebSocketAdapter() {
    uniffi_nostr_sdk_ffi_fn_init_callback_vtable_websocketadapter(UniffiCallbackInterfaceWebSocketAdapter.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWebSocketAdapter: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<WebSocketAdapter>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WebSocketAdapter

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WebSocketAdapter {
        return WebSocketAdapterImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WebSocketAdapter) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WebSocketAdapter {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WebSocketAdapter, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWebSocketAdapter_lift(_ pointer: UnsafeMutableRawPointer) throws -> WebSocketAdapter {
    return try FfiConverterTypeWebSocketAdapter.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWebSocketAdapter_lower(_ value: WebSocketAdapter) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWebSocketAdapter.lower(value)
}






public protocol WebSocketAdapterWrapperProtocol: AnyObject, Sendable {
    
}
open class WebSocketAdapterWrapper: WebSocketAdapterWrapperProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_websocketadapterwrapper(self.pointer, $0) }
    }
public convenience init(adapter: WebSocketAdapter) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_websocketadapterwrapper_new(
        FfiConverterTypeWebSocketAdapter_lower(adapter),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_websocketadapterwrapper(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWebSocketAdapterWrapper: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WebSocketAdapterWrapper

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WebSocketAdapterWrapper {
        return WebSocketAdapterWrapper(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WebSocketAdapterWrapper) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WebSocketAdapterWrapper {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WebSocketAdapterWrapper, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWebSocketAdapterWrapper_lift(_ pointer: UnsafeMutableRawPointer) throws -> WebSocketAdapterWrapper {
    return try FfiConverterTypeWebSocketAdapterWrapper.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWebSocketAdapterWrapper_lower(_ value: WebSocketAdapterWrapper) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWebSocketAdapterWrapper.lower(value)
}






/**
 * Custom policy for accepting events into the relay database
 */
public protocol WritePolicy: AnyObject, Sendable {
    
    /**
     * Check if the policy should accept an event
     */
    func admitEvent(event: Event, socketAddr: String) async  -> PolicyResult
    
}
/**
 * Custom policy for accepting events into the relay database
 */
open class WritePolicyImpl: WritePolicy, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_writepolicy(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_writepolicy(pointer, $0) }
    }

    

    
    /**
     * Check if the policy should accept an event
     */
open func admitEvent(event: Event, socketAddr: String)async  -> PolicyResult  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_method_writepolicy_admit_event(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEvent_lower(event),FfiConverterString.lower(socketAddr)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePolicyResult_lift,
            errorHandler: nil
            
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceWritePolicy {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceWritePolicy] = [UniffiVTableCallbackInterfaceWritePolicy(
        admitEvent: { (
            uniffiHandle: UInt64,
            event: UnsafeMutableRawPointer,
            socketAddr: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> PolicyResult in
                guard let uniffiObj = try? FfiConverterTypeWritePolicy.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.admitEvent(
                     event: try FfiConverterTypeEvent_lift(event),
                     socketAddr: try FfiConverterString.lift(socketAddr)
                )
            }

            let uniffiHandleSuccess = { (returnValue: PolicyResult) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypePolicyResult_lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeWritePolicy.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface WritePolicy: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitWritePolicy() {
    uniffi_nostr_sdk_ffi_fn_init_callback_vtable_writepolicy(UniffiCallbackInterfaceWritePolicy.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWritePolicy: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<WritePolicy>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WritePolicy

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WritePolicy {
        return WritePolicyImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WritePolicy) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WritePolicy {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WritePolicy, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWritePolicy_lift(_ pointer: UnsafeMutableRawPointer) throws -> WritePolicy {
    return try FfiConverterTypeWritePolicy.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWritePolicy_lower(_ value: WritePolicy) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWritePolicy.lower(value)
}






public protocol ZapRequestDataProtocol: AnyObject, Sendable {
    
    func amount(amount: UInt64)  -> ZapRequestData
    
    func eventId(eventId: EventId)  -> ZapRequestData
    
    func lnurl(lnurl: String)  -> ZapRequestData
    
    func message(message: String)  -> ZapRequestData
    
}
open class ZapRequestData: ZapRequestDataProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_sdk_ffi_fn_clone_zaprequestdata(self.pointer, $0) }
    }
public convenience init(publicKey: PublicKey, relays: [RelayUrl]) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_constructor_zaprequestdata_new(
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterSequenceTypeRelayUrl.lower(relays),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_sdk_ffi_fn_free_zaprequestdata(pointer, $0) }
    }

    

    
open func amount(amount: UInt64) -> ZapRequestData  {
    return try!  FfiConverterTypeZapRequestData_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_amount(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amount),$0
    )
})
}
    
open func eventId(eventId: EventId) -> ZapRequestData  {
    return try!  FfiConverterTypeZapRequestData_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_event_id(self.uniffiClonePointer(),
        FfiConverterTypeEventId_lower(eventId),$0
    )
})
}
    
open func lnurl(lnurl: String) -> ZapRequestData  {
    return try!  FfiConverterTypeZapRequestData_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_lnurl(self.uniffiClonePointer(),
        FfiConverterString.lower(lnurl),$0
    )
})
}
    
open func message(message: String) -> ZapRequestData  {
    return try!  FfiConverterTypeZapRequestData_lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_message(self.uniffiClonePointer(),
        FfiConverterString.lower(message),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: ZapRequestData, other: ZapRequestData) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeZapRequestData_lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_method_zaprequestdata_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}
extension ZapRequestData: CustomDebugStringConvertible {}
extension ZapRequestData: Equatable {}
extension ZapRequestData: Hashable {}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeZapRequestData: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZapRequestData

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapRequestData {
        return ZapRequestData(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZapRequestData) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZapRequestData {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZapRequestData, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeZapRequestData_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapRequestData {
    return try FfiConverterTypeZapRequestData.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeZapRequestData_lower(_ value: ZapRequestData) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZapRequestData.lower(value)
}




/**
 * Groups of articles picked by users as interesting and/or belonging to the same category
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
public struct ArticlesCuration {
    /**
     * Coordinates
     */
    public var coordinate: [Coordinate]
    /**
     * Event IDs
     */
    public var eventIds: [EventId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Coordinates
         */coordinate: [Coordinate] = [], 
        /**
         * Event IDs
         */eventIds: [EventId] = []) {
        self.coordinate = coordinate
        self.eventIds = eventIds
    }
}

#if compiler(>=6)
extension ArticlesCuration: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeArticlesCuration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArticlesCuration {
        return
            try ArticlesCuration(
                coordinate: FfiConverterSequenceTypeCoordinate.read(from: &buf), 
                eventIds: FfiConverterSequenceTypeEventId.read(from: &buf)
        )
    }

    public static func write(_ value: ArticlesCuration, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeCoordinate.write(value.coordinate, into: &buf)
        FfiConverterSequenceTypeEventId.write(value.eventIds, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArticlesCuration_lift(_ buf: RustBuffer) throws -> ArticlesCuration {
    return try FfiConverterTypeArticlesCuration.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArticlesCuration_lower(_ value: ArticlesCuration) -> RustBuffer {
    return FfiConverterTypeArticlesCuration.lower(value)
}


/**
 * Uncategorized, "global" list of things a user wants to save
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
public struct Bookmarks {
    public var eventIds: [EventId]
    public var coordinate: [Coordinate]
    public var hashtags: [String]
    public var urls: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(eventIds: [EventId] = [], coordinate: [Coordinate] = [], hashtags: [String] = [], urls: [String] = []) {
        self.eventIds = eventIds
        self.coordinate = coordinate
        self.hashtags = hashtags
        self.urls = urls
    }
}

#if compiler(>=6)
extension Bookmarks: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBookmarks: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bookmarks {
        return
            try Bookmarks(
                eventIds: FfiConverterSequenceTypeEventId.read(from: &buf), 
                coordinate: FfiConverterSequenceTypeCoordinate.read(from: &buf), 
                hashtags: FfiConverterSequenceString.read(from: &buf), 
                urls: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: Bookmarks, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeEventId.write(value.eventIds, into: &buf)
        FfiConverterSequenceTypeCoordinate.write(value.coordinate, into: &buf)
        FfiConverterSequenceString.write(value.hashtags, into: &buf)
        FfiConverterSequenceString.write(value.urls, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBookmarks_lift(_ buf: RustBuffer) throws -> Bookmarks {
    return try FfiConverterTypeBookmarks.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBookmarks_lower(_ value: Bookmarks) -> RustBuffer {
    return FfiConverterTypeBookmarks.lower(value)
}


/**
 * Cancel Hold Invoice Request
 */
public struct CancelHoldInvoiceRequest {
    /**
     * payment_hash
     */
    public var paymentHash: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * payment_hash
         */paymentHash: String) {
        self.paymentHash = paymentHash
    }
}

#if compiler(>=6)
extension CancelHoldInvoiceRequest: Sendable {}
#endif


extension CancelHoldInvoiceRequest: Equatable, Hashable {
    public static func ==(lhs: CancelHoldInvoiceRequest, rhs: CancelHoldInvoiceRequest) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCancelHoldInvoiceRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CancelHoldInvoiceRequest {
        return
            try CancelHoldInvoiceRequest(
                paymentHash: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CancelHoldInvoiceRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentHash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCancelHoldInvoiceRequest_lift(_ buf: RustBuffer) throws -> CancelHoldInvoiceRequest {
    return try FfiConverterTypeCancelHoldInvoiceRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCancelHoldInvoiceRequest_lower(_ value: CancelHoldInvoiceRequest) -> RustBuffer {
    return FfiConverterTypeCancelHoldInvoiceRequest.lower(value)
}


/**
 * Cancel Hold Invoice Response
 */
public struct CancelHoldInvoiceResponse {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}

#if compiler(>=6)
extension CancelHoldInvoiceResponse: Sendable {}
#endif


extension CancelHoldInvoiceResponse: Equatable, Hashable {
    public static func ==(lhs: CancelHoldInvoiceResponse, rhs: CancelHoldInvoiceResponse) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCancelHoldInvoiceResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CancelHoldInvoiceResponse {
        return
            CancelHoldInvoiceResponse()
    }

    public static func write(_ value: CancelHoldInvoiceResponse, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCancelHoldInvoiceResponse_lift(_ buf: RustBuffer) throws -> CancelHoldInvoiceResponse {
    return try FfiConverterTypeCancelHoldInvoiceResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCancelHoldInvoiceResponse_lower(_ value: CancelHoldInvoiceResponse) -> RustBuffer {
    return FfiConverterTypeCancelHoldInvoiceResponse.lower(value)
}


public struct Contact {
    public var publicKey: PublicKey
    public var relayUrl: RelayUrl?
    public var alias: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: PublicKey, relayUrl: RelayUrl? = nil, alias: String? = nil) {
        self.publicKey = publicKey
        self.relayUrl = relayUrl
        self.alias = alias
    }
}

#if compiler(>=6)
extension Contact: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContact: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Contact {
        return
            try Contact(
                publicKey: FfiConverterTypePublicKey.read(from: &buf), 
                relayUrl: FfiConverterOptionTypeRelayUrl.read(from: &buf), 
                alias: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Contact, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterOptionTypeRelayUrl.write(value.relayUrl, into: &buf)
        FfiConverterOptionString.write(value.alias, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContact_lift(_ buf: RustBuffer) throws -> Contact {
    return try FfiConverterTypeContact.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContact_lower(_ value: Contact) -> RustBuffer {
    return FfiConverterTypeContact.lower(value)
}


/**
 * Emoji
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
public struct EmojiInfo {
    public var shortcode: String
    public var url: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(shortcode: String, url: String) {
        self.shortcode = shortcode
        self.url = url
    }
}

#if compiler(>=6)
extension EmojiInfo: Sendable {}
#endif


extension EmojiInfo: Equatable, Hashable {
    public static func ==(lhs: EmojiInfo, rhs: EmojiInfo) -> Bool {
        if lhs.shortcode != rhs.shortcode {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(shortcode)
        hasher.combine(url)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEmojiInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmojiInfo {
        return
            try EmojiInfo(
                shortcode: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: EmojiInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.shortcode, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmojiInfo_lift(_ buf: RustBuffer) throws -> EmojiInfo {
    return try FfiConverterTypeEmojiInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmojiInfo_lower(_ value: EmojiInfo) -> RustBuffer {
    return FfiConverterTypeEmojiInfo.lower(value)
}


/**
 * User preferred emojis and pointers to emoji sets
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
public struct Emojis {
    /**
     * Emojis
     */
    public var emojis: [EmojiInfo]
    /**
     * Coordinates
     */
    public var coordinate: [Coordinate]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Emojis
         */emojis: [EmojiInfo] = [], 
        /**
         * Coordinates
         */coordinate: [Coordinate] = []) {
        self.emojis = emojis
        self.coordinate = coordinate
    }
}

#if compiler(>=6)
extension Emojis: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEmojis: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Emojis {
        return
            try Emojis(
                emojis: FfiConverterSequenceTypeEmojiInfo.read(from: &buf), 
                coordinate: FfiConverterSequenceTypeCoordinate.read(from: &buf)
        )
    }

    public static func write(_ value: Emojis, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeEmojiInfo.write(value.emojis, into: &buf)
        FfiConverterSequenceTypeCoordinate.write(value.coordinate, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmojis_lift(_ buf: RustBuffer) throws -> Emojis {
    return try FfiConverterTypeEmojis.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmojis_lower(_ value: Emojis) -> RustBuffer {
    return FfiConverterTypeEmojis.lower(value)
}


/**
 * Event deletion request
 */
public struct EventDeletionRequest {
    /**
     * Event IDs
     */
    public var ids: [EventId]
    /**
     * Event coordinates
     */
    public var coordinates: [Coordinate]
    /**
     * Optional reason
     */
    public var reason: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Event IDs
         */ids: [EventId], 
        /**
         * Event coordinates
         */coordinates: [Coordinate], 
        /**
         * Optional reason
         */reason: String? = nil) {
        self.ids = ids
        self.coordinates = coordinates
        self.reason = reason
    }
}

#if compiler(>=6)
extension EventDeletionRequest: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEventDeletionRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventDeletionRequest {
        return
            try EventDeletionRequest(
                ids: FfiConverterSequenceTypeEventId.read(from: &buf), 
                coordinates: FfiConverterSequenceTypeCoordinate.read(from: &buf), 
                reason: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: EventDeletionRequest, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeEventId.write(value.ids, into: &buf)
        FfiConverterSequenceTypeCoordinate.write(value.coordinates, into: &buf)
        FfiConverterOptionString.write(value.reason, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventDeletionRequest_lift(_ buf: RustBuffer) throws -> EventDeletionRequest {
    return try FfiConverterTypeEventDeletionRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventDeletionRequest_lower(_ value: EventDeletionRequest) -> RustBuffer {
    return FfiConverterTypeEventDeletionRequest.lower(value)
}


/**
 * The specific information about a fee schedule
 */
public struct FeeSchedule {
    /**
     * The fee amount
     */
    public var amount: Int32
    /**
     * The denomination of the feed
     */
    public var unit: String
    /**
     * The duration for which the fee is valid
     */
    public var period: Int32?
    /**
     * The event kinds the fee allows the client to publish to the relay
     */
    public var kinds: [String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The fee amount
         */amount: Int32, 
        /**
         * The denomination of the feed
         */unit: String, 
        /**
         * The duration for which the fee is valid
         */period: Int32?, 
        /**
         * The event kinds the fee allows the client to publish to the relay
         */kinds: [String]?) {
        self.amount = amount
        self.unit = unit
        self.period = period
        self.kinds = kinds
    }
}

#if compiler(>=6)
extension FeeSchedule: Sendable {}
#endif


extension FeeSchedule: Equatable, Hashable {
    public static func ==(lhs: FeeSchedule, rhs: FeeSchedule) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.unit != rhs.unit {
            return false
        }
        if lhs.period != rhs.period {
            return false
        }
        if lhs.kinds != rhs.kinds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(unit)
        hasher.combine(period)
        hasher.combine(kinds)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeSchedule: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSchedule {
        return
            try FeeSchedule(
                amount: FfiConverterInt32.read(from: &buf), 
                unit: FfiConverterString.read(from: &buf), 
                period: FfiConverterOptionInt32.read(from: &buf), 
                kinds: FfiConverterOptionSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: FeeSchedule, into buf: inout [UInt8]) {
        FfiConverterInt32.write(value.amount, into: &buf)
        FfiConverterString.write(value.unit, into: &buf)
        FfiConverterOptionInt32.write(value.period, into: &buf)
        FfiConverterOptionSequenceString.write(value.kinds, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeSchedule_lift(_ buf: RustBuffer) throws -> FeeSchedule {
    return try FfiConverterTypeFeeSchedule.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeSchedule_lower(_ value: FeeSchedule) -> RustBuffer {
    return FfiConverterTypeFeeSchedule.lower(value)
}


/**
 * Available fee schedules
 */
public struct FeeSchedules {
    /**
     * Fees for admission to use the relay
     */
    public var admission: [FeeSchedule]
    /**
     * Fees for subscription to use the relay
     */
    public var subscription: [FeeSchedule]
    /**
     * Fees to publish to the relay
     */
    public var publication: [FeeSchedule]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Fees for admission to use the relay
         */admission: [FeeSchedule], 
        /**
         * Fees for subscription to use the relay
         */subscription: [FeeSchedule], 
        /**
         * Fees to publish to the relay
         */publication: [FeeSchedule]) {
        self.admission = admission
        self.subscription = subscription
        self.publication = publication
    }
}

#if compiler(>=6)
extension FeeSchedules: Sendable {}
#endif


extension FeeSchedules: Equatable, Hashable {
    public static func ==(lhs: FeeSchedules, rhs: FeeSchedules) -> Bool {
        if lhs.admission != rhs.admission {
            return false
        }
        if lhs.subscription != rhs.subscription {
            return false
        }
        if lhs.publication != rhs.publication {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(admission)
        hasher.combine(subscription)
        hasher.combine(publication)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeSchedules: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSchedules {
        return
            try FeeSchedules(
                admission: FfiConverterSequenceTypeFeeSchedule.read(from: &buf), 
                subscription: FfiConverterSequenceTypeFeeSchedule.read(from: &buf), 
                publication: FfiConverterSequenceTypeFeeSchedule.read(from: &buf)
        )
    }

    public static func write(_ value: FeeSchedules, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFeeSchedule.write(value.admission, into: &buf)
        FfiConverterSequenceTypeFeeSchedule.write(value.subscription, into: &buf)
        FfiConverterSequenceTypeFeeSchedule.write(value.publication, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeSchedules_lift(_ buf: RustBuffer) throws -> FeeSchedules {
    return try FfiConverterTypeFeeSchedules.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeSchedules_lower(_ value: FeeSchedules) -> RustBuffer {
    return FfiConverterTypeFeeSchedules.lower(value)
}


public struct FilterRecord {
    public var ids: [EventId]?
    public var authors: [PublicKey]?
    public var kinds: [Kind]?
    /**
     * It's a string describing a query in a human-readable form, i.e. "best nostr apps"
     *
     * <https://github.com/nostr-protocol/nips/blob/master/50.md>
     */
    public var search: String?
    /**
     * An integer unix timestamp, events must be newer than this to pass
     */
    public var since: Timestamp?
    /**
     * An integer unix timestamp, events must be older than this to pass
     */
    public var until: Timestamp?
    /**
     * Maximum number of events to be returned in the initial query
     */
    public var limit: UInt64?
    /**
     * Generic tag queries
     */
    public var genericTags: [GenericTag]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ids: [EventId]?, authors: [PublicKey]?, kinds: [Kind]?, 
        /**
         * It's a string describing a query in a human-readable form, i.e. "best nostr apps"
         *
         * <https://github.com/nostr-protocol/nips/blob/master/50.md>
         */search: String?, 
        /**
         * An integer unix timestamp, events must be newer than this to pass
         */since: Timestamp?, 
        /**
         * An integer unix timestamp, events must be older than this to pass
         */until: Timestamp?, 
        /**
         * Maximum number of events to be returned in the initial query
         */limit: UInt64?, 
        /**
         * Generic tag queries
         */genericTags: [GenericTag]) {
        self.ids = ids
        self.authors = authors
        self.kinds = kinds
        self.search = search
        self.since = since
        self.until = until
        self.limit = limit
        self.genericTags = genericTags
    }
}

#if compiler(>=6)
extension FilterRecord: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFilterRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FilterRecord {
        return
            try FilterRecord(
                ids: FfiConverterOptionSequenceTypeEventId.read(from: &buf), 
                authors: FfiConverterOptionSequenceTypePublicKey.read(from: &buf), 
                kinds: FfiConverterOptionSequenceTypeKind.read(from: &buf), 
                search: FfiConverterOptionString.read(from: &buf), 
                since: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                until: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                limit: FfiConverterOptionUInt64.read(from: &buf), 
                genericTags: FfiConverterSequenceTypeGenericTag.read(from: &buf)
        )
    }

    public static func write(_ value: FilterRecord, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypeEventId.write(value.ids, into: &buf)
        FfiConverterOptionSequenceTypePublicKey.write(value.authors, into: &buf)
        FfiConverterOptionSequenceTypeKind.write(value.kinds, into: &buf)
        FfiConverterOptionString.write(value.search, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.since, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.until, into: &buf)
        FfiConverterOptionUInt64.write(value.limit, into: &buf)
        FfiConverterSequenceTypeGenericTag.write(value.genericTags, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFilterRecord_lift(_ buf: RustBuffer) throws -> FilterRecord {
    return try FfiConverterTypeFilterRecord.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFilterRecord_lower(_ value: FilterRecord) -> RustBuffer {
    return FfiConverterTypeFilterRecord.lower(value)
}


public struct GenericTag {
    public var key: SingleLetterTag
    public var value: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: SingleLetterTag, value: [String]) {
        self.key = key
        self.value = value
    }
}

#if compiler(>=6)
extension GenericTag: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGenericTag: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GenericTag {
        return
            try GenericTag(
                key: FfiConverterTypeSingleLetterTag.read(from: &buf), 
                value: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: GenericTag, into buf: inout [UInt8]) {
        FfiConverterTypeSingleLetterTag.write(value.key, into: &buf)
        FfiConverterSequenceString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGenericTag_lift(_ buf: RustBuffer) throws -> GenericTag {
    return try FfiConverterTypeGenericTag.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGenericTag_lower(_ value: GenericTag) -> RustBuffer {
    return FfiConverterTypeGenericTag.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct GetBalanceResponse {
    /**
     * Balance amount in msats
     */
    public var balance: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Balance amount in msats
         */balance: UInt64) {
        self.balance = balance
    }
}

#if compiler(>=6)
extension GetBalanceResponse: Sendable {}
#endif


extension GetBalanceResponse: Equatable, Hashable {
    public static func ==(lhs: GetBalanceResponse, rhs: GetBalanceResponse) -> Bool {
        if lhs.balance != rhs.balance {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(balance)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetBalanceResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetBalanceResponse {
        return
            try GetBalanceResponse(
                balance: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: GetBalanceResponse, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.balance, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetBalanceResponse_lift(_ buf: RustBuffer) throws -> GetBalanceResponse {
    return try FfiConverterTypeGetBalanceResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetBalanceResponse_lower(_ value: GetBalanceResponse) -> RustBuffer {
    return FfiConverterTypeGetBalanceResponse.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct GetInfoResponse {
    /**
     * The alias of the lightning node
     */
    public var alias: String?
    /**
     * The color of the current node in hex code format
     */
    public var color: String?
    /**
     * Lightning Node's public key
     */
    public var pubkey: String?
    /**
     * Active network
     */
    public var network: String?
    /**
     * Current block height
     */
    public var blockHeight: UInt32?
    /**
     * Most Recent Block Hash
     */
    public var blockHash: String?
    /**
     * Available methods for this connection
     */
    public var methods: [Method]
    /**
     * List of supported notifications for this connection (optional)
     */
    public var notifications: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The alias of the lightning node
         */alias: String?, 
        /**
         * The color of the current node in hex code format
         */color: String?, 
        /**
         * Lightning Node's public key
         */pubkey: String?, 
        /**
         * Active network
         */network: String?, 
        /**
         * Current block height
         */blockHeight: UInt32?, 
        /**
         * Most Recent Block Hash
         */blockHash: String?, 
        /**
         * Available methods for this connection
         */methods: [Method], 
        /**
         * List of supported notifications for this connection (optional)
         */notifications: [String]) {
        self.alias = alias
        self.color = color
        self.pubkey = pubkey
        self.network = network
        self.blockHeight = blockHeight
        self.blockHash = blockHash
        self.methods = methods
        self.notifications = notifications
    }
}

#if compiler(>=6)
extension GetInfoResponse: Sendable {}
#endif


extension GetInfoResponse: Equatable, Hashable {
    public static func ==(lhs: GetInfoResponse, rhs: GetInfoResponse) -> Bool {
        if lhs.alias != rhs.alias {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.blockHeight != rhs.blockHeight {
            return false
        }
        if lhs.blockHash != rhs.blockHash {
            return false
        }
        if lhs.methods != rhs.methods {
            return false
        }
        if lhs.notifications != rhs.notifications {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(alias)
        hasher.combine(color)
        hasher.combine(pubkey)
        hasher.combine(network)
        hasher.combine(blockHeight)
        hasher.combine(blockHash)
        hasher.combine(methods)
        hasher.combine(notifications)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetInfoResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetInfoResponse {
        return
            try GetInfoResponse(
                alias: FfiConverterOptionString.read(from: &buf), 
                color: FfiConverterOptionString.read(from: &buf), 
                pubkey: FfiConverterOptionString.read(from: &buf), 
                network: FfiConverterOptionString.read(from: &buf), 
                blockHeight: FfiConverterOptionUInt32.read(from: &buf), 
                blockHash: FfiConverterOptionString.read(from: &buf), 
                methods: FfiConverterSequenceTypeMethod.read(from: &buf), 
                notifications: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: GetInfoResponse, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.alias, into: &buf)
        FfiConverterOptionString.write(value.color, into: &buf)
        FfiConverterOptionString.write(value.pubkey, into: &buf)
        FfiConverterOptionString.write(value.network, into: &buf)
        FfiConverterOptionUInt32.write(value.blockHeight, into: &buf)
        FfiConverterOptionString.write(value.blockHash, into: &buf)
        FfiConverterSequenceTypeMethod.write(value.methods, into: &buf)
        FfiConverterSequenceString.write(value.notifications, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoResponse_lift(_ buf: RustBuffer) throws -> GetInfoResponse {
    return try FfiConverterTypeGetInfoResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoResponse_lower(_ value: GetInfoResponse) -> RustBuffer {
    return FfiConverterTypeGetInfoResponse.lower(value)
}


/**
 * Git Issue
 */
public struct GitIssue {
    /**
     * The repository address
     */
    public var repository: Coordinate
    /**
     * The issue content (markdown)
     */
    public var content: String
    /**
     * Subject
     */
    public var subject: String?
    /**
     * Labels
     */
    public var labels: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The repository address
         */repository: Coordinate, 
        /**
         * The issue content (markdown)
         */content: String, 
        /**
         * Subject
         */subject: String?, 
        /**
         * Labels
         */labels: [String]) {
        self.repository = repository
        self.content = content
        self.subject = subject
        self.labels = labels
    }
}

#if compiler(>=6)
extension GitIssue: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGitIssue: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GitIssue {
        return
            try GitIssue(
                repository: FfiConverterTypeCoordinate.read(from: &buf), 
                content: FfiConverterString.read(from: &buf), 
                subject: FfiConverterOptionString.read(from: &buf), 
                labels: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: GitIssue, into buf: inout [UInt8]) {
        FfiConverterTypeCoordinate.write(value.repository, into: &buf)
        FfiConverterString.write(value.content, into: &buf)
        FfiConverterOptionString.write(value.subject, into: &buf)
        FfiConverterSequenceString.write(value.labels, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGitIssue_lift(_ buf: RustBuffer) throws -> GitIssue {
    return try FfiConverterTypeGitIssue.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGitIssue_lower(_ value: GitIssue) -> RustBuffer {
    return FfiConverterTypeGitIssue.lower(value)
}


/**
 * Git Patch
 */
public struct GitPatch {
    /**
     * Repository
     */
    public var repository: Coordinate
    /**
     * Patch
     */
    public var content: GitPatchContent
    /**
     * Earliest unique commit ID of repo
     */
    public var euc: String
    /**
     * Labels
     */
    public var labels: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Repository
         */repository: Coordinate, 
        /**
         * Patch
         */content: GitPatchContent, 
        /**
         * Earliest unique commit ID of repo
         */euc: String, 
        /**
         * Labels
         */labels: [String]) {
        self.repository = repository
        self.content = content
        self.euc = euc
        self.labels = labels
    }
}

#if compiler(>=6)
extension GitPatch: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGitPatch: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GitPatch {
        return
            try GitPatch(
                repository: FfiConverterTypeCoordinate.read(from: &buf), 
                content: FfiConverterTypeGitPatchContent.read(from: &buf), 
                euc: FfiConverterString.read(from: &buf), 
                labels: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: GitPatch, into buf: inout [UInt8]) {
        FfiConverterTypeCoordinate.write(value.repository, into: &buf)
        FfiConverterTypeGitPatchContent.write(value.content, into: &buf)
        FfiConverterString.write(value.euc, into: &buf)
        FfiConverterSequenceString.write(value.labels, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGitPatch_lift(_ buf: RustBuffer) throws -> GitPatch {
    return try FfiConverterTypeGitPatch.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGitPatch_lower(_ value: GitPatch) -> RustBuffer {
    return FfiConverterTypeGitPatch.lower(value)
}


/**
 * Git Patch Committer
 */
public struct GitPatchCommitter {
    /**
     * Name
     */
    public var name: String?
    /**
     * Email
     */
    public var email: String?
    /**
     * Timestamp
     */
    public var timestamp: Timestamp
    /**
     * Timezone offset in minutes
     */
    public var offsetMinutes: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Name
         */name: String?, 
        /**
         * Email
         */email: String?, 
        /**
         * Timestamp
         */timestamp: Timestamp, 
        /**
         * Timezone offset in minutes
         */offsetMinutes: Int32) {
        self.name = name
        self.email = email
        self.timestamp = timestamp
        self.offsetMinutes = offsetMinutes
    }
}

#if compiler(>=6)
extension GitPatchCommitter: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGitPatchCommitter: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GitPatchCommitter {
        return
            try GitPatchCommitter(
                name: FfiConverterOptionString.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                timestamp: FfiConverterTypeTimestamp.read(from: &buf), 
                offsetMinutes: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: GitPatchCommitter, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterTypeTimestamp.write(value.timestamp, into: &buf)
        FfiConverterInt32.write(value.offsetMinutes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGitPatchCommitter_lift(_ buf: RustBuffer) throws -> GitPatchCommitter {
    return try FfiConverterTypeGitPatchCommitter.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGitPatchCommitter_lower(_ value: GitPatchCommitter) -> RustBuffer {
    return FfiConverterTypeGitPatchCommitter.lower(value)
}


/**
 * Git Repository Announcement
 *
 * Git repositories are hosted in Git-enabled servers, but their existence can be announced using Nostr events,
 * as well as their willingness to receive patches, bug reports and comments in general.
 */
public struct GitRepositoryAnnouncement {
    /**
     * Repository ID (usually kebab-case short name)
     */
    public var id: String
    /**
     * Human-readable project name
     */
    public var name: String?
    /**
     * Brief human-readable project description
     */
    public var description: String?
    /**
     * Webpage urls, if the git server being used provides such a thing
     */
    public var web: [String]
    /**
     * Urls for git-cloning
     */
    public var clone: [String]
    /**
     * Relays that this repository will monitor for patches and issues
     */
    public var relays: [RelayUrl]
    /**
     * Earliest unique commit ID
     *
     * `euc` marker should be the commit ID of the earliest unique commit of this repo,
     * made to identify it among forks and group it with other repositories hosted elsewhere that may represent essentially the same project.
     * In most cases it will be the root commit of a repository.
     * In case of a permanent fork between two projects, then the first commit after the fork should be used.
     */
    public var euc: String?
    /**
     * Other recognized maintainers
     */
    public var maintainers: [PublicKey]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Repository ID (usually kebab-case short name)
         */id: String, 
        /**
         * Human-readable project name
         */name: String?, 
        /**
         * Brief human-readable project description
         */description: String?, 
        /**
         * Webpage urls, if the git server being used provides such a thing
         */web: [String], 
        /**
         * Urls for git-cloning
         */clone: [String], 
        /**
         * Relays that this repository will monitor for patches and issues
         */relays: [RelayUrl], 
        /**
         * Earliest unique commit ID
         *
         * `euc` marker should be the commit ID of the earliest unique commit of this repo,
         * made to identify it among forks and group it with other repositories hosted elsewhere that may represent essentially the same project.
         * In most cases it will be the root commit of a repository.
         * In case of a permanent fork between two projects, then the first commit after the fork should be used.
         */euc: String?, 
        /**
         * Other recognized maintainers
         */maintainers: [PublicKey]) {
        self.id = id
        self.name = name
        self.description = description
        self.web = web
        self.clone = clone
        self.relays = relays
        self.euc = euc
        self.maintainers = maintainers
    }
}

#if compiler(>=6)
extension GitRepositoryAnnouncement: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGitRepositoryAnnouncement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GitRepositoryAnnouncement {
        return
            try GitRepositoryAnnouncement(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                web: FfiConverterSequenceString.read(from: &buf), 
                clone: FfiConverterSequenceString.read(from: &buf), 
                relays: FfiConverterSequenceTypeRelayUrl.read(from: &buf), 
                euc: FfiConverterOptionString.read(from: &buf), 
                maintainers: FfiConverterSequenceTypePublicKey.read(from: &buf)
        )
    }

    public static func write(_ value: GitRepositoryAnnouncement, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterSequenceString.write(value.web, into: &buf)
        FfiConverterSequenceString.write(value.clone, into: &buf)
        FfiConverterSequenceTypeRelayUrl.write(value.relays, into: &buf)
        FfiConverterOptionString.write(value.euc, into: &buf)
        FfiConverterSequenceTypePublicKey.write(value.maintainers, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGitRepositoryAnnouncement_lift(_ buf: RustBuffer) throws -> GitRepositoryAnnouncement {
    return try FfiConverterTypeGitRepositoryAnnouncement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGitRepositoryAnnouncement_lower(_ value: GitRepositoryAnnouncement) -> RustBuffer {
    return FfiConverterTypeGitRepositoryAnnouncement.lower(value)
}


/**
 * Gossip options
 */
public struct GossipOptions {
    /**
     * Max number of relays to use
     */
    public var limits: GossipRelayLimits

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Max number of relays to use
         */limits: GossipRelayLimits) {
        self.limits = limits
    }
}

#if compiler(>=6)
extension GossipOptions: Sendable {}
#endif


extension GossipOptions: Equatable, Hashable {
    public static func ==(lhs: GossipOptions, rhs: GossipOptions) -> Bool {
        if lhs.limits != rhs.limits {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(limits)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGossipOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GossipOptions {
        return
            try GossipOptions(
                limits: FfiConverterTypeGossipRelayLimits.read(from: &buf)
        )
    }

    public static func write(_ value: GossipOptions, into buf: inout [UInt8]) {
        FfiConverterTypeGossipRelayLimits.write(value.limits, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGossipOptions_lift(_ buf: RustBuffer) throws -> GossipOptions {
    return try FfiConverterTypeGossipOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGossipOptions_lower(_ value: GossipOptions) -> RustBuffer {
    return FfiConverterTypeGossipOptions.lower(value)
}


/**
 * Max number of relays to use for gossip
 */
public struct GossipRelayLimits {
    /**
     * Max number of **read** relays per user (default: 3)
     */
    public var readRelaysPerUser: UInt64
    /**
     * Max number of **write** relays per user (default: 3)
     */
    public var writeRelaysPerUser: UInt64
    /**
     * Max number of **hint** relays per user (default: 1)
     */
    public var hintRelaysPerUser: UInt64
    /**
     * Max number of **most used** relays per user (default: 1)
     */
    public var mostUsedRelaysPerUser: UInt64
    /**
     * Max number of NIP-17 relays per user (default: 3)
     */
    public var nip17Relays: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Max number of **read** relays per user (default: 3)
         */readRelaysPerUser: UInt64, 
        /**
         * Max number of **write** relays per user (default: 3)
         */writeRelaysPerUser: UInt64, 
        /**
         * Max number of **hint** relays per user (default: 1)
         */hintRelaysPerUser: UInt64, 
        /**
         * Max number of **most used** relays per user (default: 1)
         */mostUsedRelaysPerUser: UInt64, 
        /**
         * Max number of NIP-17 relays per user (default: 3)
         */nip17Relays: UInt64) {
        self.readRelaysPerUser = readRelaysPerUser
        self.writeRelaysPerUser = writeRelaysPerUser
        self.hintRelaysPerUser = hintRelaysPerUser
        self.mostUsedRelaysPerUser = mostUsedRelaysPerUser
        self.nip17Relays = nip17Relays
    }
}

#if compiler(>=6)
extension GossipRelayLimits: Sendable {}
#endif


extension GossipRelayLimits: Equatable, Hashable {
    public static func ==(lhs: GossipRelayLimits, rhs: GossipRelayLimits) -> Bool {
        if lhs.readRelaysPerUser != rhs.readRelaysPerUser {
            return false
        }
        if lhs.writeRelaysPerUser != rhs.writeRelaysPerUser {
            return false
        }
        if lhs.hintRelaysPerUser != rhs.hintRelaysPerUser {
            return false
        }
        if lhs.mostUsedRelaysPerUser != rhs.mostUsedRelaysPerUser {
            return false
        }
        if lhs.nip17Relays != rhs.nip17Relays {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(readRelaysPerUser)
        hasher.combine(writeRelaysPerUser)
        hasher.combine(hintRelaysPerUser)
        hasher.combine(mostUsedRelaysPerUser)
        hasher.combine(nip17Relays)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGossipRelayLimits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GossipRelayLimits {
        return
            try GossipRelayLimits(
                readRelaysPerUser: FfiConverterUInt64.read(from: &buf), 
                writeRelaysPerUser: FfiConverterUInt64.read(from: &buf), 
                hintRelaysPerUser: FfiConverterUInt64.read(from: &buf), 
                mostUsedRelaysPerUser: FfiConverterUInt64.read(from: &buf), 
                nip17Relays: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: GossipRelayLimits, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.readRelaysPerUser, into: &buf)
        FfiConverterUInt64.write(value.writeRelaysPerUser, into: &buf)
        FfiConverterUInt64.write(value.hintRelaysPerUser, into: &buf)
        FfiConverterUInt64.write(value.mostUsedRelaysPerUser, into: &buf)
        FfiConverterUInt64.write(value.nip17Relays, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGossipRelayLimits_lift(_ buf: RustBuffer) throws -> GossipRelayLimits {
    return try FfiConverterTypeGossipRelayLimits.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGossipRelayLimits_lower(_ value: GossipRelayLimits) -> RustBuffer {
    return FfiConverterTypeGossipRelayLimits.lower(value)
}


public struct HttpData {
    public var url: String
    public var method: HttpMethod
    public var payload: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, method: HttpMethod, payload: String?) {
        self.url = url
        self.method = method
        self.payload = payload
    }
}

#if compiler(>=6)
extension HttpData: Sendable {}
#endif


extension HttpData: Equatable, Hashable {
    public static func ==(lhs: HttpData, rhs: HttpData) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.payload != rhs.payload {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(method)
        hasher.combine(payload)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHttpData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpData {
        return
            try HttpData(
                url: FfiConverterString.read(from: &buf), 
                method: FfiConverterTypeHttpMethod.read(from: &buf), 
                payload: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: HttpData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterTypeHttpMethod.write(value.method, into: &buf)
        FfiConverterOptionString.write(value.payload, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpData_lift(_ buf: RustBuffer) throws -> HttpData {
    return try FfiConverterTypeHttpData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpData_lower(_ value: HttpData) -> RustBuffer {
    return FfiConverterTypeHttpData.lower(value)
}


/**
 * External identity
 *
 * <https://github.com/nostr-protocol/nips/blob/master/39.md>
 */
public struct Identity {
    /**
     * The external identity provider
     */
    public var platform: ExternalIdentity
    /**
     * The user's identity (username) on the provider
     */
    public var ident: String
    /**
     * The user's proof on the provider
     */
    public var proof: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The external identity provider
         */platform: ExternalIdentity, 
        /**
         * The user's identity (username) on the provider
         */ident: String, 
        /**
         * The user's proof on the provider
         */proof: String) {
        self.platform = platform
        self.ident = ident
        self.proof = proof
    }
}

#if compiler(>=6)
extension Identity: Sendable {}
#endif


extension Identity: Equatable, Hashable {
    public static func ==(lhs: Identity, rhs: Identity) -> Bool {
        if lhs.platform != rhs.platform {
            return false
        }
        if lhs.ident != rhs.ident {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(platform)
        hasher.combine(ident)
        hasher.combine(proof)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Identity {
        return
            try Identity(
                platform: FfiConverterTypeExternalIdentity.read(from: &buf), 
                ident: FfiConverterString.read(from: &buf), 
                proof: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Identity, into buf: inout [UInt8]) {
        FfiConverterTypeExternalIdentity.write(value.platform, into: &buf)
        FfiConverterString.write(value.ident, into: &buf)
        FfiConverterString.write(value.proof, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentity_lift(_ buf: RustBuffer) throws -> Identity {
    return try FfiConverterTypeIdentity.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentity_lower(_ value: Identity) -> RustBuffer {
    return FfiConverterTypeIdentity.lower(value)
}


public struct Image {
    public var url: String
    public var dimensions: ImageDimensions?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, dimensions: ImageDimensions?) {
        self.url = url
        self.dimensions = dimensions
    }
}

#if compiler(>=6)
extension Image: Sendable {}
#endif


extension Image: Equatable, Hashable {
    public static func ==(lhs: Image, rhs: Image) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.dimensions != rhs.dimensions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(dimensions)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Image {
        return
            try Image(
                url: FfiConverterString.read(from: &buf), 
                dimensions: FfiConverterOptionTypeImageDimensions.read(from: &buf)
        )
    }

    public static func write(_ value: Image, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterOptionTypeImageDimensions.write(value.dimensions, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImage_lift(_ buf: RustBuffer) throws -> Image {
    return try FfiConverterTypeImage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImage_lower(_ value: Image) -> RustBuffer {
    return FfiConverterTypeImage.lower(value)
}


public struct ImageDimensions {
    /**
     * Width
     */
    public var width: UInt64
    /**
     * Height
     */
    public var height: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Width
         */width: UInt64, 
        /**
         * Height
         */height: UInt64) {
        self.width = width
        self.height = height
    }
}

#if compiler(>=6)
extension ImageDimensions: Sendable {}
#endif


extension ImageDimensions: Equatable, Hashable {
    public static func ==(lhs: ImageDimensions, rhs: ImageDimensions) -> Bool {
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(width)
        hasher.combine(height)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImageDimensions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageDimensions {
        return
            try ImageDimensions(
                width: FfiConverterUInt64.read(from: &buf), 
                height: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ImageDimensions, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.width, into: &buf)
        FfiConverterUInt64.write(value.height, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImageDimensions_lift(_ buf: RustBuffer) throws -> ImageDimensions {
    return try FfiConverterTypeImageDimensions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImageDimensions_lower(_ value: ImageDimensions) -> RustBuffer {
    return FfiConverterTypeImageDimensions.lower(value)
}


/**
 * Topics a user may be interested in and pointers
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
public struct Interests {
    public var hashtags: [String]
    public var coordinate: [Coordinate]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hashtags: [String] = [], coordinate: [Coordinate] = []) {
        self.hashtags = hashtags
        self.coordinate = coordinate
    }
}

#if compiler(>=6)
extension Interests: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInterests: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Interests {
        return
            try Interests(
                hashtags: FfiConverterSequenceString.read(from: &buf), 
                coordinate: FfiConverterSequenceTypeCoordinate.read(from: &buf)
        )
    }

    public static func write(_ value: Interests, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.hashtags, into: &buf)
        FfiConverterSequenceTypeCoordinate.write(value.coordinate, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInterests_lift(_ buf: RustBuffer) throws -> Interests {
    return try FfiConverterTypeInterests.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInterests_lower(_ value: Interests) -> RustBuffer {
    return FfiConverterTypeInterests.lower(value)
}


/**
 * TLVs to be added to the keysend payment
 */
public struct KeysendTlvRecord {
    /**
     * TLV type
     */
    public var tlvType: UInt64
    /**
     * TLV value
     */
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * TLV type
         */tlvType: UInt64, 
        /**
         * TLV value
         */value: String) {
        self.tlvType = tlvType
        self.value = value
    }
}

#if compiler(>=6)
extension KeysendTlvRecord: Sendable {}
#endif


extension KeysendTlvRecord: Equatable, Hashable {
    public static func ==(lhs: KeysendTlvRecord, rhs: KeysendTlvRecord) -> Bool {
        if lhs.tlvType != rhs.tlvType {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tlvType)
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeysendTLVRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeysendTlvRecord {
        return
            try KeysendTlvRecord(
                tlvType: FfiConverterUInt64.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: KeysendTlvRecord, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.tlvType, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeysendTLVRecord_lift(_ buf: RustBuffer) throws -> KeysendTlvRecord {
    return try FfiConverterTypeKeysendTLVRecord.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeysendTLVRecord_lower(_ value: KeysendTlvRecord) -> RustBuffer {
    return FfiConverterTypeKeysendTLVRecord.lower(value)
}


/**
 * These are limitations imposed by the relay on clients. Your client should
 * expect that requests which exceed these practical limitations are rejected or fail immediately.
 */
public struct Limitation {
    /**
     * Maximum number of bytes for incoming JSON that the relay will attempt to decode and act upon
     */
    public var maxMessageLength: Int32?
    /**
     * Total number of subscriptions that may be active on a single websocket connection
     */
    public var maxSubscriptions: Int32?
    /**
     * Maximum number of filter values in each subscription
     */
    public var maxFilters: Int32?
    /**
     * Relay will clamp each filter's limit value to this number
     */
    public var maxLimit: Int32?
    /**
     * Maximum length of subscription id as a string
     */
    public var maxSubidLength: Int32?
    /**
     * Maximum number of elements in the tags list
     */
    public var maxEventTags: Int32?
    /**
     * Maximum number of characters in the content field of any event
     */
    public var maxContentLength: Int32?
    /**
     * New events will require at least this difficulty of PoW,
     */
    public var minPowDifficulty: Int32?
    /**
     * Relay requires NIP42 authentication to happen before a new connection may perform any other action
     */
    public var authRequired: Bool?
    /**
     * Relay requires payment before a new connection may perform any action
     */
    public var paymentRequired: Bool?
    /**
     * 'created_at' lower limit
     */
    public var createdAtLowerLimit: Timestamp?
    /**
     * 'created_at' upper limit
     */
    public var createdAtUpperLimit: Timestamp?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Maximum number of bytes for incoming JSON that the relay will attempt to decode and act upon
         */maxMessageLength: Int32?, 
        /**
         * Total number of subscriptions that may be active on a single websocket connection
         */maxSubscriptions: Int32?, 
        /**
         * Maximum number of filter values in each subscription
         */maxFilters: Int32?, 
        /**
         * Relay will clamp each filter's limit value to this number
         */maxLimit: Int32?, 
        /**
         * Maximum length of subscription id as a string
         */maxSubidLength: Int32?, 
        /**
         * Maximum number of elements in the tags list
         */maxEventTags: Int32?, 
        /**
         * Maximum number of characters in the content field of any event
         */maxContentLength: Int32?, 
        /**
         * New events will require at least this difficulty of PoW,
         */minPowDifficulty: Int32?, 
        /**
         * Relay requires NIP42 authentication to happen before a new connection may perform any other action
         */authRequired: Bool?, 
        /**
         * Relay requires payment before a new connection may perform any action
         */paymentRequired: Bool?, 
        /**
         * 'created_at' lower limit
         */createdAtLowerLimit: Timestamp?, 
        /**
         * 'created_at' upper limit
         */createdAtUpperLimit: Timestamp?) {
        self.maxMessageLength = maxMessageLength
        self.maxSubscriptions = maxSubscriptions
        self.maxFilters = maxFilters
        self.maxLimit = maxLimit
        self.maxSubidLength = maxSubidLength
        self.maxEventTags = maxEventTags
        self.maxContentLength = maxContentLength
        self.minPowDifficulty = minPowDifficulty
        self.authRequired = authRequired
        self.paymentRequired = paymentRequired
        self.createdAtLowerLimit = createdAtLowerLimit
        self.createdAtUpperLimit = createdAtUpperLimit
    }
}

#if compiler(>=6)
extension Limitation: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLimitation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Limitation {
        return
            try Limitation(
                maxMessageLength: FfiConverterOptionInt32.read(from: &buf), 
                maxSubscriptions: FfiConverterOptionInt32.read(from: &buf), 
                maxFilters: FfiConverterOptionInt32.read(from: &buf), 
                maxLimit: FfiConverterOptionInt32.read(from: &buf), 
                maxSubidLength: FfiConverterOptionInt32.read(from: &buf), 
                maxEventTags: FfiConverterOptionInt32.read(from: &buf), 
                maxContentLength: FfiConverterOptionInt32.read(from: &buf), 
                minPowDifficulty: FfiConverterOptionInt32.read(from: &buf), 
                authRequired: FfiConverterOptionBool.read(from: &buf), 
                paymentRequired: FfiConverterOptionBool.read(from: &buf), 
                createdAtLowerLimit: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                createdAtUpperLimit: FfiConverterOptionTypeTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: Limitation, into buf: inout [UInt8]) {
        FfiConverterOptionInt32.write(value.maxMessageLength, into: &buf)
        FfiConverterOptionInt32.write(value.maxSubscriptions, into: &buf)
        FfiConverterOptionInt32.write(value.maxFilters, into: &buf)
        FfiConverterOptionInt32.write(value.maxLimit, into: &buf)
        FfiConverterOptionInt32.write(value.maxSubidLength, into: &buf)
        FfiConverterOptionInt32.write(value.maxEventTags, into: &buf)
        FfiConverterOptionInt32.write(value.maxContentLength, into: &buf)
        FfiConverterOptionInt32.write(value.minPowDifficulty, into: &buf)
        FfiConverterOptionBool.write(value.authRequired, into: &buf)
        FfiConverterOptionBool.write(value.paymentRequired, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.createdAtLowerLimit, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.createdAtUpperLimit, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLimitation_lift(_ buf: RustBuffer) throws -> Limitation {
    return try FfiConverterTypeLimitation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLimitation_lower(_ value: Limitation) -> RustBuffer {
    return FfiConverterTypeLimitation.lower(value)
}


/**
 * List Invoice Request
 */
public struct ListTransactionsRequest {
    /**
     * Starting timestamp in seconds since epoch
     */
    public var from: Timestamp?
    /**
     * Ending timestamp in seconds since epoch
     */
    public var until: Timestamp?
    /**
     * Number of invoices to return
     */
    public var limit: UInt64?
    /**
     * Offset of the first invoice to return
     */
    public var offset: UInt64?
    /**
     * If true, include unpaid invoices
     */
    public var unpaid: Bool?
    /**
     * [`TransactionType::Incoming`] for invoices, [`TransactionType::Outgoing`] for payments, [`None`] for both
     */
    public var transactionType: TransactionType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Starting timestamp in seconds since epoch
         */from: Timestamp?, 
        /**
         * Ending timestamp in seconds since epoch
         */until: Timestamp?, 
        /**
         * Number of invoices to return
         */limit: UInt64?, 
        /**
         * Offset of the first invoice to return
         */offset: UInt64?, 
        /**
         * If true, include unpaid invoices
         */unpaid: Bool?, 
        /**
         * [`TransactionType::Incoming`] for invoices, [`TransactionType::Outgoing`] for payments, [`None`] for both
         */transactionType: TransactionType?) {
        self.from = from
        self.until = until
        self.limit = limit
        self.offset = offset
        self.unpaid = unpaid
        self.transactionType = transactionType
    }
}

#if compiler(>=6)
extension ListTransactionsRequest: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListTransactionsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListTransactionsRequest {
        return
            try ListTransactionsRequest(
                from: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                until: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                limit: FfiConverterOptionUInt64.read(from: &buf), 
                offset: FfiConverterOptionUInt64.read(from: &buf), 
                unpaid: FfiConverterOptionBool.read(from: &buf), 
                transactionType: FfiConverterOptionTypeTransactionType.read(from: &buf)
        )
    }

    public static func write(_ value: ListTransactionsRequest, into buf: inout [UInt8]) {
        FfiConverterOptionTypeTimestamp.write(value.from, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.until, into: &buf)
        FfiConverterOptionUInt64.write(value.limit, into: &buf)
        FfiConverterOptionUInt64.write(value.offset, into: &buf)
        FfiConverterOptionBool.write(value.unpaid, into: &buf)
        FfiConverterOptionTypeTransactionType.write(value.transactionType, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListTransactionsRequest_lift(_ buf: RustBuffer) throws -> ListTransactionsRequest {
    return try FfiConverterTypeListTransactionsRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListTransactionsRequest_lower(_ value: ListTransactionsRequest) -> RustBuffer {
    return FfiConverterTypeListTransactionsRequest.lower(value)
}


public struct LiveEvent {
    public var id: String
    public var title: String?
    public var summary: String?
    public var image: Image?
    public var hashtags: [String]
    public var streaming: String?
    public var recording: String?
    public var start: Timestamp?
    public var ends: Timestamp?
    public var status: LiveEventStatus?
    public var currentParticipants: UInt64?
    public var totalParticipants: UInt64?
    public var relays: [RelayUrl]
    public var host: LiveEventHost?
    public var speakers: [Person]
    public var participants: [Person]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, title: String?, summary: String?, image: Image?, hashtags: [String], streaming: String?, recording: String?, start: Timestamp?, ends: Timestamp?, status: LiveEventStatus?, currentParticipants: UInt64?, totalParticipants: UInt64?, relays: [RelayUrl], host: LiveEventHost?, speakers: [Person], participants: [Person]) {
        self.id = id
        self.title = title
        self.summary = summary
        self.image = image
        self.hashtags = hashtags
        self.streaming = streaming
        self.recording = recording
        self.start = start
        self.ends = ends
        self.status = status
        self.currentParticipants = currentParticipants
        self.totalParticipants = totalParticipants
        self.relays = relays
        self.host = host
        self.speakers = speakers
        self.participants = participants
    }
}

#if compiler(>=6)
extension LiveEvent: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLiveEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveEvent {
        return
            try LiveEvent(
                id: FfiConverterString.read(from: &buf), 
                title: FfiConverterOptionString.read(from: &buf), 
                summary: FfiConverterOptionString.read(from: &buf), 
                image: FfiConverterOptionTypeImage.read(from: &buf), 
                hashtags: FfiConverterSequenceString.read(from: &buf), 
                streaming: FfiConverterOptionString.read(from: &buf), 
                recording: FfiConverterOptionString.read(from: &buf), 
                start: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                ends: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                status: FfiConverterOptionTypeLiveEventStatus.read(from: &buf), 
                currentParticipants: FfiConverterOptionUInt64.read(from: &buf), 
                totalParticipants: FfiConverterOptionUInt64.read(from: &buf), 
                relays: FfiConverterSequenceTypeRelayUrl.read(from: &buf), 
                host: FfiConverterOptionTypeLiveEventHost.read(from: &buf), 
                speakers: FfiConverterSequenceTypePerson.read(from: &buf), 
                participants: FfiConverterSequenceTypePerson.read(from: &buf)
        )
    }

    public static func write(_ value: LiveEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.summary, into: &buf)
        FfiConverterOptionTypeImage.write(value.image, into: &buf)
        FfiConverterSequenceString.write(value.hashtags, into: &buf)
        FfiConverterOptionString.write(value.streaming, into: &buf)
        FfiConverterOptionString.write(value.recording, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.start, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.ends, into: &buf)
        FfiConverterOptionTypeLiveEventStatus.write(value.status, into: &buf)
        FfiConverterOptionUInt64.write(value.currentParticipants, into: &buf)
        FfiConverterOptionUInt64.write(value.totalParticipants, into: &buf)
        FfiConverterSequenceTypeRelayUrl.write(value.relays, into: &buf)
        FfiConverterOptionTypeLiveEventHost.write(value.host, into: &buf)
        FfiConverterSequenceTypePerson.write(value.speakers, into: &buf)
        FfiConverterSequenceTypePerson.write(value.participants, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveEvent_lift(_ buf: RustBuffer) throws -> LiveEvent {
    return try FfiConverterTypeLiveEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveEvent_lower(_ value: LiveEvent) -> RustBuffer {
    return FfiConverterTypeLiveEvent.lower(value)
}


public struct LiveEventHost {
    public var publicKey: PublicKey
    public var relayUrl: RelayUrl?
    public var proof: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: PublicKey, relayUrl: RelayUrl?, proof: String?) {
        self.publicKey = publicKey
        self.relayUrl = relayUrl
        self.proof = proof
    }
}

#if compiler(>=6)
extension LiveEventHost: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLiveEventHost: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveEventHost {
        return
            try LiveEventHost(
                publicKey: FfiConverterTypePublicKey.read(from: &buf), 
                relayUrl: FfiConverterOptionTypeRelayUrl.read(from: &buf), 
                proof: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LiveEventHost, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterOptionTypeRelayUrl.write(value.relayUrl, into: &buf)
        FfiConverterOptionString.write(value.proof, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveEventHost_lift(_ buf: RustBuffer) throws -> LiveEventHost {
    return try FfiConverterTypeLiveEventHost.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveEventHost_lower(_ value: LiveEventHost) -> RustBuffer {
    return FfiConverterTypeLiveEventHost.lower(value)
}


/**
 * Lookup Invoice Request
 */
public struct LookupInvoiceRequest {
    /**
     * Payment hash of invoice
     */
    public var paymentHash: String?
    /**
     * Bolt11 invoice
     */
    public var invoice: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Payment hash of invoice
         */paymentHash: String?, 
        /**
         * Bolt11 invoice
         */invoice: String?) {
        self.paymentHash = paymentHash
        self.invoice = invoice
    }
}

#if compiler(>=6)
extension LookupInvoiceRequest: Sendable {}
#endif


extension LookupInvoiceRequest: Equatable, Hashable {
    public static func ==(lhs: LookupInvoiceRequest, rhs: LookupInvoiceRequest) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
        hasher.combine(invoice)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLookupInvoiceRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LookupInvoiceRequest {
        return
            try LookupInvoiceRequest(
                paymentHash: FfiConverterOptionString.read(from: &buf), 
                invoice: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LookupInvoiceRequest, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.paymentHash, into: &buf)
        FfiConverterOptionString.write(value.invoice, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLookupInvoiceRequest_lift(_ buf: RustBuffer) throws -> LookupInvoiceRequest {
    return try FfiConverterTypeLookupInvoiceRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLookupInvoiceRequest_lower(_ value: LookupInvoiceRequest) -> RustBuffer {
    return FfiConverterTypeLookupInvoiceRequest.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct LookupInvoiceResponse {
    /**
     * Transaction type
     */
    public var transactionType: TransactionType?
    /**
     * Transaction state.
     */
    public var state: TransactionState?
    /**
     * Bolt11 invoice
     */
    public var invoice: String?
    /**
     * Invoice's description
     */
    public var description: String?
    /**
     * Invoice's description hash
     */
    public var descriptionHash: String?
    /**
     * Payment preimage
     */
    public var preimage: String?
    /**
     * Payment hash
     */
    public var paymentHash: String
    /**
     * Amount in millisatoshis
     */
    public var amount: UInt64
    /**
     * Fees paid in millisatoshis
     */
    public var feesPaid: UInt64
    /**
     * Creation timestamp in seconds since epoch
     */
    public var createdAt: Timestamp
    /**
     * Expiration timestamp in seconds since epoch
     */
    public var expiresAt: Timestamp?
    /**
     * Settled timestamp in seconds since epoch
     */
    public var settledAt: Timestamp?
    /**
     * Optional metadata about the payment
     */
    public var metadata: JsonValue?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Transaction type
         */transactionType: TransactionType?, 
        /**
         * Transaction state.
         */state: TransactionState?, 
        /**
         * Bolt11 invoice
         */invoice: String?, 
        /**
         * Invoice's description
         */description: String?, 
        /**
         * Invoice's description hash
         */descriptionHash: String?, 
        /**
         * Payment preimage
         */preimage: String?, 
        /**
         * Payment hash
         */paymentHash: String, 
        /**
         * Amount in millisatoshis
         */amount: UInt64, 
        /**
         * Fees paid in millisatoshis
         */feesPaid: UInt64, 
        /**
         * Creation timestamp in seconds since epoch
         */createdAt: Timestamp, 
        /**
         * Expiration timestamp in seconds since epoch
         */expiresAt: Timestamp?, 
        /**
         * Settled timestamp in seconds since epoch
         */settledAt: Timestamp?, 
        /**
         * Optional metadata about the payment
         */metadata: JsonValue?) {
        self.transactionType = transactionType
        self.state = state
        self.invoice = invoice
        self.description = description
        self.descriptionHash = descriptionHash
        self.preimage = preimage
        self.paymentHash = paymentHash
        self.amount = amount
        self.feesPaid = feesPaid
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.settledAt = settledAt
        self.metadata = metadata
    }
}

#if compiler(>=6)
extension LookupInvoiceResponse: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLookupInvoiceResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LookupInvoiceResponse {
        return
            try LookupInvoiceResponse(
                transactionType: FfiConverterOptionTypeTransactionType.read(from: &buf), 
                state: FfiConverterOptionTypeTransactionState.read(from: &buf), 
                invoice: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                descriptionHash: FfiConverterOptionString.read(from: &buf), 
                preimage: FfiConverterOptionString.read(from: &buf), 
                paymentHash: FfiConverterString.read(from: &buf), 
                amount: FfiConverterUInt64.read(from: &buf), 
                feesPaid: FfiConverterUInt64.read(from: &buf), 
                createdAt: FfiConverterTypeTimestamp.read(from: &buf), 
                expiresAt: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                settledAt: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                metadata: FfiConverterOptionTypeJsonValue.read(from: &buf)
        )
    }

    public static func write(_ value: LookupInvoiceResponse, into buf: inout [UInt8]) {
        FfiConverterOptionTypeTransactionType.write(value.transactionType, into: &buf)
        FfiConverterOptionTypeTransactionState.write(value.state, into: &buf)
        FfiConverterOptionString.write(value.invoice, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.descriptionHash, into: &buf)
        FfiConverterOptionString.write(value.preimage, into: &buf)
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterUInt64.write(value.amount, into: &buf)
        FfiConverterUInt64.write(value.feesPaid, into: &buf)
        FfiConverterTypeTimestamp.write(value.createdAt, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.expiresAt, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.settledAt, into: &buf)
        FfiConverterOptionTypeJsonValue.write(value.metadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLookupInvoiceResponse_lift(_ buf: RustBuffer) throws -> LookupInvoiceResponse {
    return try FfiConverterTypeLookupInvoiceResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLookupInvoiceResponse_lower(_ value: LookupInvoiceResponse) -> RustBuffer {
    return FfiConverterTypeLookupInvoiceResponse.lower(value)
}


/**
 * Make Hold Invoice Request
 */
public struct MakeHoldInvoiceRequest {
    /**
     * Amount in millisatoshis
     */
    public var amount: UInt64
    /**
     * Invoice description
     */
    public var description: String?
    /**
     * Invoice description hash
     */
    public var descriptionHash: String?
    /**
     * Invoice expiry in seconds
     */
    public var expiry: UInt64?
    /**
     * payment_hash
     */
    public var paymentHash: String
    /**
     * The minimum CLTV delta to use for the final hop
     */
    public var cltvExpiryDelta: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Amount in millisatoshis
         */amount: UInt64, 
        /**
         * Invoice description
         */description: String?, 
        /**
         * Invoice description hash
         */descriptionHash: String?, 
        /**
         * Invoice expiry in seconds
         */expiry: UInt64?, 
        /**
         * payment_hash
         */paymentHash: String, 
        /**
         * The minimum CLTV delta to use for the final hop
         */cltvExpiryDelta: UInt32?) {
        self.amount = amount
        self.description = description
        self.descriptionHash = descriptionHash
        self.expiry = expiry
        self.paymentHash = paymentHash
        self.cltvExpiryDelta = cltvExpiryDelta
    }
}

#if compiler(>=6)
extension MakeHoldInvoiceRequest: Sendable {}
#endif


extension MakeHoldInvoiceRequest: Equatable, Hashable {
    public static func ==(lhs: MakeHoldInvoiceRequest, rhs: MakeHoldInvoiceRequest) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.descriptionHash != rhs.descriptionHash {
            return false
        }
        if lhs.expiry != rhs.expiry {
            return false
        }
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(description)
        hasher.combine(descriptionHash)
        hasher.combine(expiry)
        hasher.combine(paymentHash)
        hasher.combine(cltvExpiryDelta)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMakeHoldInvoiceRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MakeHoldInvoiceRequest {
        return
            try MakeHoldInvoiceRequest(
                amount: FfiConverterUInt64.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                descriptionHash: FfiConverterOptionString.read(from: &buf), 
                expiry: FfiConverterOptionUInt64.read(from: &buf), 
                paymentHash: FfiConverterString.read(from: &buf), 
                cltvExpiryDelta: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: MakeHoldInvoiceRequest, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.descriptionHash, into: &buf)
        FfiConverterOptionUInt64.write(value.expiry, into: &buf)
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterOptionUInt32.write(value.cltvExpiryDelta, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMakeHoldInvoiceRequest_lift(_ buf: RustBuffer) throws -> MakeHoldInvoiceRequest {
    return try FfiConverterTypeMakeHoldInvoiceRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMakeHoldInvoiceRequest_lower(_ value: MakeHoldInvoiceRequest) -> RustBuffer {
    return FfiConverterTypeMakeHoldInvoiceRequest.lower(value)
}


/**
 * Make Hold Invoice Response
 */
public struct MakeHoldInvoiceResponse {
    /**
     * Transaction type
     */
    public var transactionType: TransactionType
    /**
     * Bolt11 invoice
     */
    public var invoice: String?
    /**
     * Description
     */
    public var description: String?
    /**
     * Description hash
     */
    public var descriptionHash: String?
    /**
     * Payment hash
     */
    public var paymentHash: String
    /**
     * Amount in millisatoshis
     */
    public var amount: UInt64
    /**
     * Creation timestamp
     */
    public var createdAt: Timestamp
    /**
     * Expiration timestamp
     */
    public var expiresAt: Timestamp
    /**
     * Metadata
     */
    public var metadata: JsonValue?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Transaction type
         */transactionType: TransactionType, 
        /**
         * Bolt11 invoice
         */invoice: String?, 
        /**
         * Description
         */description: String?, 
        /**
         * Description hash
         */descriptionHash: String?, 
        /**
         * Payment hash
         */paymentHash: String, 
        /**
         * Amount in millisatoshis
         */amount: UInt64, 
        /**
         * Creation timestamp
         */createdAt: Timestamp, 
        /**
         * Expiration timestamp
         */expiresAt: Timestamp, 
        /**
         * Metadata
         */metadata: JsonValue?) {
        self.transactionType = transactionType
        self.invoice = invoice
        self.description = description
        self.descriptionHash = descriptionHash
        self.paymentHash = paymentHash
        self.amount = amount
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.metadata = metadata
    }
}

#if compiler(>=6)
extension MakeHoldInvoiceResponse: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMakeHoldInvoiceResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MakeHoldInvoiceResponse {
        return
            try MakeHoldInvoiceResponse(
                transactionType: FfiConverterTypeTransactionType.read(from: &buf), 
                invoice: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                descriptionHash: FfiConverterOptionString.read(from: &buf), 
                paymentHash: FfiConverterString.read(from: &buf), 
                amount: FfiConverterUInt64.read(from: &buf), 
                createdAt: FfiConverterTypeTimestamp.read(from: &buf), 
                expiresAt: FfiConverterTypeTimestamp.read(from: &buf), 
                metadata: FfiConverterOptionTypeJsonValue.read(from: &buf)
        )
    }

    public static func write(_ value: MakeHoldInvoiceResponse, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionType.write(value.transactionType, into: &buf)
        FfiConverterOptionString.write(value.invoice, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.descriptionHash, into: &buf)
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterUInt64.write(value.amount, into: &buf)
        FfiConverterTypeTimestamp.write(value.createdAt, into: &buf)
        FfiConverterTypeTimestamp.write(value.expiresAt, into: &buf)
        FfiConverterOptionTypeJsonValue.write(value.metadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMakeHoldInvoiceResponse_lift(_ buf: RustBuffer) throws -> MakeHoldInvoiceResponse {
    return try FfiConverterTypeMakeHoldInvoiceResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMakeHoldInvoiceResponse_lower(_ value: MakeHoldInvoiceResponse) -> RustBuffer {
    return FfiConverterTypeMakeHoldInvoiceResponse.lower(value)
}


/**
 * Make Invoice Request
 */
public struct MakeInvoiceRequest {
    /**
     * Amount in millisatoshis
     */
    public var amount: UInt64
    /**
     * Invoice description
     */
    public var description: String?
    /**
     * Invoice description hash
     */
    public var descriptionHash: String?
    /**
     * Invoice expiry in seconds
     */
    public var expiry: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Amount in millisatoshis
         */amount: UInt64, 
        /**
         * Invoice description
         */description: String?, 
        /**
         * Invoice description hash
         */descriptionHash: String?, 
        /**
         * Invoice expiry in seconds
         */expiry: UInt64?) {
        self.amount = amount
        self.description = description
        self.descriptionHash = descriptionHash
        self.expiry = expiry
    }
}

#if compiler(>=6)
extension MakeInvoiceRequest: Sendable {}
#endif


extension MakeInvoiceRequest: Equatable, Hashable {
    public static func ==(lhs: MakeInvoiceRequest, rhs: MakeInvoiceRequest) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.descriptionHash != rhs.descriptionHash {
            return false
        }
        if lhs.expiry != rhs.expiry {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(description)
        hasher.combine(descriptionHash)
        hasher.combine(expiry)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMakeInvoiceRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MakeInvoiceRequest {
        return
            try MakeInvoiceRequest(
                amount: FfiConverterUInt64.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                descriptionHash: FfiConverterOptionString.read(from: &buf), 
                expiry: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: MakeInvoiceRequest, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.descriptionHash, into: &buf)
        FfiConverterOptionUInt64.write(value.expiry, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMakeInvoiceRequest_lift(_ buf: RustBuffer) throws -> MakeInvoiceRequest {
    return try FfiConverterTypeMakeInvoiceRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMakeInvoiceRequest_lower(_ value: MakeInvoiceRequest) -> RustBuffer {
    return FfiConverterTypeMakeInvoiceRequest.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct MakeInvoiceResponse {
    /**
     * Bolt 11 invoice
     */
    public var invoice: String
    /**
     * Invoice's payment hash
     */
    public var paymentHash: String?
    /**
     * Invoice's description
     */
    public var description: String?
    /**
     * Invoice's description hash
     */
    public var descriptionHash: String?
    /**
     * Payment preimage
     */
    public var preimage: String?
    /**
     * Amount in msats.
     */
    public var amount: UInt64?
    /**
     * Creation timestamp in seconds since epoch
     */
    public var createdAt: Timestamp?
    /**
     * Expiration timestamp in seconds since epoch
     */
    public var expiresAt: Timestamp?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Bolt 11 invoice
         */invoice: String, 
        /**
         * Invoice's payment hash
         */paymentHash: String?, 
        /**
         * Invoice's description
         */description: String?, 
        /**
         * Invoice's description hash
         */descriptionHash: String?, 
        /**
         * Payment preimage
         */preimage: String?, 
        /**
         * Amount in msats.
         */amount: UInt64?, 
        /**
         * Creation timestamp in seconds since epoch
         */createdAt: Timestamp?, 
        /**
         * Expiration timestamp in seconds since epoch
         */expiresAt: Timestamp?) {
        self.invoice = invoice
        self.paymentHash = paymentHash
        self.description = description
        self.descriptionHash = descriptionHash
        self.preimage = preimage
        self.amount = amount
        self.createdAt = createdAt
        self.expiresAt = expiresAt
    }
}

#if compiler(>=6)
extension MakeInvoiceResponse: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMakeInvoiceResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MakeInvoiceResponse {
        return
            try MakeInvoiceResponse(
                invoice: FfiConverterString.read(from: &buf), 
                paymentHash: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                descriptionHash: FfiConverterOptionString.read(from: &buf), 
                preimage: FfiConverterOptionString.read(from: &buf), 
                amount: FfiConverterOptionUInt64.read(from: &buf), 
                createdAt: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                expiresAt: FfiConverterOptionTypeTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: MakeInvoiceResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterOptionString.write(value.paymentHash, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.descriptionHash, into: &buf)
        FfiConverterOptionString.write(value.preimage, into: &buf)
        FfiConverterOptionUInt64.write(value.amount, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.createdAt, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.expiresAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMakeInvoiceResponse_lift(_ buf: RustBuffer) throws -> MakeInvoiceResponse {
    return try FfiConverterTypeMakeInvoiceResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMakeInvoiceResponse_lower(_ value: MakeInvoiceResponse) -> RustBuffer {
    return FfiConverterTypeMakeInvoiceResponse.lower(value)
}


public struct MetadataRecord {
    /**
     * Name
     */
    public var name: String?
    /**
     * Display name
     */
    public var displayName: String?
    /**
     * Description
     */
    public var about: String?
    /**
     * Website url
     */
    public var website: String?
    /**
     * Picture url
     */
    public var picture: String?
    /**
     * Banner url
     */
    public var banner: String?
    /**
     * NIP05 (ex. name@example.com)
     */
    public var nip05: String?
    /**
     * LNURL
     */
    public var lud06: String?
    /**
     * Lightning Address
     */
    public var lud16: String?
    /**
     * Additional custom metadata
     */
    public var custom: [String: JsonValue]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Name
         */name: String? = nil, 
        /**
         * Display name
         */displayName: String? = nil, 
        /**
         * Description
         */about: String? = nil, 
        /**
         * Website url
         */website: String? = nil, 
        /**
         * Picture url
         */picture: String? = nil, 
        /**
         * Banner url
         */banner: String? = nil, 
        /**
         * NIP05 (ex. name@example.com)
         */nip05: String? = nil, 
        /**
         * LNURL
         */lud06: String? = nil, 
        /**
         * Lightning Address
         */lud16: String? = nil, 
        /**
         * Additional custom metadata
         */custom: [String: JsonValue]? = nil) {
        self.name = name
        self.displayName = displayName
        self.about = about
        self.website = website
        self.picture = picture
        self.banner = banner
        self.nip05 = nip05
        self.lud06 = lud06
        self.lud16 = lud16
        self.custom = custom
    }
}

#if compiler(>=6)
extension MetadataRecord: Sendable {}
#endif


extension MetadataRecord: Equatable, Hashable {
    public static func ==(lhs: MetadataRecord, rhs: MetadataRecord) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.about != rhs.about {
            return false
        }
        if lhs.website != rhs.website {
            return false
        }
        if lhs.picture != rhs.picture {
            return false
        }
        if lhs.banner != rhs.banner {
            return false
        }
        if lhs.nip05 != rhs.nip05 {
            return false
        }
        if lhs.lud06 != rhs.lud06 {
            return false
        }
        if lhs.lud16 != rhs.lud16 {
            return false
        }
        if lhs.custom != rhs.custom {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(displayName)
        hasher.combine(about)
        hasher.combine(website)
        hasher.combine(picture)
        hasher.combine(banner)
        hasher.combine(nip05)
        hasher.combine(lud06)
        hasher.combine(lud16)
        hasher.combine(custom)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMetadataRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetadataRecord {
        return
            try MetadataRecord(
                name: FfiConverterOptionString.read(from: &buf), 
                displayName: FfiConverterOptionString.read(from: &buf), 
                about: FfiConverterOptionString.read(from: &buf), 
                website: FfiConverterOptionString.read(from: &buf), 
                picture: FfiConverterOptionString.read(from: &buf), 
                banner: FfiConverterOptionString.read(from: &buf), 
                nip05: FfiConverterOptionString.read(from: &buf), 
                lud06: FfiConverterOptionString.read(from: &buf), 
                lud16: FfiConverterOptionString.read(from: &buf), 
                custom: FfiConverterOptionDictionaryStringTypeJsonValue.read(from: &buf)
        )
    }

    public static func write(_ value: MetadataRecord, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.about, into: &buf)
        FfiConverterOptionString.write(value.website, into: &buf)
        FfiConverterOptionString.write(value.picture, into: &buf)
        FfiConverterOptionString.write(value.banner, into: &buf)
        FfiConverterOptionString.write(value.nip05, into: &buf)
        FfiConverterOptionString.write(value.lud06, into: &buf)
        FfiConverterOptionString.write(value.lud16, into: &buf)
        FfiConverterOptionDictionaryStringTypeJsonValue.write(value.custom, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMetadataRecord_lift(_ buf: RustBuffer) throws -> MetadataRecord {
    return try FfiConverterTypeMetadataRecord.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMetadataRecord_lower(_ value: MetadataRecord) -> RustBuffer {
    return FfiConverterTypeMetadataRecord.lower(value)
}


/**
 * Multi Pay Invoice Request Params
 */
public struct MultiPayInvoiceRequest {
    /**
     * Invoices to pay
     */
    public var invoices: [PayInvoiceRequest]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Invoices to pay
         */invoices: [PayInvoiceRequest]) {
        self.invoices = invoices
    }
}

#if compiler(>=6)
extension MultiPayInvoiceRequest: Sendable {}
#endif


extension MultiPayInvoiceRequest: Equatable, Hashable {
    public static func ==(lhs: MultiPayInvoiceRequest, rhs: MultiPayInvoiceRequest) -> Bool {
        if lhs.invoices != rhs.invoices {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoices)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMultiPayInvoiceRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiPayInvoiceRequest {
        return
            try MultiPayInvoiceRequest(
                invoices: FfiConverterSequenceTypePayInvoiceRequest.read(from: &buf)
        )
    }

    public static func write(_ value: MultiPayInvoiceRequest, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePayInvoiceRequest.write(value.invoices, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiPayInvoiceRequest_lift(_ buf: RustBuffer) throws -> MultiPayInvoiceRequest {
    return try FfiConverterTypeMultiPayInvoiceRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiPayInvoiceRequest_lower(_ value: MultiPayInvoiceRequest) -> RustBuffer {
    return FfiConverterTypeMultiPayInvoiceRequest.lower(value)
}


/**
 * Multi Pay Keysend Request
 */
public struct MultiPayKeysendRequest {
    /**
     * Keysends
     */
    public var keysends: [PayKeysendRequest]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Keysends
         */keysends: [PayKeysendRequest]) {
        self.keysends = keysends
    }
}

#if compiler(>=6)
extension MultiPayKeysendRequest: Sendable {}
#endif


extension MultiPayKeysendRequest: Equatable, Hashable {
    public static func ==(lhs: MultiPayKeysendRequest, rhs: MultiPayKeysendRequest) -> Bool {
        if lhs.keysends != rhs.keysends {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(keysends)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMultiPayKeysendRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiPayKeysendRequest {
        return
            try MultiPayKeysendRequest(
                keysends: FfiConverterSequenceTypePayKeysendRequest.read(from: &buf)
        )
    }

    public static func write(_ value: MultiPayKeysendRequest, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePayKeysendRequest.write(value.keysends, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiPayKeysendRequest_lift(_ buf: RustBuffer) throws -> MultiPayKeysendRequest {
    return try FfiConverterTypeMultiPayKeysendRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiPayKeysendRequest_lower(_ value: MultiPayKeysendRequest) -> RustBuffer {
    return FfiConverterTypeMultiPayKeysendRequest.lower(value)
}


/**
 * Things the user doesn't want to see in their feeds
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
public struct MuteList {
    public var publicKeys: [PublicKey]
    public var hashtags: [String]
    public var eventIds: [EventId]
    public var words: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKeys: [PublicKey] = [], hashtags: [String] = [], eventIds: [EventId] = [], words: [String] = []) {
        self.publicKeys = publicKeys
        self.hashtags = hashtags
        self.eventIds = eventIds
        self.words = words
    }
}

#if compiler(>=6)
extension MuteList: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMuteList: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MuteList {
        return
            try MuteList(
                publicKeys: FfiConverterSequenceTypePublicKey.read(from: &buf), 
                hashtags: FfiConverterSequenceString.read(from: &buf), 
                eventIds: FfiConverterSequenceTypeEventId.read(from: &buf), 
                words: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: MuteList, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePublicKey.write(value.publicKeys, into: &buf)
        FfiConverterSequenceString.write(value.hashtags, into: &buf)
        FfiConverterSequenceTypeEventId.write(value.eventIds, into: &buf)
        FfiConverterSequenceString.write(value.words, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMuteList_lift(_ buf: RustBuffer) throws -> MuteList {
    return try FfiConverterTypeMuteList.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMuteList_lower(_ value: MuteList) -> RustBuffer {
    return FfiConverterTypeMuteList.lower(value)
}


/**
 * NIP47 Error message
 */
public struct Nip47Error {
    /**
     * Error Code
     */
    public var code: ErrorCode
    /**
     * Human Readable error message
     */
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Error Code
         */code: ErrorCode, 
        /**
         * Human Readable error message
         */message: String) {
        self.code = code
        self.message = message
    }
}

#if compiler(>=6)
extension Nip47Error: Sendable {}
#endif


extension Nip47Error: Equatable, Hashable {
    public static func ==(lhs: Nip47Error, rhs: Nip47Error) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(message)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNIP47Error: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip47Error {
        return
            try Nip47Error(
                code: FfiConverterTypeErrorCode.read(from: &buf), 
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Nip47Error, into buf: inout [UInt8]) {
        FfiConverterTypeErrorCode.write(value.code, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNIP47Error_lift(_ buf: RustBuffer) throws -> Nip47Error {
    return try FfiConverterTypeNIP47Error.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNIP47Error_lower(_ value: Nip47Error) -> RustBuffer {
    return FfiConverterTypeNIP47Error.lower(value)
}


public struct NegentropyItem {
    public var id: EventId
    public var timestamp: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: EventId, timestamp: Timestamp) {
        self.id = id
        self.timestamp = timestamp
    }
}

#if compiler(>=6)
extension NegentropyItem: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNegentropyItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NegentropyItem {
        return
            try NegentropyItem(
                id: FfiConverterTypeEventId.read(from: &buf), 
                timestamp: FfiConverterTypeTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: NegentropyItem, into buf: inout [UInt8]) {
        FfiConverterTypeEventId.write(value.id, into: &buf)
        FfiConverterTypeTimestamp.write(value.timestamp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNegentropyItem_lift(_ buf: RustBuffer) throws -> NegentropyItem {
    return try FfiConverterTypeNegentropyItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNegentropyItem_lower(_ value: NegentropyItem) -> RustBuffer {
    return FfiConverterTypeNegentropyItem.lower(value)
}


/**
 * Nostr parser options
 */
public struct NostrParserOptions {
    /**
     * Parse nostr URIs
     */
    public var nostrUris: Bool
    /**
     * Parse URLs
     */
    public var urls: Bool
    /**
     * Parse hashtags
     */
    public var hashtags: Bool
    /**
     * Parse text, line breaks and whitespaces
     */
    public var text: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Parse nostr URIs
         */nostrUris: Bool = true, 
        /**
         * Parse URLs
         */urls: Bool = true, 
        /**
         * Parse hashtags
         */hashtags: Bool = true, 
        /**
         * Parse text, line breaks and whitespaces
         */text: Bool = true) {
        self.nostrUris = nostrUris
        self.urls = urls
        self.hashtags = hashtags
        self.text = text
    }
}

#if compiler(>=6)
extension NostrParserOptions: Sendable {}
#endif


extension NostrParserOptions: Equatable, Hashable {
    public static func ==(lhs: NostrParserOptions, rhs: NostrParserOptions) -> Bool {
        if lhs.nostrUris != rhs.nostrUris {
            return false
        }
        if lhs.urls != rhs.urls {
            return false
        }
        if lhs.hashtags != rhs.hashtags {
            return false
        }
        if lhs.text != rhs.text {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nostrUris)
        hasher.combine(urls)
        hasher.combine(hashtags)
        hasher.combine(text)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNostrParserOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrParserOptions {
        return
            try NostrParserOptions(
                nostrUris: FfiConverterBool.read(from: &buf), 
                urls: FfiConverterBool.read(from: &buf), 
                hashtags: FfiConverterBool.read(from: &buf), 
                text: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: NostrParserOptions, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.nostrUris, into: &buf)
        FfiConverterBool.write(value.urls, into: &buf)
        FfiConverterBool.write(value.hashtags, into: &buf)
        FfiConverterBool.write(value.text, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrParserOptions_lift(_ buf: RustBuffer) throws -> NostrParserOptions {
    return try FfiConverterTypeNostrParserOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrParserOptions_lower(_ value: NostrParserOptions) -> RustBuffer {
    return FfiConverterTypeNostrParserOptions.lower(value)
}


/**
 * Output
 *
 * Send or negentropy reconciliation output
 */
public struct Output {
    /**
     * Set of relays that success
     */
    public var success: [RelayUrl]
    /**
     * Map of relays that failed, with related errors.
     */
    public var failed: [RelayUrl: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Set of relays that success
         */success: [RelayUrl], 
        /**
         * Map of relays that failed, with related errors.
         */failed: [RelayUrl: String]) {
        self.success = success
        self.failed = failed
    }
}

#if compiler(>=6)
extension Output: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Output {
        return
            try Output(
                success: FfiConverterSequenceTypeRelayUrl.read(from: &buf), 
                failed: FfiConverterDictionaryTypeRelayUrlString.read(from: &buf)
        )
    }

    public static func write(_ value: Output, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeRelayUrl.write(value.success, into: &buf)
        FfiConverterDictionaryTypeRelayUrlString.write(value.failed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutput_lift(_ buf: RustBuffer) throws -> Output {
    return try FfiConverterTypeOutput.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutput_lower(_ value: Output) -> RustBuffer {
    return FfiConverterTypeOutput.lower(value)
}


/**
 * Pay Invoice Request
 */
public struct PayInvoiceRequest {
    /**
     * Optional id
     */
    public var id: String?
    /**
     * Request invoice
     */
    public var invoice: String
    /**
     * Optional amount in millisatoshis
     */
    public var amount: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Optional id
         */id: String?, 
        /**
         * Request invoice
         */invoice: String, 
        /**
         * Optional amount in millisatoshis
         */amount: UInt64?) {
        self.id = id
        self.invoice = invoice
        self.amount = amount
    }
}

#if compiler(>=6)
extension PayInvoiceRequest: Sendable {}
#endif


extension PayInvoiceRequest: Equatable, Hashable {
    public static func ==(lhs: PayInvoiceRequest, rhs: PayInvoiceRequest) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(invoice)
        hasher.combine(amount)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePayInvoiceRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayInvoiceRequest {
        return
            try PayInvoiceRequest(
                id: FfiConverterOptionString.read(from: &buf), 
                invoice: FfiConverterString.read(from: &buf), 
                amount: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PayInvoiceRequest, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.id, into: &buf)
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterOptionUInt64.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayInvoiceRequest_lift(_ buf: RustBuffer) throws -> PayInvoiceRequest {
    return try FfiConverterTypePayInvoiceRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayInvoiceRequest_lower(_ value: PayInvoiceRequest) -> RustBuffer {
    return FfiConverterTypePayInvoiceRequest.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct PayInvoiceResponse {
    /**
     * Response preimage
     */
    public var preimage: String
    /**
     * Fees paid
     */
    public var feesPaid: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Response preimage
         */preimage: String, 
        /**
         * Fees paid
         */feesPaid: UInt64?) {
        self.preimage = preimage
        self.feesPaid = feesPaid
    }
}

#if compiler(>=6)
extension PayInvoiceResponse: Sendable {}
#endif


extension PayInvoiceResponse: Equatable, Hashable {
    public static func ==(lhs: PayInvoiceResponse, rhs: PayInvoiceResponse) -> Bool {
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.feesPaid != rhs.feesPaid {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(preimage)
        hasher.combine(feesPaid)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePayInvoiceResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayInvoiceResponse {
        return
            try PayInvoiceResponse(
                preimage: FfiConverterString.read(from: &buf), 
                feesPaid: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PayInvoiceResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.preimage, into: &buf)
        FfiConverterOptionUInt64.write(value.feesPaid, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayInvoiceResponse_lift(_ buf: RustBuffer) throws -> PayInvoiceResponse {
    return try FfiConverterTypePayInvoiceResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayInvoiceResponse_lower(_ value: PayInvoiceResponse) -> RustBuffer {
    return FfiConverterTypePayInvoiceResponse.lower(value)
}


/**
 * Pay Invoice Request
 */
public struct PayKeysendRequest {
    /**
     * Optional id
     */
    public var id: String?
    /**
     * Amount in millisatoshis
     */
    public var amount: UInt64
    /**
     * Receiver's node id
     */
    public var pubkey: String
    /**
     * Optional preimage
     */
    public var preimage: String?
    /**
     * Optional TLVs to be added to the keysend payment
     */
    public var tlvRecords: [KeysendTlvRecord]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Optional id
         */id: String?, 
        /**
         * Amount in millisatoshis
         */amount: UInt64, 
        /**
         * Receiver's node id
         */pubkey: String, 
        /**
         * Optional preimage
         */preimage: String?, 
        /**
         * Optional TLVs to be added to the keysend payment
         */tlvRecords: [KeysendTlvRecord]) {
        self.id = id
        self.amount = amount
        self.pubkey = pubkey
        self.preimage = preimage
        self.tlvRecords = tlvRecords
    }
}

#if compiler(>=6)
extension PayKeysendRequest: Sendable {}
#endif


extension PayKeysendRequest: Equatable, Hashable {
    public static func ==(lhs: PayKeysendRequest, rhs: PayKeysendRequest) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.tlvRecords != rhs.tlvRecords {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(amount)
        hasher.combine(pubkey)
        hasher.combine(preimage)
        hasher.combine(tlvRecords)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePayKeysendRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayKeysendRequest {
        return
            try PayKeysendRequest(
                id: FfiConverterOptionString.read(from: &buf), 
                amount: FfiConverterUInt64.read(from: &buf), 
                pubkey: FfiConverterString.read(from: &buf), 
                preimage: FfiConverterOptionString.read(from: &buf), 
                tlvRecords: FfiConverterSequenceTypeKeysendTLVRecord.read(from: &buf)
        )
    }

    public static func write(_ value: PayKeysendRequest, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.id, into: &buf)
        FfiConverterUInt64.write(value.amount, into: &buf)
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterOptionString.write(value.preimage, into: &buf)
        FfiConverterSequenceTypeKeysendTLVRecord.write(value.tlvRecords, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayKeysendRequest_lift(_ buf: RustBuffer) throws -> PayKeysendRequest {
    return try FfiConverterTypePayKeysendRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayKeysendRequest_lower(_ value: PayKeysendRequest) -> RustBuffer {
    return FfiConverterTypePayKeysendRequest.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct PayKeysendResponse {
    /**
     * Response preimage
     */
    public var preimage: String
    /**
     * Fees paid
     */
    public var feesPaid: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Response preimage
         */preimage: String, 
        /**
         * Fees paid
         */feesPaid: UInt64?) {
        self.preimage = preimage
        self.feesPaid = feesPaid
    }
}

#if compiler(>=6)
extension PayKeysendResponse: Sendable {}
#endif


extension PayKeysendResponse: Equatable, Hashable {
    public static func ==(lhs: PayKeysendResponse, rhs: PayKeysendResponse) -> Bool {
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.feesPaid != rhs.feesPaid {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(preimage)
        hasher.combine(feesPaid)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePayKeysendResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayKeysendResponse {
        return
            try PayKeysendResponse(
                preimage: FfiConverterString.read(from: &buf), 
                feesPaid: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PayKeysendResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.preimage, into: &buf)
        FfiConverterOptionUInt64.write(value.feesPaid, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayKeysendResponse_lift(_ buf: RustBuffer) throws -> PayKeysendResponse {
    return try FfiConverterTypePayKeysendResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayKeysendResponse_lower(_ value: PayKeysendResponse) -> RustBuffer {
    return FfiConverterTypePayKeysendResponse.lower(value)
}


public struct Person {
    public var publicKey: PublicKey
    public var relayUrl: RelayUrl?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: PublicKey, relayUrl: RelayUrl?) {
        self.publicKey = publicKey
        self.relayUrl = relayUrl
    }
}

#if compiler(>=6)
extension Person: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerson: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Person {
        return
            try Person(
                publicKey: FfiConverterTypePublicKey.read(from: &buf), 
                relayUrl: FfiConverterOptionTypeRelayUrl.read(from: &buf)
        )
    }

    public static func write(_ value: Person, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterOptionTypeRelayUrl.write(value.relayUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerson_lift(_ buf: RustBuffer) throws -> Person {
    return try FfiConverterTypePerson.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerson_lower(_ value: Person) -> RustBuffer {
    return FfiConverterTypePerson.lower(value)
}


public struct PollOption {
    /**
     * Option ID
     */
    public var id: String
    /**
     * Option label
     */
    public var text: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Option ID
         */id: String, 
        /**
         * Option label
         */text: String) {
        self.id = id
        self.text = text
    }
}

#if compiler(>=6)
extension PollOption: Sendable {}
#endif


extension PollOption: Equatable, Hashable {
    public static func ==(lhs: PollOption, rhs: PollOption) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.text != rhs.text {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(text)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePollOption: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PollOption {
        return
            try PollOption(
                id: FfiConverterString.read(from: &buf), 
                text: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PollOption, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.text, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePollOption_lift(_ buf: RustBuffer) throws -> PollOption {
    return try FfiConverterTypePollOption.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePollOption_lower(_ value: PollOption) -> RustBuffer {
    return FfiConverterTypePollOption.lower(value)
}


/**
 * Payload for creating or updating product
 */
public struct ProductData {
    /**
     * UUID of the product generated by merchant
     */
    public var id: String
    /**
     * Id of the stall that this product belongs to
     */
    public var stallId: String
    /**
     * Product name
     */
    public var name: String
    /**
     * Description of the product
     */
    public var description: String?
    /**
     * Image urls of the product
     */
    public var images: [String]?
    /**
     * Currency used
     */
    public var currency: String
    /**
     * Price of the product
     */
    public var price: Double
    /**
     * Available items
     */
    public var quantity: UInt64
    /**
     * Specifications of the product
     */
    public var specs: [[String]]?
    /**
     * Shipping method costs
     */
    public var shipping: [ShippingCost]
    /**
     * Categories of the product (will be added to tags)
     */
    public var categories: [String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * UUID of the product generated by merchant
         */id: String, 
        /**
         * Id of the stall that this product belongs to
         */stallId: String, 
        /**
         * Product name
         */name: String, 
        /**
         * Description of the product
         */description: String?, 
        /**
         * Image urls of the product
         */images: [String]?, 
        /**
         * Currency used
         */currency: String, 
        /**
         * Price of the product
         */price: Double, 
        /**
         * Available items
         */quantity: UInt64, 
        /**
         * Specifications of the product
         */specs: [[String]]?, 
        /**
         * Shipping method costs
         */shipping: [ShippingCost], 
        /**
         * Categories of the product (will be added to tags)
         */categories: [String]?) {
        self.id = id
        self.stallId = stallId
        self.name = name
        self.description = description
        self.images = images
        self.currency = currency
        self.price = price
        self.quantity = quantity
        self.specs = specs
        self.shipping = shipping
        self.categories = categories
    }
}

#if compiler(>=6)
extension ProductData: Sendable {}
#endif


extension ProductData: Equatable, Hashable {
    public static func ==(lhs: ProductData, rhs: ProductData) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.stallId != rhs.stallId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.images != rhs.images {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.price != rhs.price {
            return false
        }
        if lhs.quantity != rhs.quantity {
            return false
        }
        if lhs.specs != rhs.specs {
            return false
        }
        if lhs.shipping != rhs.shipping {
            return false
        }
        if lhs.categories != rhs.categories {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(stallId)
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(images)
        hasher.combine(currency)
        hasher.combine(price)
        hasher.combine(quantity)
        hasher.combine(specs)
        hasher.combine(shipping)
        hasher.combine(categories)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProductData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProductData {
        return
            try ProductData(
                id: FfiConverterString.read(from: &buf), 
                stallId: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                images: FfiConverterOptionSequenceString.read(from: &buf), 
                currency: FfiConverterString.read(from: &buf), 
                price: FfiConverterDouble.read(from: &buf), 
                quantity: FfiConverterUInt64.read(from: &buf), 
                specs: FfiConverterOptionSequenceSequenceString.read(from: &buf), 
                shipping: FfiConverterSequenceTypeShippingCost.read(from: &buf), 
                categories: FfiConverterOptionSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: ProductData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.stallId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionSequenceString.write(value.images, into: &buf)
        FfiConverterString.write(value.currency, into: &buf)
        FfiConverterDouble.write(value.price, into: &buf)
        FfiConverterUInt64.write(value.quantity, into: &buf)
        FfiConverterOptionSequenceSequenceString.write(value.specs, into: &buf)
        FfiConverterSequenceTypeShippingCost.write(value.shipping, into: &buf)
        FfiConverterOptionSequenceString.write(value.categories, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProductData_lift(_ buf: RustBuffer) throws -> ProductData {
    return try FfiConverterTypeProductData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProductData_lower(_ value: ProductData) -> RustBuffer {
    return FfiConverterTypeProductData.lower(value)
}


/**
 * Rate limit
 */
public struct RateLimit {
    /**
     * Max active REQs
     */
    public var maxReqs: UInt64
    /**
     * Max events per minutes
     */
    public var notesPerMinute: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Max active REQs
         */maxReqs: UInt64, 
        /**
         * Max events per minutes
         */notesPerMinute: UInt32) {
        self.maxReqs = maxReqs
        self.notesPerMinute = notesPerMinute
    }
}

#if compiler(>=6)
extension RateLimit: Sendable {}
#endif


extension RateLimit: Equatable, Hashable {
    public static func ==(lhs: RateLimit, rhs: RateLimit) -> Bool {
        if lhs.maxReqs != rhs.maxReqs {
            return false
        }
        if lhs.notesPerMinute != rhs.notesPerMinute {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxReqs)
        hasher.combine(notesPerMinute)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRateLimit: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RateLimit {
        return
            try RateLimit(
                maxReqs: FfiConverterUInt64.read(from: &buf), 
                notesPerMinute: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: RateLimit, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.maxReqs, into: &buf)
        FfiConverterUInt32.write(value.notesPerMinute, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRateLimit_lift(_ buf: RustBuffer) throws -> RateLimit {
    return try FfiConverterTypeRateLimit.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRateLimit_lower(_ value: RateLimit) -> RustBuffer {
    return FfiConverterTypeRateLimit.lower(value)
}


/**
 * Reconciliation output
 */
public struct Reconciliation {
    /**
     * The IDs that were stored locally
     */
    public var local: [EventId]
    /**
     * The IDs that were missing locally (stored on relay)
     */
    public var remote: [EventId]
    /**
     * Events that are **successfully** sent to relays during reconciliation
     */
    public var sent: [EventId]
    /**
     * Event that are **successfully** received from relay
     */
    public var received: [EventId]
    /**
     * Events that failed to send to relays during reconciliation
     */
    public var sendFailures: [RelayUrl: [ReconciliationSendFailureItem]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The IDs that were stored locally
         */local: [EventId], 
        /**
         * The IDs that were missing locally (stored on relay)
         */remote: [EventId], 
        /**
         * Events that are **successfully** sent to relays during reconciliation
         */sent: [EventId], 
        /**
         * Event that are **successfully** received from relay
         */received: [EventId], 
        /**
         * Events that failed to send to relays during reconciliation
         */sendFailures: [RelayUrl: [ReconciliationSendFailureItem]]) {
        self.local = local
        self.remote = remote
        self.sent = sent
        self.received = received
        self.sendFailures = sendFailures
    }
}

#if compiler(>=6)
extension Reconciliation: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReconciliation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Reconciliation {
        return
            try Reconciliation(
                local: FfiConverterSequenceTypeEventId.read(from: &buf), 
                remote: FfiConverterSequenceTypeEventId.read(from: &buf), 
                sent: FfiConverterSequenceTypeEventId.read(from: &buf), 
                received: FfiConverterSequenceTypeEventId.read(from: &buf), 
                sendFailures: FfiConverterDictionaryTypeRelayUrlSequenceTypeReconciliationSendFailureItem.read(from: &buf)
        )
    }

    public static func write(_ value: Reconciliation, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeEventId.write(value.local, into: &buf)
        FfiConverterSequenceTypeEventId.write(value.remote, into: &buf)
        FfiConverterSequenceTypeEventId.write(value.sent, into: &buf)
        FfiConverterSequenceTypeEventId.write(value.received, into: &buf)
        FfiConverterDictionaryTypeRelayUrlSequenceTypeReconciliationSendFailureItem.write(value.sendFailures, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReconciliation_lift(_ buf: RustBuffer) throws -> Reconciliation {
    return try FfiConverterTypeReconciliation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReconciliation_lower(_ value: Reconciliation) -> RustBuffer {
    return FfiConverterTypeReconciliation.lower(value)
}


/**
 * Reconciliation output
 */
public struct ReconciliationOutput {
    /**
     * Reconciliation report
     */
    public var report: Reconciliation
    /**
     * Set of relays that success
     */
    public var success: [RelayUrl]
    /**
     * Map of relays that failed, with related errors.
     */
    public var failed: [RelayUrl: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Reconciliation report
         */report: Reconciliation, 
        /**
         * Set of relays that success
         */success: [RelayUrl], 
        /**
         * Map of relays that failed, with related errors.
         */failed: [RelayUrl: String]) {
        self.report = report
        self.success = success
        self.failed = failed
    }
}

#if compiler(>=6)
extension ReconciliationOutput: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReconciliationOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReconciliationOutput {
        return
            try ReconciliationOutput(
                report: FfiConverterTypeReconciliation.read(from: &buf), 
                success: FfiConverterSequenceTypeRelayUrl.read(from: &buf), 
                failed: FfiConverterDictionaryTypeRelayUrlString.read(from: &buf)
        )
    }

    public static func write(_ value: ReconciliationOutput, into buf: inout [UInt8]) {
        FfiConverterTypeReconciliation.write(value.report, into: &buf)
        FfiConverterSequenceTypeRelayUrl.write(value.success, into: &buf)
        FfiConverterDictionaryTypeRelayUrlString.write(value.failed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReconciliationOutput_lift(_ buf: RustBuffer) throws -> ReconciliationOutput {
    return try FfiConverterTypeReconciliationOutput.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReconciliationOutput_lower(_ value: ReconciliationOutput) -> RustBuffer {
    return FfiConverterTypeReconciliationOutput.lower(value)
}


public struct ReconciliationSendFailureItem {
    public var id: EventId
    public var error: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: EventId, error: String) {
        self.id = id
        self.error = error
    }
}

#if compiler(>=6)
extension ReconciliationSendFailureItem: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReconciliationSendFailureItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReconciliationSendFailureItem {
        return
            try ReconciliationSendFailureItem(
                id: FfiConverterTypeEventId.read(from: &buf), 
                error: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ReconciliationSendFailureItem, into buf: inout [UInt8]) {
        FfiConverterTypeEventId.write(value.id, into: &buf)
        FfiConverterString.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReconciliationSendFailureItem_lift(_ buf: RustBuffer) throws -> ReconciliationSendFailureItem {
    return try FfiConverterTypeReconciliationSendFailureItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReconciliationSendFailureItem_lower(_ value: ReconciliationSendFailureItem) -> RustBuffer {
    return FfiConverterTypeReconciliationSendFailureItem.lower(value)
}


/**
 * NIP42 options
 */
public struct RelayBuilderNip42 {
    /**
     * Mode
     */
    public var mode: RelayBuilderNip42Mode

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Mode
         */mode: RelayBuilderNip42Mode) {
        self.mode = mode
    }
}

#if compiler(>=6)
extension RelayBuilderNip42: Sendable {}
#endif


extension RelayBuilderNip42: Equatable, Hashable {
    public static func ==(lhs: RelayBuilderNip42, rhs: RelayBuilderNip42) -> Bool {
        if lhs.mode != rhs.mode {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mode)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRelayBuilderNip42: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayBuilderNip42 {
        return
            try RelayBuilderNip42(
                mode: FfiConverterTypeRelayBuilderNip42Mode.read(from: &buf)
        )
    }

    public static func write(_ value: RelayBuilderNip42, into buf: inout [UInt8]) {
        FfiConverterTypeRelayBuilderNip42Mode.write(value.mode, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayBuilderNip42_lift(_ buf: RustBuffer) throws -> RelayBuilderNip42 {
    return try FfiConverterTypeRelayBuilderNip42.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayBuilderNip42_lower(_ value: RelayBuilderNip42) -> RustBuffer {
    return FfiConverterTypeRelayBuilderNip42.lower(value)
}


/**
 * A retention schedule for the relay
 */
public struct Retention {
    /**
     * The event kinds this retention pertains to
     */
    public var kinds: [RetentionKind]?
    /**
     * The amount of time these events are kept
     */
    public var time: UInt64?
    /**
     * The max number of events kept before removing older events
     */
    public var count: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The event kinds this retention pertains to
         */kinds: [RetentionKind]?, 
        /**
         * The amount of time these events are kept
         */time: UInt64?, 
        /**
         * The max number of events kept before removing older events
         */count: UInt64?) {
        self.kinds = kinds
        self.time = time
        self.count = count
    }
}

#if compiler(>=6)
extension Retention: Sendable {}
#endif


extension Retention: Equatable, Hashable {
    public static func ==(lhs: Retention, rhs: Retention) -> Bool {
        if lhs.kinds != rhs.kinds {
            return false
        }
        if lhs.time != rhs.time {
            return false
        }
        if lhs.count != rhs.count {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kinds)
        hasher.combine(time)
        hasher.combine(count)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRetention: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Retention {
        return
            try Retention(
                kinds: FfiConverterOptionSequenceTypeRetentionKind.read(from: &buf), 
                time: FfiConverterOptionUInt64.read(from: &buf), 
                count: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Retention, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypeRetentionKind.write(value.kinds, into: &buf)
        FfiConverterOptionUInt64.write(value.time, into: &buf)
        FfiConverterOptionUInt64.write(value.count, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRetention_lift(_ buf: RustBuffer) throws -> Retention {
    return try FfiConverterTypeRetention.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRetention_lower(_ value: Retention) -> RustBuffer {
    return FfiConverterTypeRetention.lower(value)
}


/**
 * Send event output
 */
public struct SendEventOutput {
    /**
     * Event ID
     */
    public var id: EventId
    /**
     * Set of relays that success
     */
    public var success: [RelayUrl]
    /**
     * Map of relays that failed, with related errors.
     */
    public var failed: [RelayUrl: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Event ID
         */id: EventId, 
        /**
         * Set of relays that success
         */success: [RelayUrl], 
        /**
         * Map of relays that failed, with related errors.
         */failed: [RelayUrl: String]) {
        self.id = id
        self.success = success
        self.failed = failed
    }
}

#if compiler(>=6)
extension SendEventOutput: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendEventOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendEventOutput {
        return
            try SendEventOutput(
                id: FfiConverterTypeEventId.read(from: &buf), 
                success: FfiConverterSequenceTypeRelayUrl.read(from: &buf), 
                failed: FfiConverterDictionaryTypeRelayUrlString.read(from: &buf)
        )
    }

    public static func write(_ value: SendEventOutput, into buf: inout [UInt8]) {
        FfiConverterTypeEventId.write(value.id, into: &buf)
        FfiConverterSequenceTypeRelayUrl.write(value.success, into: &buf)
        FfiConverterDictionaryTypeRelayUrlString.write(value.failed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendEventOutput_lift(_ buf: RustBuffer) throws -> SendEventOutput {
    return try FfiConverterTypeSendEventOutput.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendEventOutput_lower(_ value: SendEventOutput) -> RustBuffer {
    return FfiConverterTypeSendEventOutput.lower(value)
}


/**
 * Settle Hold Invoice Request
 */
public struct SettleHoldInvoiceRequest {
    /**
     * preimage
     */
    public var preimage: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * preimage
         */preimage: String) {
        self.preimage = preimage
    }
}

#if compiler(>=6)
extension SettleHoldInvoiceRequest: Sendable {}
#endif


extension SettleHoldInvoiceRequest: Equatable, Hashable {
    public static func ==(lhs: SettleHoldInvoiceRequest, rhs: SettleHoldInvoiceRequest) -> Bool {
        if lhs.preimage != rhs.preimage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(preimage)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSettleHoldInvoiceRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SettleHoldInvoiceRequest {
        return
            try SettleHoldInvoiceRequest(
                preimage: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SettleHoldInvoiceRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.preimage, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSettleHoldInvoiceRequest_lift(_ buf: RustBuffer) throws -> SettleHoldInvoiceRequest {
    return try FfiConverterTypeSettleHoldInvoiceRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSettleHoldInvoiceRequest_lower(_ value: SettleHoldInvoiceRequest) -> RustBuffer {
    return FfiConverterTypeSettleHoldInvoiceRequest.lower(value)
}


/**
 * Settle Hold Invoice Response
 */
public struct SettleHoldInvoiceResponse {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}

#if compiler(>=6)
extension SettleHoldInvoiceResponse: Sendable {}
#endif


extension SettleHoldInvoiceResponse: Equatable, Hashable {
    public static func ==(lhs: SettleHoldInvoiceResponse, rhs: SettleHoldInvoiceResponse) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSettleHoldInvoiceResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SettleHoldInvoiceResponse {
        return
            SettleHoldInvoiceResponse()
    }

    public static func write(_ value: SettleHoldInvoiceResponse, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSettleHoldInvoiceResponse_lift(_ buf: RustBuffer) throws -> SettleHoldInvoiceResponse {
    return try FfiConverterTypeSettleHoldInvoiceResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSettleHoldInvoiceResponse_lower(_ value: SettleHoldInvoiceResponse) -> RustBuffer {
    return FfiConverterTypeSettleHoldInvoiceResponse.lower(value)
}


/**
 * Delivery cost for shipping method as defined by the merchant in the product
 */
public struct ShippingCost {
    /**
     * Id of the shipping method
     */
    public var id: String
    /**
     * Cost to use this shipping method
     */
    public var cost: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Id of the shipping method
         */id: String, 
        /**
         * Cost to use this shipping method
         */cost: Double) {
        self.id = id
        self.cost = cost
    }
}

#if compiler(>=6)
extension ShippingCost: Sendable {}
#endif


extension ShippingCost: Equatable, Hashable {
    public static func ==(lhs: ShippingCost, rhs: ShippingCost) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.cost != rhs.cost {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(cost)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeShippingCost: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShippingCost {
        return
            try ShippingCost(
                id: FfiConverterString.read(from: &buf), 
                cost: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: ShippingCost, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterDouble.write(value.cost, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShippingCost_lift(_ buf: RustBuffer) throws -> ShippingCost {
    return try FfiConverterTypeShippingCost.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShippingCost_lower(_ value: ShippingCost) -> RustBuffer {
    return FfiConverterTypeShippingCost.lower(value)
}


public struct ShippingMethodRecord {
    /**
     * Shipping method unique id by merchant
     */
    public var id: String
    /**
     * Shipping method name
     */
    public var name: String?
    /**
     * Shipping method cost (currency is the same as the stall)
     */
    public var cost: Double
    /**
     * Covered regions
     */
    public var regions: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Shipping method unique id by merchant
         */id: String, 
        /**
         * Shipping method name
         */name: String?, 
        /**
         * Shipping method cost (currency is the same as the stall)
         */cost: Double, 
        /**
         * Covered regions
         */regions: [String]) {
        self.id = id
        self.name = name
        self.cost = cost
        self.regions = regions
    }
}

#if compiler(>=6)
extension ShippingMethodRecord: Sendable {}
#endif


extension ShippingMethodRecord: Equatable, Hashable {
    public static func ==(lhs: ShippingMethodRecord, rhs: ShippingMethodRecord) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.cost != rhs.cost {
            return false
        }
        if lhs.regions != rhs.regions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(cost)
        hasher.combine(regions)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeShippingMethodRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShippingMethodRecord {
        return
            try ShippingMethodRecord(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                cost: FfiConverterDouble.read(from: &buf), 
                regions: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: ShippingMethodRecord, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterDouble.write(value.cost, into: &buf)
        FfiConverterSequenceString.write(value.regions, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShippingMethodRecord_lift(_ buf: RustBuffer) throws -> ShippingMethodRecord {
    return try FfiConverterTypeShippingMethodRecord.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShippingMethodRecord_lower(_ value: ShippingMethodRecord) -> RustBuffer {
    return FfiConverterTypeShippingMethodRecord.lower(value)
}


/**
 * Payload for creating or updating stall
 */
public struct StallDataRecord {
    /**
     * UUID of the stall generated by merchant
     */
    public var id: String
    /**
     * Stall name
     */
    public var name: String
    /**
     * Stall description
     */
    public var description: String?
    /**
     * Currency used
     */
    public var currency: String
    /**
     * Available shipping methods
     */
    public var shipping: [ShippingMethodRecord]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * UUID of the stall generated by merchant
         */id: String, 
        /**
         * Stall name
         */name: String, 
        /**
         * Stall description
         */description: String?, 
        /**
         * Currency used
         */currency: String, 
        /**
         * Available shipping methods
         */shipping: [ShippingMethodRecord]) {
        self.id = id
        self.name = name
        self.description = description
        self.currency = currency
        self.shipping = shipping
    }
}

#if compiler(>=6)
extension StallDataRecord: Sendable {}
#endif


extension StallDataRecord: Equatable, Hashable {
    public static func ==(lhs: StallDataRecord, rhs: StallDataRecord) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.shipping != rhs.shipping {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(currency)
        hasher.combine(shipping)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStallDataRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StallDataRecord {
        return
            try StallDataRecord(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                currency: FfiConverterString.read(from: &buf), 
                shipping: FfiConverterSequenceTypeShippingMethodRecord.read(from: &buf)
        )
    }

    public static func write(_ value: StallDataRecord, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterString.write(value.currency, into: &buf)
        FfiConverterSequenceTypeShippingMethodRecord.write(value.shipping, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStallDataRecord_lift(_ buf: RustBuffer) throws -> StallDataRecord {
    return try FfiConverterTypeStallDataRecord.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStallDataRecord_lower(_ value: StallDataRecord) -> RustBuffer {
    return FfiConverterTypeStallDataRecord.lower(value)
}


/**
 * Subscribe output
 */
public struct SubscribeOutput {
    /**
     * Subscription ID
     */
    public var id: String
    /**
     * Set of relays that success
     */
    public var success: [RelayUrl]
    /**
     * Map of relays that failed, with related errors.
     */
    public var failed: [RelayUrl: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Subscription ID
         */id: String, 
        /**
         * Set of relays that success
         */success: [RelayUrl], 
        /**
         * Map of relays that failed, with related errors.
         */failed: [RelayUrl: String]) {
        self.id = id
        self.success = success
        self.failed = failed
    }
}

#if compiler(>=6)
extension SubscribeOutput: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSubscribeOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubscribeOutput {
        return
            try SubscribeOutput(
                id: FfiConverterString.read(from: &buf), 
                success: FfiConverterSequenceTypeRelayUrl.read(from: &buf), 
                failed: FfiConverterDictionaryTypeRelayUrlString.read(from: &buf)
        )
    }

    public static func write(_ value: SubscribeOutput, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterSequenceTypeRelayUrl.write(value.success, into: &buf)
        FfiConverterDictionaryTypeRelayUrlString.write(value.failed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubscribeOutput_lift(_ buf: RustBuffer) throws -> SubscribeOutput {
    return try FfiConverterTypeSubscribeOutput.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubscribeOutput_lower(_ value: SubscribeOutput) -> RustBuffer {
    return FfiConverterTypeSubscribeOutput.lower(value)
}


public struct TagClientAddress {
    /**
     * Coordinate
     */
    public var coordinate: Coordinate
    /**
     * Relay hint
     */
    public var hint: RelayUrl?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Coordinate
         */coordinate: Coordinate, 
        /**
         * Relay hint
         */hint: RelayUrl?) {
        self.coordinate = coordinate
        self.hint = hint
    }
}

#if compiler(>=6)
extension TagClientAddress: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTagClientAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TagClientAddress {
        return
            try TagClientAddress(
                coordinate: FfiConverterTypeCoordinate.read(from: &buf), 
                hint: FfiConverterOptionTypeRelayUrl.read(from: &buf)
        )
    }

    public static func write(_ value: TagClientAddress, into buf: inout [UInt8]) {
        FfiConverterTypeCoordinate.write(value.coordinate, into: &buf)
        FfiConverterOptionTypeRelayUrl.write(value.hint, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTagClientAddress_lift(_ buf: RustBuffer) throws -> TagClientAddress {
    return try FfiConverterTypeTagClientAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTagClientAddress_lower(_ value: TagClientAddress) -> RustBuffer {
    return FfiConverterTypeTagClientAddress.lower(value)
}


public struct WebSocketCloseFrame {
    public var code: UInt16
    public var reason: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(code: UInt16, reason: String) {
        self.code = code
        self.reason = reason
    }
}

#if compiler(>=6)
extension WebSocketCloseFrame: Sendable {}
#endif


extension WebSocketCloseFrame: Equatable, Hashable {
    public static func ==(lhs: WebSocketCloseFrame, rhs: WebSocketCloseFrame) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(reason)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWebSocketCloseFrame: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WebSocketCloseFrame {
        return
            try WebSocketCloseFrame(
                code: FfiConverterUInt16.read(from: &buf), 
                reason: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: WebSocketCloseFrame, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.code, into: &buf)
        FfiConverterString.write(value.reason, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWebSocketCloseFrame_lift(_ buf: RustBuffer) throws -> WebSocketCloseFrame {
    return try FfiConverterTypeWebSocketCloseFrame.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWebSocketCloseFrame_lower(_ value: WebSocketCloseFrame) -> RustBuffer {
    return FfiConverterTypeWebSocketCloseFrame.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Alphabet {
    
    case a
    case b
    case c
    case d
    case e
    case f
    case g
    case h
    case i
    case j
    case k
    case l
    case m
    case n
    case o
    case p
    case q
    case r
    case s
    case t
    case u
    case v
    case w
    case x
    case y
    case z
}


#if compiler(>=6)
extension Alphabet: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAlphabet: FfiConverterRustBuffer {
    typealias SwiftType = Alphabet

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Alphabet {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .a
        
        case 2: return .b
        
        case 3: return .c
        
        case 4: return .d
        
        case 5: return .e
        
        case 6: return .f
        
        case 7: return .g
        
        case 8: return .h
        
        case 9: return .i
        
        case 10: return .j
        
        case 11: return .k
        
        case 12: return .l
        
        case 13: return .m
        
        case 14: return .n
        
        case 15: return .o
        
        case 16: return .p
        
        case 17: return .q
        
        case 18: return .r
        
        case 19: return .s
        
        case 20: return .t
        
        case 21: return .u
        
        case 22: return .v
        
        case 23: return .w
        
        case 24: return .x
        
        case 25: return .y
        
        case 26: return .z
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Alphabet, into buf: inout [UInt8]) {
        switch value {
        
        
        case .a:
            writeInt(&buf, Int32(1))
        
        
        case .b:
            writeInt(&buf, Int32(2))
        
        
        case .c:
            writeInt(&buf, Int32(3))
        
        
        case .d:
            writeInt(&buf, Int32(4))
        
        
        case .e:
            writeInt(&buf, Int32(5))
        
        
        case .f:
            writeInt(&buf, Int32(6))
        
        
        case .g:
            writeInt(&buf, Int32(7))
        
        
        case .h:
            writeInt(&buf, Int32(8))
        
        
        case .i:
            writeInt(&buf, Int32(9))
        
        
        case .j:
            writeInt(&buf, Int32(10))
        
        
        case .k:
            writeInt(&buf, Int32(11))
        
        
        case .l:
            writeInt(&buf, Int32(12))
        
        
        case .m:
            writeInt(&buf, Int32(13))
        
        
        case .n:
            writeInt(&buf, Int32(14))
        
        
        case .o:
            writeInt(&buf, Int32(15))
        
        
        case .p:
            writeInt(&buf, Int32(16))
        
        
        case .q:
            writeInt(&buf, Int32(17))
        
        
        case .r:
            writeInt(&buf, Int32(18))
        
        
        case .s:
            writeInt(&buf, Int32(19))
        
        
        case .t:
            writeInt(&buf, Int32(20))
        
        
        case .u:
            writeInt(&buf, Int32(21))
        
        
        case .v:
            writeInt(&buf, Int32(22))
        
        
        case .w:
            writeInt(&buf, Int32(23))
        
        
        case .x:
            writeInt(&buf, Int32(24))
        
        
        case .y:
            writeInt(&buf, Int32(25))
        
        
        case .z:
            writeInt(&buf, Int32(26))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAlphabet_lift(_ buf: RustBuffer) throws -> Alphabet {
    return try FfiConverterTypeAlphabet.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAlphabet_lower(_ value: Alphabet) -> RustBuffer {
    return FfiConverterTypeAlphabet.lower(value)
}


extension Alphabet: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Messages sent by clients, received by relays
 */

public enum ClientMessageEnum {
    
    case eventMsg(event: Event
    )
    case req(subscriptionId: String, filters: [Filter]
    )
    case count(subscriptionId: String, filter: Filter
    )
    case close(subscriptionId: String
    )
    case auth(event: Event
    )
    /**
     * Negentropy Open
     */
    case negOpen(subscriptionId: String, filter: Filter, 
        /**
         * ID size (deprecated)
         */idSize: UInt8?, initialMessage: String
    )
    /**
     * Negentropy Message
     */
    case negMsg(subscriptionId: String, message: String
    )
    /**
     * Negentropy Close
     */
    case negClose(subscriptionId: String
    )
}


#if compiler(>=6)
extension ClientMessageEnum: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientMessageEnum: FfiConverterRustBuffer {
    typealias SwiftType = ClientMessageEnum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientMessageEnum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventMsg(event: try FfiConverterTypeEvent.read(from: &buf)
        )
        
        case 2: return .req(subscriptionId: try FfiConverterString.read(from: &buf), filters: try FfiConverterSequenceTypeFilter.read(from: &buf)
        )
        
        case 3: return .count(subscriptionId: try FfiConverterString.read(from: &buf), filter: try FfiConverterTypeFilter.read(from: &buf)
        )
        
        case 4: return .close(subscriptionId: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .auth(event: try FfiConverterTypeEvent.read(from: &buf)
        )
        
        case 6: return .negOpen(subscriptionId: try FfiConverterString.read(from: &buf), filter: try FfiConverterTypeFilter.read(from: &buf), idSize: try FfiConverterOptionUInt8.read(from: &buf), initialMessage: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .negMsg(subscriptionId: try FfiConverterString.read(from: &buf), message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .negClose(subscriptionId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientMessageEnum, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .eventMsg(event):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEvent.write(event, into: &buf)
            
        
        case let .req(subscriptionId,filters):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterSequenceTypeFilter.write(filters, into: &buf)
            
        
        case let .count(subscriptionId,filter):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterTypeFilter.write(filter, into: &buf)
            
        
        case let .close(subscriptionId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(subscriptionId, into: &buf)
            
        
        case let .auth(event):
            writeInt(&buf, Int32(5))
            FfiConverterTypeEvent.write(event, into: &buf)
            
        
        case let .negOpen(subscriptionId,filter,idSize,initialMessage):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterTypeFilter.write(filter, into: &buf)
            FfiConverterOptionUInt8.write(idSize, into: &buf)
            FfiConverterString.write(initialMessage, into: &buf)
            
        
        case let .negMsg(subscriptionId,message):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .negClose(subscriptionId):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(subscriptionId, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientMessageEnum_lift(_ buf: RustBuffer) throws -> ClientMessageEnum {
    return try FfiConverterTypeClientMessageEnum.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientMessageEnum_lower(_ value: ClientMessageEnum) -> RustBuffer {
    return FfiConverterTypeClientMessageEnum.lower(value)
}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Comment target
 *
 * <https://github.com/nostr-protocol/nips/blob/master/22.md>
 */

public enum CommentTarget {
    
    /**
     * Event
     */
    case event(
        /**
         * Event ID
         */id: EventId, 
        /**
         * Relay hint
         */relayHint: RelayUrl?, 
        /**
         * Public key hint
         */pubkeyHint: PublicKey?, 
        /**
         * Kind
         */kind: Kind?
    )
    /**
     * Coordinate
     */
    case address(
        /**
         * Coordinate
         */address: Coordinate, 
        /**
         * Relay hint
         */relayHint: RelayUrl?
    )
    /**
     * External content
     */
    case external(
        /**
         * Content
         */content: ExternalContentId, 
        /**
         * Web hint
         */hint: String?
    )
}


#if compiler(>=6)
extension CommentTarget: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCommentTarget: FfiConverterRustBuffer {
    typealias SwiftType = CommentTarget

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CommentTarget {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .event(id: try FfiConverterTypeEventId.read(from: &buf), relayHint: try FfiConverterOptionTypeRelayUrl.read(from: &buf), pubkeyHint: try FfiConverterOptionTypePublicKey.read(from: &buf), kind: try FfiConverterOptionTypeKind.read(from: &buf)
        )
        
        case 2: return .address(address: try FfiConverterTypeCoordinate.read(from: &buf), relayHint: try FfiConverterOptionTypeRelayUrl.read(from: &buf)
        )
        
        case 3: return .external(content: try FfiConverterTypeExternalContentId.read(from: &buf), hint: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CommentTarget, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .event(id,relayHint,pubkeyHint,kind):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEventId.write(id, into: &buf)
            FfiConverterOptionTypeRelayUrl.write(relayHint, into: &buf)
            FfiConverterOptionTypePublicKey.write(pubkeyHint, into: &buf)
            FfiConverterOptionTypeKind.write(kind, into: &buf)
            
        
        case let .address(address,relayHint):
            writeInt(&buf, Int32(2))
            FfiConverterTypeCoordinate.write(address, into: &buf)
            FfiConverterOptionTypeRelayUrl.write(relayHint, into: &buf)
            
        
        case let .external(content,hint):
            writeInt(&buf, Int32(3))
            FfiConverterTypeExternalContentId.write(content, into: &buf)
            FfiConverterOptionString.write(hint, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCommentTarget_lift(_ buf: RustBuffer) throws -> CommentTarget {
    return try FfiConverterTypeCommentTarget.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCommentTarget_lower(_ value: CommentTarget) -> RustBuffer {
    return FfiConverterTypeCommentTarget.lower(value)
}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ConnectionMode {
    
    case direct
    case proxy(
        /**
         * IP
         */ip: String, 
        /**
         * Port
         */port: UInt16
    )
}


#if compiler(>=6)
extension ConnectionMode: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnectionMode: FfiConverterRustBuffer {
    typealias SwiftType = ConnectionMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectionMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .direct
        
        case 2: return .proxy(ip: try FfiConverterString.read(from: &buf), port: try FfiConverterUInt16.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConnectionMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .direct:
            writeInt(&buf, Int32(1))
        
        
        case let .proxy(ip,port):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(ip, into: &buf)
            FfiConverterUInt16.write(port, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectionMode_lift(_ buf: RustBuffer) throws -> ConnectionMode {
    return try FfiConverterTypeConnectionMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectionMode_lower(_ value: ConnectionMode) -> RustBuffer {
    return FfiConverterTypeConnectionMode.lower(value)
}


extension ConnectionMode: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Connection target
 */

public enum ConnectionTarget {
    
    /**
     * Use proxy for all relays
     */
    case all
    /**
     * Use proxy only for `.onion` relays
     */
    case onion
}


#if compiler(>=6)
extension ConnectionTarget: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnectionTarget: FfiConverterRustBuffer {
    typealias SwiftType = ConnectionTarget

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectionTarget {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .all
        
        case 2: return .onion
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConnectionTarget, into buf: inout [UInt8]) {
        switch value {
        
        
        case .all:
            writeInt(&buf, Int32(1))
        
        
        case .onion:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectionTarget_lift(_ buf: RustBuffer) throws -> ConnectionTarget {
    return try FfiConverterTypeConnectionTarget.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectionTarget_lower(_ value: ConnectionTarget) -> RustBuffer {
    return FfiConverterTypeConnectionTarget.lower(value)
}


extension ConnectionTarget: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DataVendingMachineStatus {
    
    case paymentRequired
    case processing
    case error
    case success
    case partial
}


#if compiler(>=6)
extension DataVendingMachineStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDataVendingMachineStatus: FfiConverterRustBuffer {
    typealias SwiftType = DataVendingMachineStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DataVendingMachineStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .paymentRequired
        
        case 2: return .processing
        
        case 3: return .error
        
        case 4: return .success
        
        case 5: return .partial
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DataVendingMachineStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .paymentRequired:
            writeInt(&buf, Int32(1))
        
        
        case .processing:
            writeInt(&buf, Int32(2))
        
        
        case .error:
            writeInt(&buf, Int32(3))
        
        
        case .success:
            writeInt(&buf, Int32(4))
        
        
        case .partial:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataVendingMachineStatus_lift(_ buf: RustBuffer) throws -> DataVendingMachineStatus {
    return try FfiConverterTypeDataVendingMachineStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDataVendingMachineStatus_lower(_ value: DataVendingMachineStatus) -> RustBuffer {
    return FfiConverterTypeDataVendingMachineStatus.lower(value)
}


extension DataVendingMachineStatus: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DatabaseEventStatus {
    
    case saved
    case deleted
    case notExistent
}


#if compiler(>=6)
extension DatabaseEventStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDatabaseEventStatus: FfiConverterRustBuffer {
    typealias SwiftType = DatabaseEventStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DatabaseEventStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .saved
        
        case 2: return .deleted
        
        case 3: return .notExistent
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DatabaseEventStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .saved:
            writeInt(&buf, Int32(1))
        
        
        case .deleted:
            writeInt(&buf, Int32(2))
        
        
        case .notExistent:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDatabaseEventStatus_lift(_ buf: RustBuffer) throws -> DatabaseEventStatus {
    return try FfiConverterTypeDatabaseEventStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDatabaseEventStatus_lower(_ value: DatabaseEventStatus) -> RustBuffer {
    return FfiConverterTypeDatabaseEventStatus.lower(value)
}


extension DatabaseEventStatus: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Encrypted Secret Key version (NIP49)
 */

public enum EncryptedSecretKeyVersion {
    
    case v2
}


#if compiler(>=6)
extension EncryptedSecretKeyVersion: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEncryptedSecretKeyVersion: FfiConverterRustBuffer {
    typealias SwiftType = EncryptedSecretKeyVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedSecretKeyVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .v2
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EncryptedSecretKeyVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .v2:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryptedSecretKeyVersion_lift(_ buf: RustBuffer) throws -> EncryptedSecretKeyVersion {
    return try FfiConverterTypeEncryptedSecretKeyVersion.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryptedSecretKeyVersion_lower(_ value: EncryptedSecretKeyVersion) -> RustBuffer {
    return FfiConverterTypeEncryptedSecretKeyVersion.lower(value)
}


extension EncryptedSecretKeyVersion: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * NIP47 Response Error codes
 */

public enum ErrorCode {
    
    /**
     * The client is sending commands too fast.
     */
    case rateLimited
    /**
     * The command is not known of is intentionally not implemented
     */
    case notImplemented
    /**
     * The wallet does not have enough funds to cover a fee reserve or the payment amount
     */
    case insufficientBalance
    /**
     * The payment failed. This may be due to a timeout, exhausting all routes, insufficient capacity or similar.
     */
    case paymentFailed
    /**
     * The invoice could not be found by the given parameters.
     */
    case notFound
    /**
     * The wallet has exceeded its spending quota
     */
    case quotaExceeded
    /**
     * This public key is not allowed to do this operation
     */
    case restricted
    /**
     * This public key has no wallet connected
     */
    case unauthorized
    /**
     * An internal error
     */
    case `internal`
    /**
     * Other error
     */
    case other
}


#if compiler(>=6)
extension ErrorCode: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = ErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .rateLimited
        
        case 2: return .notImplemented
        
        case 3: return .insufficientBalance
        
        case 4: return .paymentFailed
        
        case 5: return .notFound
        
        case 6: return .quotaExceeded
        
        case 7: return .restricted
        
        case 8: return .unauthorized
        
        case 9: return .`internal`
        
        case 10: return .other
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ErrorCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .rateLimited:
            writeInt(&buf, Int32(1))
        
        
        case .notImplemented:
            writeInt(&buf, Int32(2))
        
        
        case .insufficientBalance:
            writeInt(&buf, Int32(3))
        
        
        case .paymentFailed:
            writeInt(&buf, Int32(4))
        
        
        case .notFound:
            writeInt(&buf, Int32(5))
        
        
        case .quotaExceeded:
            writeInt(&buf, Int32(6))
        
        
        case .restricted:
            writeInt(&buf, Int32(7))
        
        
        case .unauthorized:
            writeInt(&buf, Int32(8))
        
        
        case .`internal`:
            writeInt(&buf, Int32(9))
        
        
        case .other:
            writeInt(&buf, Int32(10))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeErrorCode_lift(_ buf: RustBuffer) throws -> ErrorCode {
    return try FfiConverterTypeErrorCode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeErrorCode_lower(_ value: ErrorCode) -> RustBuffer {
    return FfiConverterTypeErrorCode.lower(value)
}


extension ErrorCode: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * External Content ID
 */

public enum ExternalContentId {
    
    /**
     * URL
     */
    case url(String
    )
    /**
     * Hashtag
     */
    case hashtag(String
    )
    /**
     * Geohash
     */
    case geohash(String
    )
    /**
     * Book
     */
    case book(String
    )
    /**
     * Podcast Feed
     */
    case podcastFeed(String
    )
    /**
     * Podcast Episode
     */
    case podcastEpisode(String
    )
    /**
     * Podcast Publisher
     */
    case podcastPublisher(String
    )
    /**
     * Movie
     */
    case movie(String
    )
    /**
     * Paper
     */
    case paper(String
    )
    /**
     * Blockchain Transaction
     */
    case blockchainTransaction(
        /**
         * The blockchain name (e.g., "bitcoin", "ethereum")
         */chain: String, 
        /**
         * A lower case hex transaction id
         */transactionHash: String, 
        /**
         * The chain id if one is required
         */chainId: String?
    )
    /**
     * Blockchain Address
     */
    case blockchainAddress(
        /**
         * The blockchain name (e.g., "bitcoin", "ethereum")
         */chain: String, 
        /**
         * The on-chain address
         */address: String, 
        /**
         * The chain id if one is required
         */chainId: String?
    )
}


#if compiler(>=6)
extension ExternalContentId: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalContentId: FfiConverterRustBuffer {
    typealias SwiftType = ExternalContentId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalContentId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .url(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .hashtag(try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .geohash(try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .book(try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .podcastFeed(try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .podcastEpisode(try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .podcastPublisher(try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .movie(try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .paper(try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .blockchainTransaction(chain: try FfiConverterString.read(from: &buf), transactionHash: try FfiConverterString.read(from: &buf), chainId: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 11: return .blockchainAddress(chain: try FfiConverterString.read(from: &buf), address: try FfiConverterString.read(from: &buf), chainId: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ExternalContentId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .url(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .hashtag(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .geohash(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .book(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .podcastFeed(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .podcastEpisode(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .podcastPublisher(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .movie(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .paper(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .blockchainTransaction(chain,transactionHash,chainId):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(chain, into: &buf)
            FfiConverterString.write(transactionHash, into: &buf)
            FfiConverterOptionString.write(chainId, into: &buf)
            
        
        case let .blockchainAddress(chain,address,chainId):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(chain, into: &buf)
            FfiConverterString.write(address, into: &buf)
            FfiConverterOptionString.write(chainId, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalContentId_lift(_ buf: RustBuffer) throws -> ExternalContentId {
    return try FfiConverterTypeExternalContentId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalContentId_lower(_ value: ExternalContentId) -> RustBuffer {
    return FfiConverterTypeExternalContentId.lower(value)
}


extension ExternalContentId: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Supported external identity providers
 *
 * <https://github.com/nostr-protocol/nips/blob/master/39.md>
 */

public enum ExternalIdentity {
    
    /**
     * github.com
     */
    case gitHub
    /**
     * twitter.com
     */
    case twitter
    /**
     * mastodon.social
     */
    case mastodon
    /**
     * telegram.org
     */
    case telegram
}


#if compiler(>=6)
extension ExternalIdentity: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalIdentity: FfiConverterRustBuffer {
    typealias SwiftType = ExternalIdentity

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalIdentity {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .gitHub
        
        case 2: return .twitter
        
        case 3: return .mastodon
        
        case 4: return .telegram
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ExternalIdentity, into buf: inout [UInt8]) {
        switch value {
        
        
        case .gitHub:
            writeInt(&buf, Int32(1))
        
        
        case .twitter:
            writeInt(&buf, Int32(2))
        
        
        case .mastodon:
            writeInt(&buf, Int32(3))
        
        
        case .telegram:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalIdentity_lift(_ buf: RustBuffer) throws -> ExternalIdentity {
    return try FfiConverterTypeExternalIdentity.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalIdentity_lower(_ value: ExternalIdentity) -> RustBuffer {
    return FfiConverterTypeExternalIdentity.lower(value)
}


extension ExternalIdentity: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Git Patch Content
 */

public enum GitPatchContent {
    
    /**
     * Cover letter
     */
    case coverLetter(
        /**
         * Title
         */title: String, 
        /**
         * Description
         */description: String, 
        /**
         * Last commit
         */lastCommit: String, 
        /**
         * Number of commits
         */commitsLen: UInt64
    )
    /**
     * Patch
     */
    case patch(
        /**
         * Patch content
         */content: String, 
        /**
         * Commit hash
         */commit: String, 
        /**
         * Parent commit
         */parentCommit: String, 
        /**
         * PGP signature of commit
         */commitPgpSig: String?, 
        /**
         * Committer
         */committer: GitPatchCommitter
    )
}


#if compiler(>=6)
extension GitPatchContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGitPatchContent: FfiConverterRustBuffer {
    typealias SwiftType = GitPatchContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GitPatchContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .coverLetter(title: try FfiConverterString.read(from: &buf), description: try FfiConverterString.read(from: &buf), lastCommit: try FfiConverterString.read(from: &buf), commitsLen: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .patch(content: try FfiConverterString.read(from: &buf), commit: try FfiConverterString.read(from: &buf), parentCommit: try FfiConverterString.read(from: &buf), commitPgpSig: try FfiConverterOptionString.read(from: &buf), committer: try FfiConverterTypeGitPatchCommitter.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GitPatchContent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .coverLetter(title,description,lastCommit,commitsLen):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(title, into: &buf)
            FfiConverterString.write(description, into: &buf)
            FfiConverterString.write(lastCommit, into: &buf)
            FfiConverterUInt64.write(commitsLen, into: &buf)
            
        
        case let .patch(content,commit,parentCommit,commitPgpSig,committer):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(content, into: &buf)
            FfiConverterString.write(commit, into: &buf)
            FfiConverterString.write(parentCommit, into: &buf)
            FfiConverterOptionString.write(commitPgpSig, into: &buf)
            FfiConverterTypeGitPatchCommitter.write(committer, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGitPatchContent_lift(_ buf: RustBuffer) throws -> GitPatchContent {
    return try FfiConverterTypeGitPatchContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGitPatchContent_lower(_ value: GitPatchContent) -> RustBuffer {
    return FfiConverterTypeGitPatchContent.lower(value)
}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum HttpMethod {
    
    case get
    case post
    case put
    case patch
}


#if compiler(>=6)
extension HttpMethod: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHttpMethod: FfiConverterRustBuffer {
    typealias SwiftType = HttpMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .get
        
        case 2: return .post
        
        case 3: return .put
        
        case 4: return .patch
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HttpMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .get:
            writeInt(&buf, Int32(1))
        
        
        case .post:
            writeInt(&buf, Int32(2))
        
        
        case .put:
            writeInt(&buf, Int32(3))
        
        
        case .patch:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpMethod_lift(_ buf: RustBuffer) throws -> HttpMethod {
    return try FfiConverterTypeHttpMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpMethod_lower(_ value: HttpMethod) -> RustBuffer {
    return FfiConverterTypeHttpMethod.lower(value)
}


extension HttpMethod: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum JsonValue {
    
    case bool(bool: Bool
    )
    case numberPosInt(number: UInt64
    )
    case numberNegInt(number: Int64
    )
    case numberFloat(number: Double
    )
    case str(s: String
    )
    case array(array: [JsonValue]
    )
    case object(map: [String: JsonValue]
    )
    case null
}


#if compiler(>=6)
extension JsonValue: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJsonValue: FfiConverterRustBuffer {
    typealias SwiftType = JsonValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsonValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bool(bool: try FfiConverterBool.read(from: &buf)
        )
        
        case 2: return .numberPosInt(number: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 3: return .numberNegInt(number: try FfiConverterInt64.read(from: &buf)
        )
        
        case 4: return .numberFloat(number: try FfiConverterDouble.read(from: &buf)
        )
        
        case 5: return .str(s: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .array(array: try FfiConverterSequenceTypeJsonValue.read(from: &buf)
        )
        
        case 7: return .object(map: try FfiConverterDictionaryStringTypeJsonValue.read(from: &buf)
        )
        
        case 8: return .null
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JsonValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bool(bool):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(bool, into: &buf)
            
        
        case let .numberPosInt(number):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(number, into: &buf)
            
        
        case let .numberNegInt(number):
            writeInt(&buf, Int32(3))
            FfiConverterInt64.write(number, into: &buf)
            
        
        case let .numberFloat(number):
            writeInt(&buf, Int32(4))
            FfiConverterDouble.write(number, into: &buf)
            
        
        case let .str(s):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(s, into: &buf)
            
        
        case let .array(array):
            writeInt(&buf, Int32(6))
            FfiConverterSequenceTypeJsonValue.write(array, into: &buf)
            
        
        case let .object(map):
            writeInt(&buf, Int32(7))
            FfiConverterDictionaryStringTypeJsonValue.write(map, into: &buf)
            
        
        case .null:
            writeInt(&buf, Int32(8))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsonValue_lift(_ buf: RustBuffer) throws -> JsonValue {
    return try FfiConverterTypeJsonValue.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsonValue_lower(_ value: JsonValue) -> RustBuffer {
    return FfiConverterTypeJsonValue.lower(value)
}


extension JsonValue: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Key security
 */

public enum KeySecurity {
    
    /**
     * The key has been known to have been handled insecurely (stored unencrypted, cut and paste unencrypted, etc)
     */
    case weak
    /**
     * The key has NOT been known to have been handled insecurely (stored encrypted, cut and paste encrypted, etc)
     */
    case medium
    /**
     * The client does not track this data
     */
    case unknown
}


#if compiler(>=6)
extension KeySecurity: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeySecurity: FfiConverterRustBuffer {
    typealias SwiftType = KeySecurity

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeySecurity {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .weak
        
        case 2: return .medium
        
        case 3: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeySecurity, into buf: inout [UInt8]) {
        switch value {
        
        
        case .weak:
            writeInt(&buf, Int32(1))
        
        
        case .medium:
            writeInt(&buf, Int32(2))
        
        
        case .unknown:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeySecurity_lift(_ buf: RustBuffer) throws -> KeySecurity {
    return try FfiConverterTypeKeySecurity.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeySecurity_lower(_ value: KeySecurity) -> RustBuffer {
    return FfiConverterTypeKeySecurity.lower(value)
}


extension KeySecurity: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Standardized kind
 */

public enum KindStandard {
    
    /**
     * Metadata (NIP01 and NIP05)
     */
    case metadata
    /**
     * Short Text Note (NIP01)
     */
    case textNote
    /**
     * Contacts (NIP02)
     */
    case contactList
    /**
     * OpenTimestamps Attestations (NIP03)
     */
    case openTimestamps
    /**
     * Event Deletion (NIP09)
     */
    case eventDeletion
    /**
     * Repost (NIP18)
     */
    case repost
    /**
     * Generic Repost (NIP18)
     */
    case genericRepost
    /**
     * Comment (NIP22)
     */
    case comment
    /**
     * Reaction (NIP25)
     */
    case reaction
    /**
     * Badge Award (NIP58)
     */
    case badgeAward
    /**
     * Blossom Authorization
     */
    case blossomAuth
    /**
     * Channel Creation (NIP28)
     */
    case channelCreation
    /**
     * Channel Metadata (NIP28)
     */
    case channelMetadata
    /**
     * Channel Message (NIP28)
     */
    case channelMessage
    /**
     * Channel Hide Message (NIP28)
     */
    case channelHideMessage
    /**
     * Channel Mute User (NIP28)
     */
    case channelMuteUser
    /**
     * Git Patch
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
    case gitPatch
    /**
     * Git Issue
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
    case gitIssue
    /**
     * Git Reply
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
    case gitReply
    /**
     * Open Status of Git Patch or Issue
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
    case gitStatusOpen
    /**
     * Applied / Merged Status of Git Patch or Resolved Status of Git Issue
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
    case gitStatusApplied
    /**
     * Closed Status of Git Patch or Issue
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
    case gitStatusClosed
    /**
     * Draft Status of Git Patch or Issue
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
    case gitStatusDraft
    /**
     * Torrent
     *
     * <https://github.com/nostr-protocol/nips/blob/master/35.md>
     */
    case torrent
    /**
     * Torrent comment
     *
     * <https://github.com/nostr-protocol/nips/blob/master/35.md>
     */
    case torrentComment
    /**
     * Label
     *
     * <https://github.com/nostr-protocol/nips/blob/master/32.md>
     */
    case label
    /**
     * Wallet Service Info (NIP47)
     */
    case walletConnectInfo
    /**
     * Wallet Connect notification (NIP47)
     */
    case walletConnectNotification
    /**
     * Reporting (NIP56)
     */
    case reporting
    /**
     * Zap Private Message (NIP57)
     */
    case zapPrivateMessage
    /**
     * Zap Request (NIP57)
     */
    case zapRequest
    /**
     * Zap Receipt (NIP57)
     */
    case zapReceipt
    /**
     * Mute List
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case muteList
    /**
     * Pin List
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case pinList
    /**
     * Bookmarks
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case bookmarks
    /**
     * Communities
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case communities
    /**
     * Public Chats
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case publicChats
    /**
     * Blocked Relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case blockedRelays
    /**
     * Search Relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case searchRelays
    /**
     * Simple Groups
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case simpleGroups
    /**
     * Interests
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case interests
    /**
     * Emojis
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case emojis
    /**
     * Follow Set
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case followSet
    /**
     * Relay Set
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case relaySet
    /**
     * Bookmark Set
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case bookmarkSet
    /**
     * Articles Curation Set
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case articlesCurationSet
    /**
     * Videos Curation Set
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case videosCurationSet
    /**
     * Interest Set
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case interestSet
    /**
     * Emoji Set
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case emojiSet
    /**
     * Release Artifact Set
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case releaseArtifactSet
    /**
     * Relay List Metadata (NIP65)
     */
    case relayList
    /**
     * Peer-to-peer Order events
     *
     * <https://github.com/nostr-protocol/nips/blob/master/69.md>
     */
    case peerToPeerOrder
    /**
     * Request to Vanish (NIP62)
     *
     * <https://github.com/nostr-protocol/nips/blob/master/62.md>
     */
    case requestToVanish
    /**
     * Client Authentication (NIP42)
     */
    case authentication
    /**
     * Wallet Connect Request (NIP47)
     */
    case walletConnectRequest
    /**
     * Wallet Connect Response (NIP47)
     */
    case walletConnectResponse
    /**
     * Nostr Connect (NIP46)
     */
    case nostrConnect
    /**
     * Live Event (NIP53)
     */
    case liveEvent
    /**
     * Live Event Message (NIP53)
     */
    case liveEventMessage
    /**
     * Profile Badges (NIP58)
     */
    case profileBadges
    /**
     * Badge Definition (NIP58)
     */
    case badgeDefinition
    /**
     * Seal (NIP59)
     */
    case seal
    /**
     * Gift Wrap (NIP59)
     */
    case giftWrap
    /**
     * Private Direct message
     *
     * <https://github.com/nostr-protocol/nips/blob/master/17.md>
     */
    case privateDirectMessage
    /**
     * Inbox Relays (NIP17)
     */
    case inboxRelays
    /**
     * MLS Key Package Relays (NIP104)
     */
    case mlsKeyPackageRelays
    /**
     * MLS Key Package (NIP104)
     */
    case mlsKeyPackage
    /**
     * MLS Welcome (NIP104)
     */
    case mlsWelcome
    /**
     * MLS Group Message (NIP104)
     */
    case mlsGroupMessage
    /**
     * Long-form Text Note (NIP23)
     */
    case longFormTextNote
    /**
     * Git Repository Announcement
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
    case gitRepoAnnouncement
    /**
     * Application-specific Data (NIP78)
     */
    case applicationSpecificData
    /**
     * File Metadata (NIP94)
     */
    case fileMetadata
    /**
     * HTTP Auth (NIP98)
     */
    case httpAuth
    /**
     * Set stall (NIP15)
     */
    case setStall
    /**
     * Set product (NIP15)
     */
    case setProduct
    /**
     * Job Feedback (NIP90)
     */
    case jobFeedback
    /**
     * User Status
     *
     * <https://github.com/nostr-protocol/nips/blob/master/38.md>
     */
    case userStatus
    /**
     * Cashu Wallet
     *
     * <https://github.com/nostr-protocol/nips/blob/master/60.md>
     */
    case cashuWallet
    /**
     * Cashu Wallet Unspent Proof
     *
     * <https://github.com/nostr-protocol/nips/blob/master/60.md>
     */
    case cashuWalletUnspentProof
    /**
     * Cashu Wallet Spending History
     *
     * <https://github.com/nostr-protocol/nips/blob/master/60.md>
     */
    case cashuWalletSpendingHistory
    /**
     * Cashu Wallet Redeeming a quote
     */
    case cashuWalletQuote
    /**
     * Cashu Nut Zap informational event
     */
    case cashuNutZapInfo
    /**
     * Cashu Nut Zap
     */
    case cashuNutZap
    /**
     * Code Snippet
     *
     * <https://github.com/nostr-protocol/nips/blob/master/C0.md>
     */
    case codeSnippet
    /**
     * Poll
     *
     * <https://github.com/nostr-protocol/nips/blob/master/88.md>
     */
    case poll
    /**
     * Poll response
     *
     * <https://github.com/nostr-protocol/nips/blob/master/88.md>
     */
    case pollResponse
    case repoState
    case voiceMessage
    case voiceMessageReply
    case thread
    case webBookmark
    case chatMessage
}


#if compiler(>=6)
extension KindStandard: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKindStandard: FfiConverterRustBuffer {
    typealias SwiftType = KindStandard

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KindStandard {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .metadata
        
        case 2: return .textNote
        
        case 3: return .contactList
        
        case 4: return .openTimestamps
        
        case 5: return .eventDeletion
        
        case 6: return .repost
        
        case 7: return .genericRepost
        
        case 8: return .comment
        
        case 9: return .reaction
        
        case 10: return .badgeAward
        
        case 11: return .blossomAuth
        
        case 12: return .channelCreation
        
        case 13: return .channelMetadata
        
        case 14: return .channelMessage
        
        case 15: return .channelHideMessage
        
        case 16: return .channelMuteUser
        
        case 17: return .gitPatch
        
        case 18: return .gitIssue
        
        case 19: return .gitReply
        
        case 20: return .gitStatusOpen
        
        case 21: return .gitStatusApplied
        
        case 22: return .gitStatusClosed
        
        case 23: return .gitStatusDraft
        
        case 24: return .torrent
        
        case 25: return .torrentComment
        
        case 26: return .label
        
        case 27: return .walletConnectInfo
        
        case 28: return .walletConnectNotification
        
        case 29: return .reporting
        
        case 30: return .zapPrivateMessage
        
        case 31: return .zapRequest
        
        case 32: return .zapReceipt
        
        case 33: return .muteList
        
        case 34: return .pinList
        
        case 35: return .bookmarks
        
        case 36: return .communities
        
        case 37: return .publicChats
        
        case 38: return .blockedRelays
        
        case 39: return .searchRelays
        
        case 40: return .simpleGroups
        
        case 41: return .interests
        
        case 42: return .emojis
        
        case 43: return .followSet
        
        case 44: return .relaySet
        
        case 45: return .bookmarkSet
        
        case 46: return .articlesCurationSet
        
        case 47: return .videosCurationSet
        
        case 48: return .interestSet
        
        case 49: return .emojiSet
        
        case 50: return .releaseArtifactSet
        
        case 51: return .relayList
        
        case 52: return .peerToPeerOrder
        
        case 53: return .requestToVanish
        
        case 54: return .authentication
        
        case 55: return .walletConnectRequest
        
        case 56: return .walletConnectResponse
        
        case 57: return .nostrConnect
        
        case 58: return .liveEvent
        
        case 59: return .liveEventMessage
        
        case 60: return .profileBadges
        
        case 61: return .badgeDefinition
        
        case 62: return .seal
        
        case 63: return .giftWrap
        
        case 64: return .privateDirectMessage
        
        case 65: return .inboxRelays
        
        case 66: return .mlsKeyPackageRelays
        
        case 67: return .mlsKeyPackage
        
        case 68: return .mlsWelcome
        
        case 69: return .mlsGroupMessage
        
        case 70: return .longFormTextNote
        
        case 71: return .gitRepoAnnouncement
        
        case 72: return .applicationSpecificData
        
        case 73: return .fileMetadata
        
        case 74: return .httpAuth
        
        case 75: return .setStall
        
        case 76: return .setProduct
        
        case 77: return .jobFeedback
        
        case 78: return .userStatus
        
        case 79: return .cashuWallet
        
        case 80: return .cashuWalletUnspentProof
        
        case 81: return .cashuWalletSpendingHistory
        
        case 82: return .cashuWalletQuote
        
        case 83: return .cashuNutZapInfo
        
        case 84: return .cashuNutZap
        
        case 85: return .codeSnippet
        
        case 86: return .poll
        
        case 87: return .pollResponse
        
        case 88: return .repoState
        
        case 89: return .voiceMessage
        
        case 90: return .voiceMessageReply
        
        case 91: return .thread
        
        case 92: return .webBookmark
        
        case 93: return .chatMessage
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KindStandard, into buf: inout [UInt8]) {
        switch value {
        
        
        case .metadata:
            writeInt(&buf, Int32(1))
        
        
        case .textNote:
            writeInt(&buf, Int32(2))
        
        
        case .contactList:
            writeInt(&buf, Int32(3))
        
        
        case .openTimestamps:
            writeInt(&buf, Int32(4))
        
        
        case .eventDeletion:
            writeInt(&buf, Int32(5))
        
        
        case .repost:
            writeInt(&buf, Int32(6))
        
        
        case .genericRepost:
            writeInt(&buf, Int32(7))
        
        
        case .comment:
            writeInt(&buf, Int32(8))
        
        
        case .reaction:
            writeInt(&buf, Int32(9))
        
        
        case .badgeAward:
            writeInt(&buf, Int32(10))
        
        
        case .blossomAuth:
            writeInt(&buf, Int32(11))
        
        
        case .channelCreation:
            writeInt(&buf, Int32(12))
        
        
        case .channelMetadata:
            writeInt(&buf, Int32(13))
        
        
        case .channelMessage:
            writeInt(&buf, Int32(14))
        
        
        case .channelHideMessage:
            writeInt(&buf, Int32(15))
        
        
        case .channelMuteUser:
            writeInt(&buf, Int32(16))
        
        
        case .gitPatch:
            writeInt(&buf, Int32(17))
        
        
        case .gitIssue:
            writeInt(&buf, Int32(18))
        
        
        case .gitReply:
            writeInt(&buf, Int32(19))
        
        
        case .gitStatusOpen:
            writeInt(&buf, Int32(20))
        
        
        case .gitStatusApplied:
            writeInt(&buf, Int32(21))
        
        
        case .gitStatusClosed:
            writeInt(&buf, Int32(22))
        
        
        case .gitStatusDraft:
            writeInt(&buf, Int32(23))
        
        
        case .torrent:
            writeInt(&buf, Int32(24))
        
        
        case .torrentComment:
            writeInt(&buf, Int32(25))
        
        
        case .label:
            writeInt(&buf, Int32(26))
        
        
        case .walletConnectInfo:
            writeInt(&buf, Int32(27))
        
        
        case .walletConnectNotification:
            writeInt(&buf, Int32(28))
        
        
        case .reporting:
            writeInt(&buf, Int32(29))
        
        
        case .zapPrivateMessage:
            writeInt(&buf, Int32(30))
        
        
        case .zapRequest:
            writeInt(&buf, Int32(31))
        
        
        case .zapReceipt:
            writeInt(&buf, Int32(32))
        
        
        case .muteList:
            writeInt(&buf, Int32(33))
        
        
        case .pinList:
            writeInt(&buf, Int32(34))
        
        
        case .bookmarks:
            writeInt(&buf, Int32(35))
        
        
        case .communities:
            writeInt(&buf, Int32(36))
        
        
        case .publicChats:
            writeInt(&buf, Int32(37))
        
        
        case .blockedRelays:
            writeInt(&buf, Int32(38))
        
        
        case .searchRelays:
            writeInt(&buf, Int32(39))
        
        
        case .simpleGroups:
            writeInt(&buf, Int32(40))
        
        
        case .interests:
            writeInt(&buf, Int32(41))
        
        
        case .emojis:
            writeInt(&buf, Int32(42))
        
        
        case .followSet:
            writeInt(&buf, Int32(43))
        
        
        case .relaySet:
            writeInt(&buf, Int32(44))
        
        
        case .bookmarkSet:
            writeInt(&buf, Int32(45))
        
        
        case .articlesCurationSet:
            writeInt(&buf, Int32(46))
        
        
        case .videosCurationSet:
            writeInt(&buf, Int32(47))
        
        
        case .interestSet:
            writeInt(&buf, Int32(48))
        
        
        case .emojiSet:
            writeInt(&buf, Int32(49))
        
        
        case .releaseArtifactSet:
            writeInt(&buf, Int32(50))
        
        
        case .relayList:
            writeInt(&buf, Int32(51))
        
        
        case .peerToPeerOrder:
            writeInt(&buf, Int32(52))
        
        
        case .requestToVanish:
            writeInt(&buf, Int32(53))
        
        
        case .authentication:
            writeInt(&buf, Int32(54))
        
        
        case .walletConnectRequest:
            writeInt(&buf, Int32(55))
        
        
        case .walletConnectResponse:
            writeInt(&buf, Int32(56))
        
        
        case .nostrConnect:
            writeInt(&buf, Int32(57))
        
        
        case .liveEvent:
            writeInt(&buf, Int32(58))
        
        
        case .liveEventMessage:
            writeInt(&buf, Int32(59))
        
        
        case .profileBadges:
            writeInt(&buf, Int32(60))
        
        
        case .badgeDefinition:
            writeInt(&buf, Int32(61))
        
        
        case .seal:
            writeInt(&buf, Int32(62))
        
        
        case .giftWrap:
            writeInt(&buf, Int32(63))
        
        
        case .privateDirectMessage:
            writeInt(&buf, Int32(64))
        
        
        case .inboxRelays:
            writeInt(&buf, Int32(65))
        
        
        case .mlsKeyPackageRelays:
            writeInt(&buf, Int32(66))
        
        
        case .mlsKeyPackage:
            writeInt(&buf, Int32(67))
        
        
        case .mlsWelcome:
            writeInt(&buf, Int32(68))
        
        
        case .mlsGroupMessage:
            writeInt(&buf, Int32(69))
        
        
        case .longFormTextNote:
            writeInt(&buf, Int32(70))
        
        
        case .gitRepoAnnouncement:
            writeInt(&buf, Int32(71))
        
        
        case .applicationSpecificData:
            writeInt(&buf, Int32(72))
        
        
        case .fileMetadata:
            writeInt(&buf, Int32(73))
        
        
        case .httpAuth:
            writeInt(&buf, Int32(74))
        
        
        case .setStall:
            writeInt(&buf, Int32(75))
        
        
        case .setProduct:
            writeInt(&buf, Int32(76))
        
        
        case .jobFeedback:
            writeInt(&buf, Int32(77))
        
        
        case .userStatus:
            writeInt(&buf, Int32(78))
        
        
        case .cashuWallet:
            writeInt(&buf, Int32(79))
        
        
        case .cashuWalletUnspentProof:
            writeInt(&buf, Int32(80))
        
        
        case .cashuWalletSpendingHistory:
            writeInt(&buf, Int32(81))
        
        
        case .cashuWalletQuote:
            writeInt(&buf, Int32(82))
        
        
        case .cashuNutZapInfo:
            writeInt(&buf, Int32(83))
        
        
        case .cashuNutZap:
            writeInt(&buf, Int32(84))
        
        
        case .codeSnippet:
            writeInt(&buf, Int32(85))
        
        
        case .poll:
            writeInt(&buf, Int32(86))
        
        
        case .pollResponse:
            writeInt(&buf, Int32(87))
        
        
        case .repoState:
            writeInt(&buf, Int32(88))
        
        
        case .voiceMessage:
            writeInt(&buf, Int32(89))
        
        
        case .voiceMessageReply:
            writeInt(&buf, Int32(90))
        
        
        case .thread:
            writeInt(&buf, Int32(91))
        
        
        case .webBookmark:
            writeInt(&buf, Int32(92))
        
        
        case .chatMessage:
            writeInt(&buf, Int32(93))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKindStandard_lift(_ buf: RustBuffer) throws -> KindStandard {
    return try FfiConverterTypeKindStandard.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKindStandard_lower(_ value: KindStandard) -> RustBuffer {
    return FfiConverterTypeKindStandard.lower(value)
}


extension KindStandard: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Live Event Marker
 */

public enum LiveEventMarker {
    
    /**
     * Host
     */
    case host
    /**
     * Speaker
     */
    case speaker
    /**
     * Participant
     */
    case participant
}


#if compiler(>=6)
extension LiveEventMarker: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLiveEventMarker: FfiConverterRustBuffer {
    typealias SwiftType = LiveEventMarker

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveEventMarker {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .host
        
        case 2: return .speaker
        
        case 3: return .participant
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LiveEventMarker, into buf: inout [UInt8]) {
        switch value {
        
        
        case .host:
            writeInt(&buf, Int32(1))
        
        
        case .speaker:
            writeInt(&buf, Int32(2))
        
        
        case .participant:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveEventMarker_lift(_ buf: RustBuffer) throws -> LiveEventMarker {
    return try FfiConverterTypeLiveEventMarker.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveEventMarker_lower(_ value: LiveEventMarker) -> RustBuffer {
    return FfiConverterTypeLiveEventMarker.lower(value)
}


extension LiveEventMarker: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LiveEventStatus {
    
    case planned
    case live
    case ended
    case custom(custom: String
    )
}


#if compiler(>=6)
extension LiveEventStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLiveEventStatus: FfiConverterRustBuffer {
    typealias SwiftType = LiveEventStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveEventStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .planned
        
        case 2: return .live
        
        case 3: return .ended
        
        case 4: return .custom(custom: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LiveEventStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .planned:
            writeInt(&buf, Int32(1))
        
        
        case .live:
            writeInt(&buf, Int32(2))
        
        
        case .ended:
            writeInt(&buf, Int32(3))
        
        
        case let .custom(custom):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(custom, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveEventStatus_lift(_ buf: RustBuffer) throws -> LiveEventStatus {
    return try FfiConverterTypeLiveEventStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveEventStatus_lower(_ value: LiveEventStatus) -> RustBuffer {
    return FfiConverterTypeLiveEventStatus.lower(value)
}


extension LiveEventStatus: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogLevel {
    
    case error
    case warn
    case info
    case debug
    case trace
}


#if compiler(>=6)
extension LogLevel: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .error
        
        case 2: return .warn
        
        case 3: return .info
        
        case 4: return .debug
        
        case 5: return .trace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .error:
            writeInt(&buf, Int32(1))
        
        
        case .warn:
            writeInt(&buf, Int32(2))
        
        
        case .info:
            writeInt(&buf, Int32(3))
        
        
        case .debug:
            writeInt(&buf, Int32(4))
        
        
        case .trace:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}


extension LogLevel: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Marker
 */

public enum Marker {
    
    /**
     * Root
     */
    case root
    /**
     * Reply
     */
    case reply
}


#if compiler(>=6)
extension Marker: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMarker: FfiConverterRustBuffer {
    typealias SwiftType = Marker

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Marker {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .root
        
        case 2: return .reply
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Marker, into buf: inout [UInt8]) {
        switch value {
        
        
        case .root:
            writeInt(&buf, Int32(1))
        
        
        case .reply:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMarker_lift(_ buf: RustBuffer) throws -> Marker {
    return try FfiConverterTypeMarker.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMarker_lower(_ value: Marker) -> RustBuffer {
    return FfiConverterTypeMarker.lower(value)
}


extension Marker: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Method
 */

public enum Method {
    
    /**
     * Pay Invoice
     */
    case payInvoice
    /**
     * Multi Pay Invoice
     */
    case multiPayInvoice
    /**
     * Pay Keysend
     */
    case payKeysend
    /**
     * Multi Pay Keysend
     */
    case multiPayKeysend
    /**
     * Make Invoice
     */
    case makeInvoice
    /**
     * Lookup Invoice
     */
    case lookupInvoice
    /**
     * List transactions
     */
    case listTransactions
    /**
     * Get Balance
     */
    case getBalance
    /**
     * Get Info
     */
    case getInfo
    /**
     * Make Hold Invoice
     */
    case makeHoldInvoice
    /**
     * Cancel Hold Invoice
     */
    case cancelHoldInvoice
    /**
     * Settle Hold Invoice
     */
    case settleHoldInvoice
}


#if compiler(>=6)
extension Method: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMethod: FfiConverterRustBuffer {
    typealias SwiftType = Method

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Method {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .payInvoice
        
        case 2: return .multiPayInvoice
        
        case 3: return .payKeysend
        
        case 4: return .multiPayKeysend
        
        case 5: return .makeInvoice
        
        case 6: return .lookupInvoice
        
        case 7: return .listTransactions
        
        case 8: return .getBalance
        
        case 9: return .getInfo
        
        case 10: return .makeHoldInvoice
        
        case 11: return .cancelHoldInvoice
        
        case 12: return .settleHoldInvoice
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Method, into buf: inout [UInt8]) {
        switch value {
        
        
        case .payInvoice:
            writeInt(&buf, Int32(1))
        
        
        case .multiPayInvoice:
            writeInt(&buf, Int32(2))
        
        
        case .payKeysend:
            writeInt(&buf, Int32(3))
        
        
        case .multiPayKeysend:
            writeInt(&buf, Int32(4))
        
        
        case .makeInvoice:
            writeInt(&buf, Int32(5))
        
        
        case .lookupInvoice:
            writeInt(&buf, Int32(6))
        
        
        case .listTransactions:
            writeInt(&buf, Int32(7))
        
        
        case .getBalance:
            writeInt(&buf, Int32(8))
        
        
        case .getInfo:
            writeInt(&buf, Int32(9))
        
        
        case .makeHoldInvoice:
            writeInt(&buf, Int32(10))
        
        
        case .cancelHoldInvoice:
            writeInt(&buf, Int32(11))
        
        
        case .settleHoldInvoice:
            writeInt(&buf, Int32(12))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMethod_lift(_ buf: RustBuffer) throws -> Method {
    return try FfiConverterTypeMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMethod_lower(_ value: Method) -> RustBuffer {
    return FfiConverterTypeMethod.lower(value)
}


extension Method: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A representation any `NIP19` bech32 nostr object. Useful for decoding
 * `NIP19` bech32 strings without necessarily knowing what you're decoding
 * ahead of time.
 */

public enum Nip19Enum {
    
    /**
     * nsec
     */
    case secret(nsec: SecretKey
    )
    /**
     * Encrypted Secret Key
     */
    case encryptedSecret(val: EncryptedSecretKey
    )
    /**
     * npub
     */
    case pubkey(npub: PublicKey
    )
    /**
     * nprofile
     */
    case profile(nprofile: Nip19Profile
    )
    /**
     * note
     */
    case note(eventId: EventId
    )
    /**
     * nevent
     */
    case event(event: Nip19Event
    )
    /**
     * naddr
     */
    case addr(coordinate: Nip19Coordinate
    )
}


#if compiler(>=6)
extension Nip19Enum: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNip19Enum: FfiConverterRustBuffer {
    typealias SwiftType = Nip19Enum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip19Enum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .secret(nsec: try FfiConverterTypeSecretKey.read(from: &buf)
        )
        
        case 2: return .encryptedSecret(val: try FfiConverterTypeEncryptedSecretKey.read(from: &buf)
        )
        
        case 3: return .pubkey(npub: try FfiConverterTypePublicKey.read(from: &buf)
        )
        
        case 4: return .profile(nprofile: try FfiConverterTypeNip19Profile.read(from: &buf)
        )
        
        case 5: return .note(eventId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 6: return .event(event: try FfiConverterTypeNip19Event.read(from: &buf)
        )
        
        case 7: return .addr(coordinate: try FfiConverterTypeNip19Coordinate.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Nip19Enum, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .secret(nsec):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecretKey.write(nsec, into: &buf)
            
        
        case let .encryptedSecret(val):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEncryptedSecretKey.write(val, into: &buf)
            
        
        case let .pubkey(npub):
            writeInt(&buf, Int32(3))
            FfiConverterTypePublicKey.write(npub, into: &buf)
            
        
        case let .profile(nprofile):
            writeInt(&buf, Int32(4))
            FfiConverterTypeNip19Profile.write(nprofile, into: &buf)
            
        
        case let .note(eventId):
            writeInt(&buf, Int32(5))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            
        
        case let .event(event):
            writeInt(&buf, Int32(6))
            FfiConverterTypeNip19Event.write(event, into: &buf)
            
        
        case let .addr(coordinate):
            writeInt(&buf, Int32(7))
            FfiConverterTypeNip19Coordinate.write(coordinate, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip19Enum_lift(_ buf: RustBuffer) throws -> Nip19Enum {
    return try FfiConverterTypeNip19Enum.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip19Enum_lower(_ value: Nip19Enum) -> RustBuffer {
    return FfiConverterTypeNip19Enum.lower(value)
}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A representation any `NIP21` object. Useful for decoding
 * `NIP21` strings without necessarily knowing what you're decoding
 * ahead of time.
 */

public enum Nip21Enum {
    
    /**
     * nostr::npub
     */
    case pubkey(publicKey: PublicKey
    )
    /**
     * nostr::nprofile
     */
    case profile(profile: Nip19Profile
    )
    /**
     * nostr::note (EventId)
     */
    case note(eventId: EventId
    )
    /**
     * nostr::nevent
     */
    case event(event: Nip19Event
    )
    /**
     * nostr::naddr
     */
    case addr(coordinate: Nip19Coordinate
    )
}


#if compiler(>=6)
extension Nip21Enum: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNip21Enum: FfiConverterRustBuffer {
    typealias SwiftType = Nip21Enum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip21Enum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pubkey(publicKey: try FfiConverterTypePublicKey.read(from: &buf)
        )
        
        case 2: return .profile(profile: try FfiConverterTypeNip19Profile.read(from: &buf)
        )
        
        case 3: return .note(eventId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 4: return .event(event: try FfiConverterTypeNip19Event.read(from: &buf)
        )
        
        case 5: return .addr(coordinate: try FfiConverterTypeNip19Coordinate.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Nip21Enum, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .pubkey(publicKey):
            writeInt(&buf, Int32(1))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            
        
        case let .profile(profile):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNip19Profile.write(profile, into: &buf)
            
        
        case let .note(eventId):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            
        
        case let .event(event):
            writeInt(&buf, Int32(4))
            FfiConverterTypeNip19Event.write(event, into: &buf)
            
        
        case let .addr(coordinate):
            writeInt(&buf, Int32(5))
            FfiConverterTypeNip19Coordinate.write(coordinate, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip21Enum_lift(_ buf: RustBuffer) throws -> Nip21Enum {
    return try FfiConverterTypeNip21Enum.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip21Enum_lower(_ value: Nip21Enum) -> RustBuffer {
    return FfiConverterTypeNip21Enum.lower(value)
}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * NIP44 Version
 */

public enum Nip44Version {
    
    /**
     * V2 - Secp256k1 ECDH, HKDF, padding, ChaCha20, HMAC-SHA256 and base64
     */
    case v2
}


#if compiler(>=6)
extension Nip44Version: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNip44Version: FfiConverterRustBuffer {
    typealias SwiftType = Nip44Version

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip44Version {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .v2
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Nip44Version, into buf: inout [UInt8]) {
        switch value {
        
        
        case .v2:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip44Version_lift(_ buf: RustBuffer) throws -> Nip44Version {
    return try FfiConverterTypeNip44Version.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip44Version_lower(_ value: Nip44Version) -> RustBuffer {
    return FfiConverterTypeNip44Version.lower(value)
}


extension Nip44Version: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * NIP-73 kinds
 */

public enum Nip73Kind {
    
    /**
     * URLs kind "web"
     */
    case url
    /**
     * Books kind "isbn"
     */
    case book
    /**
     * Geohashes kind "geo"
     */
    case geohash
    /**
     * Movies kind "isan"
     */
    case movie
    /**
     * Papers kind "doi"
     */
    case paper
    /**
     * Hashtags kind "#"
     */
    case hashtag
    /**
     * Podcast feeds kind "podcast:guid"
     */
    case podcastFeed
    /**
     * Podcast episodes kind "podcast:item:guid"
     */
    case podcastEpisode
    /**
     * Podcast publishers kind "podcast:publisher:guid"
     */
    case podcastPublisher
    /**
     * Blockchain transaction kind "<blockchain>:tx"
     */
    case blockchainTransaction(tx: String
    )
    /**
     * Blockchain address kind "<blockchain>:address"
     */
    case blockchainAddress(address: String
    )
}


#if compiler(>=6)
extension Nip73Kind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNip73Kind: FfiConverterRustBuffer {
    typealias SwiftType = Nip73Kind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip73Kind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .url
        
        case 2: return .book
        
        case 3: return .geohash
        
        case 4: return .movie
        
        case 5: return .paper
        
        case 6: return .hashtag
        
        case 7: return .podcastFeed
        
        case 8: return .podcastEpisode
        
        case 9: return .podcastPublisher
        
        case 10: return .blockchainTransaction(tx: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .blockchainAddress(address: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Nip73Kind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .url:
            writeInt(&buf, Int32(1))
        
        
        case .book:
            writeInt(&buf, Int32(2))
        
        
        case .geohash:
            writeInt(&buf, Int32(3))
        
        
        case .movie:
            writeInt(&buf, Int32(4))
        
        
        case .paper:
            writeInt(&buf, Int32(5))
        
        
        case .hashtag:
            writeInt(&buf, Int32(6))
        
        
        case .podcastFeed:
            writeInt(&buf, Int32(7))
        
        
        case .podcastEpisode:
            writeInt(&buf, Int32(8))
        
        
        case .podcastPublisher:
            writeInt(&buf, Int32(9))
        
        
        case let .blockchainTransaction(tx):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(tx, into: &buf)
            
        
        case let .blockchainAddress(address):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(address, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip73Kind_lift(_ buf: RustBuffer) throws -> Nip73Kind {
    return try FfiConverterTypeNip73Kind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNip73Kind_lower(_ value: Nip73Kind) -> RustBuffer {
    return FfiConverterTypeNip73Kind.lower(value)
}


extension Nip73Kind: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NostrConnectMessage {
    
    case request(id: String, method: String, params: [String]
    )
    case response(id: String, result: String?, error: String?
    )
}


#if compiler(>=6)
extension NostrConnectMessage: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNostrConnectMessage: FfiConverterRustBuffer {
    typealias SwiftType = NostrConnectMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .request(id: try FfiConverterString.read(from: &buf), method: try FfiConverterString.read(from: &buf), params: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 2: return .response(id: try FfiConverterString.read(from: &buf), result: try FfiConverterOptionString.read(from: &buf), error: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NostrConnectMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .request(id,method,params):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(id, into: &buf)
            FfiConverterString.write(method, into: &buf)
            FfiConverterSequenceString.write(params, into: &buf)
            
        
        case let .response(id,result,error):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(id, into: &buf)
            FfiConverterOptionString.write(result, into: &buf)
            FfiConverterOptionString.write(error, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrConnectMessage_lift(_ buf: RustBuffer) throws -> NostrConnectMessage {
    return try FfiConverterTypeNostrConnectMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrConnectMessage_lower(_ value: NostrConnectMessage) -> RustBuffer {
    return FfiConverterTypeNostrConnectMessage.lower(value)
}


extension NostrConnectMessage: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Nostr Connect Request (NIP46)
 */

public enum NostrConnectRequest {
    
    /**
     * Connect
     */
    case connect(
        /**
         * Remote public key
         */remoteSignerPublicKey: PublicKey, 
        /**
         * Optional secret
         */secret: String?
    )
    /**
     * Get public key
     */
    case getPublicKey
    /**
     * Sign [`UnsignedEvent`]
     */
    case signEvent(unsignedEvent: UnsignedEvent
    )
    /**
     * Encrypt text (NIP04)
     */
    case nip04Encrypt(
        /**
         * Pubkey
         */publicKey: PublicKey, 
        /**
         * Plain text
         */text: String
    )
    /**
     * Decrypt (NIP04)
     */
    case nip04Decrypt(
        /**
         * Pubkey
         */publicKey: PublicKey, 
        /**
         * Ciphertext
         */ciphertext: String
    )
    /**
     * Encrypt text (NIP44)
     */
    case nip44Encrypt(
        /**
         * Pubkey
         */publicKey: PublicKey, 
        /**
         * Plain text
         */text: String
    )
    /**
     * Decrypt (NIP44)
     */
    case nip44Decrypt(
        /**
         * Pubkey
         */publicKey: PublicKey, 
        /**
         * Ciphertext
         */ciphertext: String
    )
    /**
     * Ping
     */
    case ping
}


#if compiler(>=6)
extension NostrConnectRequest: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNostrConnectRequest: FfiConverterRustBuffer {
    typealias SwiftType = NostrConnectRequest

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectRequest {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .connect(remoteSignerPublicKey: try FfiConverterTypePublicKey.read(from: &buf), secret: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 2: return .getPublicKey
        
        case 3: return .signEvent(unsignedEvent: try FfiConverterTypeUnsignedEvent.read(from: &buf)
        )
        
        case 4: return .nip04Encrypt(publicKey: try FfiConverterTypePublicKey.read(from: &buf), text: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .nip04Decrypt(publicKey: try FfiConverterTypePublicKey.read(from: &buf), ciphertext: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .nip44Encrypt(publicKey: try FfiConverterTypePublicKey.read(from: &buf), text: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .nip44Decrypt(publicKey: try FfiConverterTypePublicKey.read(from: &buf), ciphertext: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .ping
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NostrConnectRequest, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .connect(remoteSignerPublicKey,secret):
            writeInt(&buf, Int32(1))
            FfiConverterTypePublicKey.write(remoteSignerPublicKey, into: &buf)
            FfiConverterOptionString.write(secret, into: &buf)
            
        
        case .getPublicKey:
            writeInt(&buf, Int32(2))
        
        
        case let .signEvent(unsignedEvent):
            writeInt(&buf, Int32(3))
            FfiConverterTypeUnsignedEvent.write(unsignedEvent, into: &buf)
            
        
        case let .nip04Encrypt(publicKey,text):
            writeInt(&buf, Int32(4))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterString.write(text, into: &buf)
            
        
        case let .nip04Decrypt(publicKey,ciphertext):
            writeInt(&buf, Int32(5))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterString.write(ciphertext, into: &buf)
            
        
        case let .nip44Encrypt(publicKey,text):
            writeInt(&buf, Int32(6))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterString.write(text, into: &buf)
            
        
        case let .nip44Decrypt(publicKey,ciphertext):
            writeInt(&buf, Int32(7))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterString.write(ciphertext, into: &buf)
            
        
        case .ping:
            writeInt(&buf, Int32(8))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrConnectRequest_lift(_ buf: RustBuffer) throws -> NostrConnectRequest {
    return try FfiConverterTypeNostrConnectRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrConnectRequest_lower(_ value: NostrConnectRequest) -> RustBuffer {
    return FfiConverterTypeNostrConnectRequest.lower(value)
}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NostrParserToken {
    
    /**
     * Nostr URI
     *
     * <https://github.com/nostr-protocol/nips/blob/master/21.md>
     */
    case nostr(uri: Nip21Enum
    )
    /**
     * Url
     */
    case url(url: String
    )
    /**
     * Hashtag
     */
    case hashtag(hashtag: String
    )
    /**
     * Other text
     *
     * Spaces at the beginning or end of a text are parsed as [`Token::Whitespace`].
     */
    case text(text: String
    )
    /**
     * Line break
     */
    case lineBreak
    /**
     * A whitespace
     */
    case whitespace
}


#if compiler(>=6)
extension NostrParserToken: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNostrParserToken: FfiConverterRustBuffer {
    typealias SwiftType = NostrParserToken

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrParserToken {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nostr(uri: try FfiConverterTypeNip21Enum.read(from: &buf)
        )
        
        case 2: return .url(url: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .hashtag(hashtag: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .text(text: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .lineBreak
        
        case 6: return .whitespace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NostrParserToken, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .nostr(uri):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNip21Enum.write(uri, into: &buf)
            
        
        case let .url(url):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .hashtag(hashtag):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(hashtag, into: &buf)
            
        
        case let .text(text):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(text, into: &buf)
            
        
        case .lineBreak:
            writeInt(&buf, Int32(5))
        
        
        case .whitespace:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrParserToken_lift(_ buf: RustBuffer) throws -> NostrParserToken {
    return try FfiConverterTypeNostrParserToken.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrParserToken_lower(_ value: NostrParserToken) -> RustBuffer {
    return FfiConverterTypeNostrParserToken.lower(value)
}







public enum NostrSdkError: Swift.Error {

    
    
    case Generic(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNostrSdkError: FfiConverterRustBuffer {
    typealias SwiftType = NostrSdkError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrSdkError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NostrSdkError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrSdkError_lift(_ buf: RustBuffer) throws -> NostrSdkError {
    return try FfiConverterTypeNostrSdkError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNostrSdkError_lower(_ value: NostrSdkError) -> RustBuffer {
    return FfiConverterTypeNostrSdkError.lower(value)
}


extension NostrSdkError: Equatable, Hashable {}




extension NostrSdkError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Generic plugin policy response
 */

public enum PolicyResult {
    
    /**
     * Policy enforces that the event/query should be accepted
     */
    case accept
    /**
     * Policy enforces that the event/query should be rejected
     */
    case reject(
        /**
         * Rejection reason
         */reason: String
    )
}


#if compiler(>=6)
extension PolicyResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePolicyResult: FfiConverterRustBuffer {
    typealias SwiftType = PolicyResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PolicyResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .accept
        
        case 2: return .reject(reason: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PolicyResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case .accept:
            writeInt(&buf, Int32(1))
        
        
        case let .reject(reason):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolicyResult_lift(_ buf: RustBuffer) throws -> PolicyResult {
    return try FfiConverterTypePolicyResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePolicyResult_lower(_ value: PolicyResult) -> RustBuffer {
    return FfiConverterTypePolicyResult.lower(value)
}


extension PolicyResult: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PollType {
    
    /**
     * Single choice
     */
    case singleChoice
    /**
     * Multiple choice
     */
    case multipleChoice
}


#if compiler(>=6)
extension PollType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePollType: FfiConverterRustBuffer {
    typealias SwiftType = PollType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PollType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .singleChoice
        
        case 2: return .multipleChoice
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PollType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .singleChoice:
            writeInt(&buf, Int32(1))
        
        
        case .multipleChoice:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePollType_lift(_ buf: RustBuffer) throws -> PollType {
    return try FfiConverterTypePollType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePollType_lower(_ value: PollType) -> RustBuffer {
    return FfiConverterTypePollType.lower(value)
}


extension PollType: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * NIP48 Proxy Protocol
 */

public enum Protocol {
    
    /**
     * ActivityPub
     */
    case activityPub
    /**
     * AT Protocol
     */
    case atProto
    /**
     * Rss
     */
    case rss
    /**
     * Web
     */
    case web
    /**
     * Custom
     */
    case custom(custom: String
    )
}


#if compiler(>=6)
extension Protocol: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProtocol: FfiConverterRustBuffer {
    typealias SwiftType = Protocol

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Protocol {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .activityPub
        
        case 2: return .atProto
        
        case 3: return .rss
        
        case 4: return .web
        
        case 5: return .custom(custom: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Protocol, into buf: inout [UInt8]) {
        switch value {
        
        
        case .activityPub:
            writeInt(&buf, Int32(1))
        
        
        case .atProto:
            writeInt(&buf, Int32(2))
        
        
        case .rss:
            writeInt(&buf, Int32(3))
        
        
        case .web:
            writeInt(&buf, Int32(4))
        
        
        case let .custom(custom):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(custom, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProtocol_lift(_ buf: RustBuffer) throws -> Protocol {
    return try FfiConverterTypeProtocol.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProtocol_lower(_ value: Protocol) -> RustBuffer {
    return FfiConverterTypeProtocol.lower(value)
}


extension Protocol: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Reason why event wasn't stored into the database
 */

public enum RejectedReason {
    
    /**
     * Ephemeral events aren't expected to be stored
     */
    case ephemeral
    /**
     * The event already exists
     */
    case duplicate
    /**
     * The event was deleted
     */
    case deleted
    /**
     * The event is expired
     */
    case expired
    /**
     * The event was replaced
     */
    case replaced
    /**
     * Attempt to delete a non-owned event
     */
    case invalidDelete
    /**
     * Other reason
     */
    case other
}


#if compiler(>=6)
extension RejectedReason: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRejectedReason: FfiConverterRustBuffer {
    typealias SwiftType = RejectedReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RejectedReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ephemeral
        
        case 2: return .duplicate
        
        case 3: return .deleted
        
        case 4: return .expired
        
        case 5: return .replaced
        
        case 6: return .invalidDelete
        
        case 7: return .other
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RejectedReason, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ephemeral:
            writeInt(&buf, Int32(1))
        
        
        case .duplicate:
            writeInt(&buf, Int32(2))
        
        
        case .deleted:
            writeInt(&buf, Int32(3))
        
        
        case .expired:
            writeInt(&buf, Int32(4))
        
        
        case .replaced:
            writeInt(&buf, Int32(5))
        
        
        case .invalidDelete:
            writeInt(&buf, Int32(6))
        
        
        case .other:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRejectedReason_lift(_ buf: RustBuffer) throws -> RejectedReason {
    return try FfiConverterTypeRejectedReason.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRejectedReason_lower(_ value: RejectedReason) -> RustBuffer {
    return FfiConverterTypeRejectedReason.lower(value)
}


extension RejectedReason: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * NIP42 mode
 */

public enum RelayBuilderNip42Mode {
    
    /**
     * Require authentication for writing
     */
    case write
    /**
     * Require authentication for reading
     */
    case read
    /**
     * Always require authentication
     */
    case both
}


#if compiler(>=6)
extension RelayBuilderNip42Mode: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRelayBuilderNip42Mode: FfiConverterRustBuffer {
    typealias SwiftType = RelayBuilderNip42Mode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayBuilderNip42Mode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .write
        
        case 2: return .read
        
        case 3: return .both
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RelayBuilderNip42Mode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .write:
            writeInt(&buf, Int32(1))
        
        
        case .read:
            writeInt(&buf, Int32(2))
        
        
        case .both:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayBuilderNip42Mode_lift(_ buf: RustBuffer) throws -> RelayBuilderNip42Mode {
    return try FfiConverterTypeRelayBuilderNip42Mode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayBuilderNip42Mode_lower(_ value: RelayBuilderNip42Mode) -> RustBuffer {
    return FfiConverterTypeRelayBuilderNip42Mode.lower(value)
}


extension RelayBuilderNip42Mode: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RelayMessageEnum {
    
    case eventMsg(subscriptionId: String, event: Event
    )
    case ok(eventId: EventId, status: Bool, message: String
    )
    case endOfStoredEvents(subscriptionId: String
    )
    case notice(message: String
    )
    case closed(subscriptionId: String, message: String
    )
    case auth(challenge: String
    )
    case count(subscriptionId: String, count: UInt64
    )
    case negMsg(subscriptionId: String, message: String
    )
    case negErr(subscriptionId: String, message: String
    )
}


#if compiler(>=6)
extension RelayMessageEnum: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRelayMessageEnum: FfiConverterRustBuffer {
    typealias SwiftType = RelayMessageEnum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayMessageEnum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventMsg(subscriptionId: try FfiConverterString.read(from: &buf), event: try FfiConverterTypeEvent.read(from: &buf)
        )
        
        case 2: return .ok(eventId: try FfiConverterTypeEventId.read(from: &buf), status: try FfiConverterBool.read(from: &buf), message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .endOfStoredEvents(subscriptionId: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .notice(message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .closed(subscriptionId: try FfiConverterString.read(from: &buf), message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .auth(challenge: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .count(subscriptionId: try FfiConverterString.read(from: &buf), count: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 8: return .negMsg(subscriptionId: try FfiConverterString.read(from: &buf), message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .negErr(subscriptionId: try FfiConverterString.read(from: &buf), message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RelayMessageEnum, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .eventMsg(subscriptionId,event):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterTypeEvent.write(event, into: &buf)
            
        
        case let .ok(eventId,status,message):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            FfiConverterBool.write(status, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .endOfStoredEvents(subscriptionId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(subscriptionId, into: &buf)
            
        
        case let .notice(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .closed(subscriptionId,message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .auth(challenge):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(challenge, into: &buf)
            
        
        case let .count(subscriptionId,count):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterUInt64.write(count, into: &buf)
            
        
        case let .negMsg(subscriptionId,message):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .negErr(subscriptionId,message):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayMessageEnum_lift(_ buf: RustBuffer) throws -> RelayMessageEnum {
    return try FfiConverterTypeRelayMessageEnum.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayMessageEnum_lower(_ value: RelayMessageEnum) -> RustBuffer {
    return FfiConverterTypeRelayMessageEnum.lower(value)
}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RelayMetadata {
    
    /**
     * Read
     */
    case read
    /**
     * Write
     */
    case write
}


#if compiler(>=6)
extension RelayMetadata: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRelayMetadata: FfiConverterRustBuffer {
    typealias SwiftType = RelayMetadata

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayMetadata {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .read
        
        case 2: return .write
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RelayMetadata, into buf: inout [UInt8]) {
        switch value {
        
        
        case .read:
            writeInt(&buf, Int32(1))
        
        
        case .write:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayMetadata_lift(_ buf: RustBuffer) throws -> RelayMetadata {
    return try FfiConverterTypeRelayMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayMetadata_lower(_ value: RelayMetadata) -> RustBuffer {
    return FfiConverterTypeRelayMetadata.lower(value)
}


extension RelayMetadata: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RelayStatus {
    
    /**
     * Initialized
     */
    case initialized
    /**
     * Pending
     */
    case pending
    /**
     * Connecting
     */
    case connecting
    /**
     * Connected
     */
    case connected
    /**
     * Disconnected, will retry to connect again
     */
    case disconnected
    /**
     * Completely disconnected
     */
    case terminated
    /**
     * The relay has been banned.
     */
    case banned
    /**
     * Relay is sleeping
     */
    case sleeping
}


#if compiler(>=6)
extension RelayStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRelayStatus: FfiConverterRustBuffer {
    typealias SwiftType = RelayStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initialized
        
        case 2: return .pending
        
        case 3: return .connecting
        
        case 4: return .connected
        
        case 5: return .disconnected
        
        case 6: return .terminated
        
        case 7: return .banned
        
        case 8: return .sleeping
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RelayStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .initialized:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case .connecting:
            writeInt(&buf, Int32(3))
        
        
        case .connected:
            writeInt(&buf, Int32(4))
        
        
        case .disconnected:
            writeInt(&buf, Int32(5))
        
        
        case .terminated:
            writeInt(&buf, Int32(6))
        
        
        case .banned:
            writeInt(&buf, Int32(7))
        
        
        case .sleeping:
            writeInt(&buf, Int32(8))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayStatus_lift(_ buf: RustBuffer) throws -> RelayStatus {
    return try FfiConverterTypeRelayStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRelayStatus_lower(_ value: RelayStatus) -> RustBuffer {
    return FfiConverterTypeRelayStatus.lower(value)
}


extension RelayStatus: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Report
 *
 * <https://github.com/nostr-protocol/nips/blob/master/56.md>
 */

public enum Report {
    
    /**
     * Depictions of nudity, porn, etc
     */
    case nudity
    /**
     * Virus, trojan horse, worm, robot, spyware, adware, back door, ransomware, rootkit, kidnapper, etc.
     */
    case malware
    /**
     * Profanity, hateful speech, etc.
     */
    case profanity
    /**
     * Something which may be illegal in some jurisdiction
     *
     * Remember: there is what is right and there is the law.
     */
    case illegal
    /**
     * Spam
     */
    case spam
    /**
     * Someone pretending to be someone else
     */
    case impersonation
    /**
     * Reports that don't fit in the above categories
     */
    case other
}


#if compiler(>=6)
extension Report: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReport: FfiConverterRustBuffer {
    typealias SwiftType = Report

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Report {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nudity
        
        case 2: return .malware
        
        case 3: return .profanity
        
        case 4: return .illegal
        
        case 5: return .spam
        
        case 6: return .impersonation
        
        case 7: return .other
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Report, into buf: inout [UInt8]) {
        switch value {
        
        
        case .nudity:
            writeInt(&buf, Int32(1))
        
        
        case .malware:
            writeInt(&buf, Int32(2))
        
        
        case .profanity:
            writeInt(&buf, Int32(3))
        
        
        case .illegal:
            writeInt(&buf, Int32(4))
        
        
        case .spam:
            writeInt(&buf, Int32(5))
        
        
        case .impersonation:
            writeInt(&buf, Int32(6))
        
        
        case .other:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReport_lift(_ buf: RustBuffer) throws -> Report {
    return try FfiConverterTypeReport.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReport_lower(_ value: Report) -> RustBuffer {
    return FfiConverterTypeReport.lower(value)
}


extension Report: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Request (REQ) exit policy
 */

public enum ReqExitPolicy {
    
    /**
     * Exit on EOSE
     */
    case exitOnEose
    /**
     * Wait to receive N events and then exit.
     */
    case waitForEvents(num: UInt16
    )
    /**
     * After EOSE is received, keep listening for N more events that match the filter.
     */
    case waitForEventsAfterEose(num: UInt16
    )
    /**
     * After EOSE is received, keep listening for matching events for `Duration` more time.
     */
    case waitDurationAfterEose(duration: TimeInterval
    )
}


#if compiler(>=6)
extension ReqExitPolicy: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReqExitPolicy: FfiConverterRustBuffer {
    typealias SwiftType = ReqExitPolicy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReqExitPolicy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .exitOnEose
        
        case 2: return .waitForEvents(num: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 3: return .waitForEventsAfterEose(num: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 4: return .waitDurationAfterEose(duration: try FfiConverterDuration.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReqExitPolicy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .exitOnEose:
            writeInt(&buf, Int32(1))
        
        
        case let .waitForEvents(num):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(num, into: &buf)
            
        
        case let .waitForEventsAfterEose(num):
            writeInt(&buf, Int32(3))
            FfiConverterUInt16.write(num, into: &buf)
            
        
        case let .waitDurationAfterEose(duration):
            writeInt(&buf, Int32(4))
            FfiConverterDuration.write(duration, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReqExitPolicy_lift(_ buf: RustBuffer) throws -> ReqExitPolicy {
    return try FfiConverterTypeReqExitPolicy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReqExitPolicy_lower(_ value: ReqExitPolicy) -> RustBuffer {
    return FfiConverterTypeReqExitPolicy.lower(value)
}


extension ReqExitPolicy: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Nostr Wallet Connect Request Params
 */

public enum RequestParams {
    
    /**
     * Pay Invoice
     */
    case payInvoice(payInvoice: PayInvoiceRequest
    )
    /**
     * Multi Pay Invoice
     */
    case multiPayInvoice(multiPayInvoice: MultiPayInvoiceRequest
    )
    /**
     * Pay Keysend
     */
    case payKeysend(payKeysend: PayKeysendRequest
    )
    /**
     * Multi Pay Keysend
     */
    case multiPayKeysend(multiPayKeysend: MultiPayKeysendRequest
    )
    /**
     * Make Invoice
     */
    case makeInvoice(makeInvoice: MakeInvoiceRequest
    )
    /**
     * Lookup Invoice
     */
    case lookupInvoice(lookupInvoice: LookupInvoiceRequest
    )
    /**
     * List Transactions
     */
    case listTransactions(listTransactions: ListTransactionsRequest
    )
    /**
     * Get Balance
     */
    case getBalance
    /**
     * Get Info
     */
    case getInfo
    /**
     * Make Hold Invoice
     */
    case makeHoldInvoice(req: MakeHoldInvoiceRequest
    )
    /**
     * Cancel Hold Invoice
     */
    case cancelHoldInvoice(req: CancelHoldInvoiceRequest
    )
    /**
     * Settle Hold Invoice
     */
    case settleHoldInvoice(req: SettleHoldInvoiceRequest
    )
}


#if compiler(>=6)
extension RequestParams: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequestParams: FfiConverterRustBuffer {
    typealias SwiftType = RequestParams

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestParams {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .payInvoice(payInvoice: try FfiConverterTypePayInvoiceRequest.read(from: &buf)
        )
        
        case 2: return .multiPayInvoice(multiPayInvoice: try FfiConverterTypeMultiPayInvoiceRequest.read(from: &buf)
        )
        
        case 3: return .payKeysend(payKeysend: try FfiConverterTypePayKeysendRequest.read(from: &buf)
        )
        
        case 4: return .multiPayKeysend(multiPayKeysend: try FfiConverterTypeMultiPayKeysendRequest.read(from: &buf)
        )
        
        case 5: return .makeInvoice(makeInvoice: try FfiConverterTypeMakeInvoiceRequest.read(from: &buf)
        )
        
        case 6: return .lookupInvoice(lookupInvoice: try FfiConverterTypeLookupInvoiceRequest.read(from: &buf)
        )
        
        case 7: return .listTransactions(listTransactions: try FfiConverterTypeListTransactionsRequest.read(from: &buf)
        )
        
        case 8: return .getBalance
        
        case 9: return .getInfo
        
        case 10: return .makeHoldInvoice(req: try FfiConverterTypeMakeHoldInvoiceRequest.read(from: &buf)
        )
        
        case 11: return .cancelHoldInvoice(req: try FfiConverterTypeCancelHoldInvoiceRequest.read(from: &buf)
        )
        
        case 12: return .settleHoldInvoice(req: try FfiConverterTypeSettleHoldInvoiceRequest.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestParams, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .payInvoice(payInvoice):
            writeInt(&buf, Int32(1))
            FfiConverterTypePayInvoiceRequest.write(payInvoice, into: &buf)
            
        
        case let .multiPayInvoice(multiPayInvoice):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMultiPayInvoiceRequest.write(multiPayInvoice, into: &buf)
            
        
        case let .payKeysend(payKeysend):
            writeInt(&buf, Int32(3))
            FfiConverterTypePayKeysendRequest.write(payKeysend, into: &buf)
            
        
        case let .multiPayKeysend(multiPayKeysend):
            writeInt(&buf, Int32(4))
            FfiConverterTypeMultiPayKeysendRequest.write(multiPayKeysend, into: &buf)
            
        
        case let .makeInvoice(makeInvoice):
            writeInt(&buf, Int32(5))
            FfiConverterTypeMakeInvoiceRequest.write(makeInvoice, into: &buf)
            
        
        case let .lookupInvoice(lookupInvoice):
            writeInt(&buf, Int32(6))
            FfiConverterTypeLookupInvoiceRequest.write(lookupInvoice, into: &buf)
            
        
        case let .listTransactions(listTransactions):
            writeInt(&buf, Int32(7))
            FfiConverterTypeListTransactionsRequest.write(listTransactions, into: &buf)
            
        
        case .getBalance:
            writeInt(&buf, Int32(8))
        
        
        case .getInfo:
            writeInt(&buf, Int32(9))
        
        
        case let .makeHoldInvoice(req):
            writeInt(&buf, Int32(10))
            FfiConverterTypeMakeHoldInvoiceRequest.write(req, into: &buf)
            
        
        case let .cancelHoldInvoice(req):
            writeInt(&buf, Int32(11))
            FfiConverterTypeCancelHoldInvoiceRequest.write(req, into: &buf)
            
        
        case let .settleHoldInvoice(req):
            writeInt(&buf, Int32(12))
            FfiConverterTypeSettleHoldInvoiceRequest.write(req, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestParams_lift(_ buf: RustBuffer) throws -> RequestParams {
    return try FfiConverterTypeRequestParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestParams_lower(_ value: RequestParams) -> RustBuffer {
    return FfiConverterTypeRequestParams.lower(value)
}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * NIP47 Response Result
 */

public enum ResponseResult {
    
    /**
     * Pay Invoice
     */
    case payInvoice(payInvoice: PayInvoiceResponse
    )
    /**
     * Multi Pay Invoice
     */
    case multiPayInvoice(payInvoice: PayInvoiceResponse
    )
    /**
     * Pay Keysend
     */
    case payKeysend(payKeysend: PayKeysendResponse
    )
    /**
     * Multi Pay Keysend
     */
    case multiPayKeysend(payKeysend: PayKeysendResponse
    )
    /**
     * Make Invoice
     */
    case makeInvoice(makeInvoice: MakeInvoiceResponse
    )
    /**
     * Lookup Invoice
     */
    case lookupInvoice(lookupInvoice: LookupInvoiceResponse
    )
    /**
     * List Transactions
     */
    case listTransactions(listTransactions: [LookupInvoiceResponse]
    )
    /**
     * Get Balance
     */
    case getBalance(getBalance: GetBalanceResponse
    )
    /**
     * Get Info
     */
    case getInfo(getInfo: GetInfoResponse
    )
    /**
     * Make Hold Invoice
     */
    case makeHoldInvoice(res: MakeHoldInvoiceResponse
    )
    /**
     * Cancel Hold Invoice
     */
    case cancelHoldInvoice(res: CancelHoldInvoiceResponse
    )
    /**
     * Settle Hold Invoice
     */
    case settleHoldInvoice(res: SettleHoldInvoiceResponse
    )
}


#if compiler(>=6)
extension ResponseResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResponseResult: FfiConverterRustBuffer {
    typealias SwiftType = ResponseResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResponseResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .payInvoice(payInvoice: try FfiConverterTypePayInvoiceResponse.read(from: &buf)
        )
        
        case 2: return .multiPayInvoice(payInvoice: try FfiConverterTypePayInvoiceResponse.read(from: &buf)
        )
        
        case 3: return .payKeysend(payKeysend: try FfiConverterTypePayKeysendResponse.read(from: &buf)
        )
        
        case 4: return .multiPayKeysend(payKeysend: try FfiConverterTypePayKeysendResponse.read(from: &buf)
        )
        
        case 5: return .makeInvoice(makeInvoice: try FfiConverterTypeMakeInvoiceResponse.read(from: &buf)
        )
        
        case 6: return .lookupInvoice(lookupInvoice: try FfiConverterTypeLookupInvoiceResponse.read(from: &buf)
        )
        
        case 7: return .listTransactions(listTransactions: try FfiConverterSequenceTypeLookupInvoiceResponse.read(from: &buf)
        )
        
        case 8: return .getBalance(getBalance: try FfiConverterTypeGetBalanceResponse.read(from: &buf)
        )
        
        case 9: return .getInfo(getInfo: try FfiConverterTypeGetInfoResponse.read(from: &buf)
        )
        
        case 10: return .makeHoldInvoice(res: try FfiConverterTypeMakeHoldInvoiceResponse.read(from: &buf)
        )
        
        case 11: return .cancelHoldInvoice(res: try FfiConverterTypeCancelHoldInvoiceResponse.read(from: &buf)
        )
        
        case 12: return .settleHoldInvoice(res: try FfiConverterTypeSettleHoldInvoiceResponse.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResponseResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .payInvoice(payInvoice):
            writeInt(&buf, Int32(1))
            FfiConverterTypePayInvoiceResponse.write(payInvoice, into: &buf)
            
        
        case let .multiPayInvoice(payInvoice):
            writeInt(&buf, Int32(2))
            FfiConverterTypePayInvoiceResponse.write(payInvoice, into: &buf)
            
        
        case let .payKeysend(payKeysend):
            writeInt(&buf, Int32(3))
            FfiConverterTypePayKeysendResponse.write(payKeysend, into: &buf)
            
        
        case let .multiPayKeysend(payKeysend):
            writeInt(&buf, Int32(4))
            FfiConverterTypePayKeysendResponse.write(payKeysend, into: &buf)
            
        
        case let .makeInvoice(makeInvoice):
            writeInt(&buf, Int32(5))
            FfiConverterTypeMakeInvoiceResponse.write(makeInvoice, into: &buf)
            
        
        case let .lookupInvoice(lookupInvoice):
            writeInt(&buf, Int32(6))
            FfiConverterTypeLookupInvoiceResponse.write(lookupInvoice, into: &buf)
            
        
        case let .listTransactions(listTransactions):
            writeInt(&buf, Int32(7))
            FfiConverterSequenceTypeLookupInvoiceResponse.write(listTransactions, into: &buf)
            
        
        case let .getBalance(getBalance):
            writeInt(&buf, Int32(8))
            FfiConverterTypeGetBalanceResponse.write(getBalance, into: &buf)
            
        
        case let .getInfo(getInfo):
            writeInt(&buf, Int32(9))
            FfiConverterTypeGetInfoResponse.write(getInfo, into: &buf)
            
        
        case let .makeHoldInvoice(res):
            writeInt(&buf, Int32(10))
            FfiConverterTypeMakeHoldInvoiceResponse.write(res, into: &buf)
            
        
        case let .cancelHoldInvoice(res):
            writeInt(&buf, Int32(11))
            FfiConverterTypeCancelHoldInvoiceResponse.write(res, into: &buf)
            
        
        case let .settleHoldInvoice(res):
            writeInt(&buf, Int32(12))
            FfiConverterTypeSettleHoldInvoiceResponse.write(res, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResponseResult_lift(_ buf: RustBuffer) throws -> ResponseResult {
    return try FfiConverterTypeResponseResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResponseResult_lower(_ value: ResponseResult) -> RustBuffer {
    return FfiConverterTypeResponseResult.lower(value)
}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RetentionKind {
    
    case single(single: UInt64
    )
    case range(start: UInt64, end: UInt64
    )
}


#if compiler(>=6)
extension RetentionKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRetentionKind: FfiConverterRustBuffer {
    typealias SwiftType = RetentionKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetentionKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .single(single: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .range(start: try FfiConverterUInt64.read(from: &buf), end: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RetentionKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .single(single):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(single, into: &buf)
            
        
        case let .range(start,end):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(start, into: &buf)
            FfiConverterUInt64.write(end, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRetentionKind_lift(_ buf: RustBuffer) throws -> RetentionKind {
    return try FfiConverterTypeRetentionKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRetentionKind_lower(_ value: RetentionKind) -> RustBuffer {
    return FfiConverterTypeRetentionKind.lower(value)
}


extension RetentionKind: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SignerBackend {
    
    /**
     * Secret key
     */
    case keys
    /**
     * Browser extension (NIP07)
     *
     * <https://github.com/nostr-protocol/nips/blob/master/07.md>
     */
    case browserExtension
    /**
     * Nostr Connect (NIP46)
     *
     * <https://github.com/nostr-protocol/nips/blob/master/46.md>
     */
    case nostrConnect
    /**
     * Custom
     */
    case custom(backend: String
    )
}


#if compiler(>=6)
extension SignerBackend: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignerBackend: FfiConverterRustBuffer {
    typealias SwiftType = SignerBackend

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignerBackend {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .keys
        
        case 2: return .browserExtension
        
        case 3: return .nostrConnect
        
        case 4: return .custom(backend: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignerBackend, into buf: inout [UInt8]) {
        switch value {
        
        
        case .keys:
            writeInt(&buf, Int32(1))
        
        
        case .browserExtension:
            writeInt(&buf, Int32(2))
        
        
        case .nostrConnect:
            writeInt(&buf, Int32(3))
        
        
        case let .custom(backend):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(backend, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignerBackend_lift(_ buf: RustBuffer) throws -> SignerBackend {
    return try FfiConverterTypeSignerBackend.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignerBackend_lower(_ value: SignerBackend) -> RustBuffer {
    return FfiConverterTypeSignerBackend.lower(value)
}


extension SignerBackend: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SyncDirection {
    
    case up
    case down
    case both
}


#if compiler(>=6)
extension SyncDirection: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncDirection: FfiConverterRustBuffer {
    typealias SwiftType = SyncDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .up
        
        case 2: return .down
        
        case 3: return .both
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SyncDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .up:
            writeInt(&buf, Int32(1))
        
        
        case .down:
            writeInt(&buf, Int32(2))
        
        
        case .both:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncDirection_lift(_ buf: RustBuffer) throws -> SyncDirection {
    return try FfiConverterTypeSyncDirection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncDirection_lower(_ value: SyncDirection) -> RustBuffer {
    return FfiConverterTypeSyncDirection.lower(value)
}


extension SyncDirection: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TagKind {
    
    /**
     * Human-readable plaintext summary of what that event is about
     *
     * <https://github.com/nostr-protocol/nips/blob/master/31.md>
     */
    case alt
    /**
     * Client
     *
     * <https://github.com/nostr-protocol/nips/blob/master/89.md>
     */
    case client
    /**
     * Commit
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
    case commit
    /**
     * Required dependency
     *
     * <https://github.com/nostr-protocol/nips/blob/master/C0.md>
     */
    case dependency
    /**
     * File extension
     *
     * <https://github.com/nostr-protocol/nips/blob/master/C0.md>
     */
    case `extension`
    /**
     * License of the shared content
     *
     * <https://github.com/nostr-protocol/nips/blob/master/C0.md>
     */
    case license
    /**
     * Maintainers
     */
    case maintainers
    /**
     * Protected event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/70.md>
     */
    case protected
    /**
     * Relay
     */
    case relayUrl
    /**
     * Nonce
     */
    case nonce
    /**
     * Content warning
     */
    case contentWarning
    /**
     * Expiration
     */
    case expiration
    /**
     * Subject
     */
    case subject
    /**
     * Auth challenge
     */
    case challenge
    /**
     * Title (NIP23)
     */
    case title
    /**
     * Image (NIP23)
     */
    case image
    /**
     * Thumbnail
     */
    case thumb
    /**
     * Summary (NIP23)
     */
    case summary
    /**
     * PublishedAt (NIP23)
     */
    case publishedAt
    /**
     * Description (NIP57)
     */
    case description
    /**
     * Bolt11 Invoice (NIP57)
     */
    case bolt11
    /**
     * Preimage (NIP57)
     */
    case preimage
    /**
     * Relays (NIP57)
     */
    case relays
    /**
     * Amount (NIP57)
     */
    case amount
    /**
     * Lnurl (NIP57)
     */
    case lnurl
    /**
     * MLS Protocol Version (NIP104)
     */
    case mlsProtocolVersion
    /**
     * MLS Cipher Suite (NIP104)
     */
    case mlsCiphersuite
    /**
     * MLS Extensions (NIP104)
     */
    case mlsExtensions
    /**
     * Name tag
     */
    case name
    /**
     * Option
     */
    case option
    /**
     * Url
     */
    case url
    /**
     * AES 256 GCM
     */
    case aes256Gcm
    /**
     * Size of file in bytes
     */
    case size
    /**
     * Size of file in pixels
     */
    case dim
    case file
    /**
     * Magnet
     */
    case magnet
    /**
     * Blurhash
     */
    case blurhash
    /**
     * Streaming
     */
    case streaming
    /**
     * Recording
     */
    case recording
    /**
     * Server
     */
    case server
    /**
     * Starts
     */
    case starts
    /**
     * Ends
     */
    case ends
    /**
     * Status
     */
    case status
    /**
     * Current participants
     */
    case currentParticipants
    /**
     * Total participants
     */
    case totalParticipants
    case tracker
    /**
     * HTTP Method Request
     */
    case method
    /**
     * Payload HASH
     */
    case payload
    case anon
    case proxy
    case emoji
    /**
     * Encrypted
     */
    case encrypted
    /**
     * Reference to the origin repository
     *
     * <https://github.com/nostr-protocol/nips/blob/master/C0.md>
     */
    case repository
    /**
     * Request
     */
    case request
    /**
     * Runtime or environment specification
     *
     * <https://github.com/nostr-protocol/nips/blob/master/C0.md>
     */
    case runtime
    case pollType
    case response
    case web
    case word
    case head
    case singleLetter(singleLetter: SingleLetterTag
    )
    case unknown(unknown: String
    )
}


#if compiler(>=6)
extension TagKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTagKind: FfiConverterRustBuffer {
    typealias SwiftType = TagKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TagKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .alt
        
        case 2: return .client
        
        case 3: return .commit
        
        case 4: return .dependency
        
        case 5: return .`extension`
        
        case 6: return .license
        
        case 7: return .maintainers
        
        case 8: return .protected
        
        case 9: return .relayUrl
        
        case 10: return .nonce
        
        case 11: return .contentWarning
        
        case 12: return .expiration
        
        case 13: return .subject
        
        case 14: return .challenge
        
        case 15: return .title
        
        case 16: return .image
        
        case 17: return .thumb
        
        case 18: return .summary
        
        case 19: return .publishedAt
        
        case 20: return .description
        
        case 21: return .bolt11
        
        case 22: return .preimage
        
        case 23: return .relays
        
        case 24: return .amount
        
        case 25: return .lnurl
        
        case 26: return .mlsProtocolVersion
        
        case 27: return .mlsCiphersuite
        
        case 28: return .mlsExtensions
        
        case 29: return .name
        
        case 30: return .option
        
        case 31: return .url
        
        case 32: return .aes256Gcm
        
        case 33: return .size
        
        case 34: return .dim
        
        case 35: return .file
        
        case 36: return .magnet
        
        case 37: return .blurhash
        
        case 38: return .streaming
        
        case 39: return .recording
        
        case 40: return .server
        
        case 41: return .starts
        
        case 42: return .ends
        
        case 43: return .status
        
        case 44: return .currentParticipants
        
        case 45: return .totalParticipants
        
        case 46: return .tracker
        
        case 47: return .method
        
        case 48: return .payload
        
        case 49: return .anon
        
        case 50: return .proxy
        
        case 51: return .emoji
        
        case 52: return .encrypted
        
        case 53: return .repository
        
        case 54: return .request
        
        case 55: return .runtime
        
        case 56: return .pollType
        
        case 57: return .response
        
        case 58: return .web
        
        case 59: return .word
        
        case 60: return .head
        
        case 61: return .singleLetter(singleLetter: try FfiConverterTypeSingleLetterTag.read(from: &buf)
        )
        
        case 62: return .unknown(unknown: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TagKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .alt:
            writeInt(&buf, Int32(1))
        
        
        case .client:
            writeInt(&buf, Int32(2))
        
        
        case .commit:
            writeInt(&buf, Int32(3))
        
        
        case .dependency:
            writeInt(&buf, Int32(4))
        
        
        case .`extension`:
            writeInt(&buf, Int32(5))
        
        
        case .license:
            writeInt(&buf, Int32(6))
        
        
        case .maintainers:
            writeInt(&buf, Int32(7))
        
        
        case .protected:
            writeInt(&buf, Int32(8))
        
        
        case .relayUrl:
            writeInt(&buf, Int32(9))
        
        
        case .nonce:
            writeInt(&buf, Int32(10))
        
        
        case .contentWarning:
            writeInt(&buf, Int32(11))
        
        
        case .expiration:
            writeInt(&buf, Int32(12))
        
        
        case .subject:
            writeInt(&buf, Int32(13))
        
        
        case .challenge:
            writeInt(&buf, Int32(14))
        
        
        case .title:
            writeInt(&buf, Int32(15))
        
        
        case .image:
            writeInt(&buf, Int32(16))
        
        
        case .thumb:
            writeInt(&buf, Int32(17))
        
        
        case .summary:
            writeInt(&buf, Int32(18))
        
        
        case .publishedAt:
            writeInt(&buf, Int32(19))
        
        
        case .description:
            writeInt(&buf, Int32(20))
        
        
        case .bolt11:
            writeInt(&buf, Int32(21))
        
        
        case .preimage:
            writeInt(&buf, Int32(22))
        
        
        case .relays:
            writeInt(&buf, Int32(23))
        
        
        case .amount:
            writeInt(&buf, Int32(24))
        
        
        case .lnurl:
            writeInt(&buf, Int32(25))
        
        
        case .mlsProtocolVersion:
            writeInt(&buf, Int32(26))
        
        
        case .mlsCiphersuite:
            writeInt(&buf, Int32(27))
        
        
        case .mlsExtensions:
            writeInt(&buf, Int32(28))
        
        
        case .name:
            writeInt(&buf, Int32(29))
        
        
        case .option:
            writeInt(&buf, Int32(30))
        
        
        case .url:
            writeInt(&buf, Int32(31))
        
        
        case .aes256Gcm:
            writeInt(&buf, Int32(32))
        
        
        case .size:
            writeInt(&buf, Int32(33))
        
        
        case .dim:
            writeInt(&buf, Int32(34))
        
        
        case .file:
            writeInt(&buf, Int32(35))
        
        
        case .magnet:
            writeInt(&buf, Int32(36))
        
        
        case .blurhash:
            writeInt(&buf, Int32(37))
        
        
        case .streaming:
            writeInt(&buf, Int32(38))
        
        
        case .recording:
            writeInt(&buf, Int32(39))
        
        
        case .server:
            writeInt(&buf, Int32(40))
        
        
        case .starts:
            writeInt(&buf, Int32(41))
        
        
        case .ends:
            writeInt(&buf, Int32(42))
        
        
        case .status:
            writeInt(&buf, Int32(43))
        
        
        case .currentParticipants:
            writeInt(&buf, Int32(44))
        
        
        case .totalParticipants:
            writeInt(&buf, Int32(45))
        
        
        case .tracker:
            writeInt(&buf, Int32(46))
        
        
        case .method:
            writeInt(&buf, Int32(47))
        
        
        case .payload:
            writeInt(&buf, Int32(48))
        
        
        case .anon:
            writeInt(&buf, Int32(49))
        
        
        case .proxy:
            writeInt(&buf, Int32(50))
        
        
        case .emoji:
            writeInt(&buf, Int32(51))
        
        
        case .encrypted:
            writeInt(&buf, Int32(52))
        
        
        case .repository:
            writeInt(&buf, Int32(53))
        
        
        case .request:
            writeInt(&buf, Int32(54))
        
        
        case .runtime:
            writeInt(&buf, Int32(55))
        
        
        case .pollType:
            writeInt(&buf, Int32(56))
        
        
        case .response:
            writeInt(&buf, Int32(57))
        
        
        case .web:
            writeInt(&buf, Int32(58))
        
        
        case .word:
            writeInt(&buf, Int32(59))
        
        
        case .head:
            writeInt(&buf, Int32(60))
        
        
        case let .singleLetter(singleLetter):
            writeInt(&buf, Int32(61))
            FfiConverterTypeSingleLetterTag.write(singleLetter, into: &buf)
            
        
        case let .unknown(unknown):
            writeInt(&buf, Int32(62))
            FfiConverterString.write(unknown, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTagKind_lift(_ buf: RustBuffer) throws -> TagKind {
    return try FfiConverterTypeTagKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTagKind_lower(_ value: TagKind) -> RustBuffer {
    return FfiConverterTypeTagKind.lower(value)
}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Standardized tag
 */

public enum TagStandard {
    
    case eventTag(eventId: EventId, relayUrl: RelayUrl?, marker: Marker?, 
        /**
         * Should be the public key of the author of the referenced event
         */publicKey: PublicKey?, 
        /**
         * Whether the e tag is an uppercase E or not
         */uppercase: Bool
    )
    case quote(eventId: EventId, relayUrl: RelayUrl?, 
        /**
         * Should be the public key of the author of the referenced event
         */publicKey: PublicKey?
    )
    case quoteAddress(coordinate: Coordinate, relayUrl: RelayUrl?
    )
    /**
     * Git clone (`clone` tag)
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
    case gitClone(urls: [String]
    )
    /**
     * Git commit
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
    case gitCommit(hash: String
    )
    /**
     * Git earliest unique commit ID
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
    case gitEarliestUniqueCommitId(commit: String
    )
    /**
     * Git repo maintainers
     *
     * <https://github.com/nostr-protocol/nips/blob/master/34.md>
     */
    case gitMaintainers(publicKeys: [PublicKey]
    )
    case gitHead(head: String
    )
    case publicKeyTag(publicKey: PublicKey, relayUrl: RelayUrl?, alias: String?, 
        /**
         * Whether the p tag is an uppercase P or not
         */uppercase: Bool
    )
    case eventReport(eventId: EventId, report: Report
    )
    case pubKeyReport(publicKey: PublicKey, report: Report
    )
    case publicKeyLiveEvent(publicKey: PublicKey, relayUrl: RelayUrl?, marker: LiveEventMarker, proof: String?
    )
    case reference(reference: String
    )
    case relayMetadataTag(relayUrl: RelayUrl, rw: RelayMetadata?
    )
    case hashtag(hashtag: String
    )
    case geohash(geohash: String
    )
    case identifier(identifier: String
    )
    case externalContent(content: ExternalContentId, 
        /**
         * Hint URL
         */hint: String?, uppercase: Bool
    )
    case externalIdentity(identity: Identity
    )
    case coordinateTag(coordinate: Coordinate, relayUrl: RelayUrl?, 
        /**
         * Whether the a tag is an uppercase A or not
         */uppercase: Bool
    )
    case kindTag(kind: Kind, 
        /**
         * Whether the k tag is an uppercase K or not
         */uppercase: Bool
    )
    case nip73KindTag(kind: Nip73Kind, 
        /**
         * Whether the tag is an uppercase or not
         */uppercase: Bool
    )
    case relay(url: RelayUrl
    )
    /**
     * All relays tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/62.md>
     */
    case allRelays
    case pow(nonce: String, difficulty: UInt8
    )
    case client(name: String, address: TagClientAddress?
    )
    case contentWarning(reason: String?
    )
    case expiration(timestamp: Timestamp
    )
    case subject(subject: String
    )
    case challenge(challenge: String
    )
    case title(title: String
    )
    case image(url: String, dimensions: ImageDimensions?
    )
    case thumb(url: String, dimensions: ImageDimensions?
    )
    case summary(summary: String
    )
    case description(desc: String
    )
    case bolt11(bolt11: String
    )
    case preimage(preimage: String
    )
    case relays(urls: [RelayUrl]
    )
    case amount(millisats: UInt64, bolt11: String?
    )
    case lnurl(lnurl: String
    )
    case name(name: String
    )
    case publishedAt(timestamp: Timestamp
    )
    case urlTag(url: String
    )
    case mimeType(mime: String
    )
    case aes256Gcm(key: String, iv: String
    )
    case server(url: String
    )
    case sha256(hash: String
    )
    case size(size: UInt64
    )
    /**
     * Size of file in pixels
     */
    case dim(dimensions: ImageDimensions
    )
    case magnet(uri: String
    )
    case blurhash(blurhash: String
    )
    case streaming(url: String
    )
    case recording(url: String
    )
    case starts(timestamp: Timestamp
    )
    case ends(timestamp: Timestamp
    )
    case liveEventStatusTag(status: LiveEventStatus
    )
    case currentParticipants(num: UInt64
    )
    case totalParticipants(num: UInt64
    )
    case absoluteUrl(url: String
    )
    case method(method: HttpMethod
    )
    case payload(hash: String
    )
    case anon(msg: String?
    )
    case proxy(id: String, `protocol`: Protocol
    )
    case emoji(shortcode: String, url: String
    )
    case encrypted
    case request(event: Event
    )
    case dataVendingMachineStatusTag(status: DataVendingMachineStatus, extraInfo: String?
    )
    case labelNamespace(namespace: String
    )
    case label(value: String, namespace: String?
    )
    /**
     * Protected event
     *
     * <https://github.com/nostr-protocol/nips/blob/master/70.md>
     */
    case protected
    /**
     * A short human-readable plaintext summary of what that event is about
     *
     * <https://github.com/nostr-protocol/nips/blob/master/31.md>
     */
    case alt(summary: String
    )
    case word(word: String
    )
    case web(urls: [String]
    )
    /**
     * Required dependency
     *
     * <https://github.com/nostr-protocol/nips/blob/master/C0.md>
     */
    case dependency(dep: String
    )
    /**
     * File extension
     *
     * <https://github.com/nostr-protocol/nips/blob/master/C0.md>
     */
    case `extension`(ext: String
    )
    /**
     * License of the shared content
     *
     * <https://github.com/nostr-protocol/nips/blob/master/C0.md>
     */
    case license(license: String
    )
    /**
     * Runtime or environment specification
     *
     * <https://github.com/nostr-protocol/nips/blob/master/C0.md>
     */
    case runtime(runtime: String
    )
    /**
     * Reference to the origin repository
     *
     * <https://github.com/nostr-protocol/nips/blob/master/C0.md>
     */
    case repository(url: String
    )
    case nip88PollEndsAt(timestamp: Timestamp
    )
    case nip88PollOption(option: PollOption
    )
    case nip88PollResponse(response: String
    )
    case nip88PollType(pollType: PollType
    )
}


#if compiler(>=6)
extension TagStandard: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTagStandard: FfiConverterRustBuffer {
    typealias SwiftType = TagStandard

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TagStandard {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventTag(eventId: try FfiConverterTypeEventId.read(from: &buf), relayUrl: try FfiConverterOptionTypeRelayUrl.read(from: &buf), marker: try FfiConverterOptionTypeMarker.read(from: &buf), publicKey: try FfiConverterOptionTypePublicKey.read(from: &buf), uppercase: try FfiConverterBool.read(from: &buf)
        )
        
        case 2: return .quote(eventId: try FfiConverterTypeEventId.read(from: &buf), relayUrl: try FfiConverterOptionTypeRelayUrl.read(from: &buf), publicKey: try FfiConverterOptionTypePublicKey.read(from: &buf)
        )
        
        case 3: return .quoteAddress(coordinate: try FfiConverterTypeCoordinate.read(from: &buf), relayUrl: try FfiConverterOptionTypeRelayUrl.read(from: &buf)
        )
        
        case 4: return .gitClone(urls: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 5: return .gitCommit(hash: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .gitEarliestUniqueCommitId(commit: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .gitMaintainers(publicKeys: try FfiConverterSequenceTypePublicKey.read(from: &buf)
        )
        
        case 8: return .gitHead(head: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .publicKeyTag(publicKey: try FfiConverterTypePublicKey.read(from: &buf), relayUrl: try FfiConverterOptionTypeRelayUrl.read(from: &buf), alias: try FfiConverterOptionString.read(from: &buf), uppercase: try FfiConverterBool.read(from: &buf)
        )
        
        case 10: return .eventReport(eventId: try FfiConverterTypeEventId.read(from: &buf), report: try FfiConverterTypeReport.read(from: &buf)
        )
        
        case 11: return .pubKeyReport(publicKey: try FfiConverterTypePublicKey.read(from: &buf), report: try FfiConverterTypeReport.read(from: &buf)
        )
        
        case 12: return .publicKeyLiveEvent(publicKey: try FfiConverterTypePublicKey.read(from: &buf), relayUrl: try FfiConverterOptionTypeRelayUrl.read(from: &buf), marker: try FfiConverterTypeLiveEventMarker.read(from: &buf), proof: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 13: return .reference(reference: try FfiConverterString.read(from: &buf)
        )
        
        case 14: return .relayMetadataTag(relayUrl: try FfiConverterTypeRelayUrl.read(from: &buf), rw: try FfiConverterOptionTypeRelayMetadata.read(from: &buf)
        )
        
        case 15: return .hashtag(hashtag: try FfiConverterString.read(from: &buf)
        )
        
        case 16: return .geohash(geohash: try FfiConverterString.read(from: &buf)
        )
        
        case 17: return .identifier(identifier: try FfiConverterString.read(from: &buf)
        )
        
        case 18: return .externalContent(content: try FfiConverterTypeExternalContentId.read(from: &buf), hint: try FfiConverterOptionString.read(from: &buf), uppercase: try FfiConverterBool.read(from: &buf)
        )
        
        case 19: return .externalIdentity(identity: try FfiConverterTypeIdentity.read(from: &buf)
        )
        
        case 20: return .coordinateTag(coordinate: try FfiConverterTypeCoordinate.read(from: &buf), relayUrl: try FfiConverterOptionTypeRelayUrl.read(from: &buf), uppercase: try FfiConverterBool.read(from: &buf)
        )
        
        case 21: return .kindTag(kind: try FfiConverterTypeKind.read(from: &buf), uppercase: try FfiConverterBool.read(from: &buf)
        )
        
        case 22: return .nip73KindTag(kind: try FfiConverterTypeNip73Kind.read(from: &buf), uppercase: try FfiConverterBool.read(from: &buf)
        )
        
        case 23: return .relay(url: try FfiConverterTypeRelayUrl.read(from: &buf)
        )
        
        case 24: return .allRelays
        
        case 25: return .pow(nonce: try FfiConverterString.read(from: &buf), difficulty: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 26: return .client(name: try FfiConverterString.read(from: &buf), address: try FfiConverterOptionTypeTagClientAddress.read(from: &buf)
        )
        
        case 27: return .contentWarning(reason: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 28: return .expiration(timestamp: try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 29: return .subject(subject: try FfiConverterString.read(from: &buf)
        )
        
        case 30: return .challenge(challenge: try FfiConverterString.read(from: &buf)
        )
        
        case 31: return .title(title: try FfiConverterString.read(from: &buf)
        )
        
        case 32: return .image(url: try FfiConverterString.read(from: &buf), dimensions: try FfiConverterOptionTypeImageDimensions.read(from: &buf)
        )
        
        case 33: return .thumb(url: try FfiConverterString.read(from: &buf), dimensions: try FfiConverterOptionTypeImageDimensions.read(from: &buf)
        )
        
        case 34: return .summary(summary: try FfiConverterString.read(from: &buf)
        )
        
        case 35: return .description(desc: try FfiConverterString.read(from: &buf)
        )
        
        case 36: return .bolt11(bolt11: try FfiConverterString.read(from: &buf)
        )
        
        case 37: return .preimage(preimage: try FfiConverterString.read(from: &buf)
        )
        
        case 38: return .relays(urls: try FfiConverterSequenceTypeRelayUrl.read(from: &buf)
        )
        
        case 39: return .amount(millisats: try FfiConverterUInt64.read(from: &buf), bolt11: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 40: return .lnurl(lnurl: try FfiConverterString.read(from: &buf)
        )
        
        case 41: return .name(name: try FfiConverterString.read(from: &buf)
        )
        
        case 42: return .publishedAt(timestamp: try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 43: return .urlTag(url: try FfiConverterString.read(from: &buf)
        )
        
        case 44: return .mimeType(mime: try FfiConverterString.read(from: &buf)
        )
        
        case 45: return .aes256Gcm(key: try FfiConverterString.read(from: &buf), iv: try FfiConverterString.read(from: &buf)
        )
        
        case 46: return .server(url: try FfiConverterString.read(from: &buf)
        )
        
        case 47: return .sha256(hash: try FfiConverterString.read(from: &buf)
        )
        
        case 48: return .size(size: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 49: return .dim(dimensions: try FfiConverterTypeImageDimensions.read(from: &buf)
        )
        
        case 50: return .magnet(uri: try FfiConverterString.read(from: &buf)
        )
        
        case 51: return .blurhash(blurhash: try FfiConverterString.read(from: &buf)
        )
        
        case 52: return .streaming(url: try FfiConverterString.read(from: &buf)
        )
        
        case 53: return .recording(url: try FfiConverterString.read(from: &buf)
        )
        
        case 54: return .starts(timestamp: try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 55: return .ends(timestamp: try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 56: return .liveEventStatusTag(status: try FfiConverterTypeLiveEventStatus.read(from: &buf)
        )
        
        case 57: return .currentParticipants(num: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 58: return .totalParticipants(num: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 59: return .absoluteUrl(url: try FfiConverterString.read(from: &buf)
        )
        
        case 60: return .method(method: try FfiConverterTypeHttpMethod.read(from: &buf)
        )
        
        case 61: return .payload(hash: try FfiConverterString.read(from: &buf)
        )
        
        case 62: return .anon(msg: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 63: return .proxy(id: try FfiConverterString.read(from: &buf), protocol: try FfiConverterTypeProtocol.read(from: &buf)
        )
        
        case 64: return .emoji(shortcode: try FfiConverterString.read(from: &buf), url: try FfiConverterString.read(from: &buf)
        )
        
        case 65: return .encrypted
        
        case 66: return .request(event: try FfiConverterTypeEvent.read(from: &buf)
        )
        
        case 67: return .dataVendingMachineStatusTag(status: try FfiConverterTypeDataVendingMachineStatus.read(from: &buf), extraInfo: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 68: return .labelNamespace(namespace: try FfiConverterString.read(from: &buf)
        )
        
        case 69: return .label(value: try FfiConverterString.read(from: &buf), namespace: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 70: return .protected
        
        case 71: return .alt(summary: try FfiConverterString.read(from: &buf)
        )
        
        case 72: return .word(word: try FfiConverterString.read(from: &buf)
        )
        
        case 73: return .web(urls: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 74: return .dependency(dep: try FfiConverterString.read(from: &buf)
        )
        
        case 75: return .`extension`(ext: try FfiConverterString.read(from: &buf)
        )
        
        case 76: return .license(license: try FfiConverterString.read(from: &buf)
        )
        
        case 77: return .runtime(runtime: try FfiConverterString.read(from: &buf)
        )
        
        case 78: return .repository(url: try FfiConverterString.read(from: &buf)
        )
        
        case 79: return .nip88PollEndsAt(timestamp: try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 80: return .nip88PollOption(option: try FfiConverterTypePollOption.read(from: &buf)
        )
        
        case 81: return .nip88PollResponse(response: try FfiConverterString.read(from: &buf)
        )
        
        case 82: return .nip88PollType(pollType: try FfiConverterTypePollType.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TagStandard, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .eventTag(eventId,relayUrl,marker,publicKey,uppercase):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            FfiConverterOptionTypeRelayUrl.write(relayUrl, into: &buf)
            FfiConverterOptionTypeMarker.write(marker, into: &buf)
            FfiConverterOptionTypePublicKey.write(publicKey, into: &buf)
            FfiConverterBool.write(uppercase, into: &buf)
            
        
        case let .quote(eventId,relayUrl,publicKey):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            FfiConverterOptionTypeRelayUrl.write(relayUrl, into: &buf)
            FfiConverterOptionTypePublicKey.write(publicKey, into: &buf)
            
        
        case let .quoteAddress(coordinate,relayUrl):
            writeInt(&buf, Int32(3))
            FfiConverterTypeCoordinate.write(coordinate, into: &buf)
            FfiConverterOptionTypeRelayUrl.write(relayUrl, into: &buf)
            
        
        case let .gitClone(urls):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceString.write(urls, into: &buf)
            
        
        case let .gitCommit(hash):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .gitEarliestUniqueCommitId(commit):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(commit, into: &buf)
            
        
        case let .gitMaintainers(publicKeys):
            writeInt(&buf, Int32(7))
            FfiConverterSequenceTypePublicKey.write(publicKeys, into: &buf)
            
        
        case let .gitHead(head):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(head, into: &buf)
            
        
        case let .publicKeyTag(publicKey,relayUrl,alias,uppercase):
            writeInt(&buf, Int32(9))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterOptionTypeRelayUrl.write(relayUrl, into: &buf)
            FfiConverterOptionString.write(alias, into: &buf)
            FfiConverterBool.write(uppercase, into: &buf)
            
        
        case let .eventReport(eventId,report):
            writeInt(&buf, Int32(10))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            FfiConverterTypeReport.write(report, into: &buf)
            
        
        case let .pubKeyReport(publicKey,report):
            writeInt(&buf, Int32(11))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterTypeReport.write(report, into: &buf)
            
        
        case let .publicKeyLiveEvent(publicKey,relayUrl,marker,proof):
            writeInt(&buf, Int32(12))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterOptionTypeRelayUrl.write(relayUrl, into: &buf)
            FfiConverterTypeLiveEventMarker.write(marker, into: &buf)
            FfiConverterOptionString.write(proof, into: &buf)
            
        
        case let .reference(reference):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(reference, into: &buf)
            
        
        case let .relayMetadataTag(relayUrl,rw):
            writeInt(&buf, Int32(14))
            FfiConverterTypeRelayUrl.write(relayUrl, into: &buf)
            FfiConverterOptionTypeRelayMetadata.write(rw, into: &buf)
            
        
        case let .hashtag(hashtag):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(hashtag, into: &buf)
            
        
        case let .geohash(geohash):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(geohash, into: &buf)
            
        
        case let .identifier(identifier):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(identifier, into: &buf)
            
        
        case let .externalContent(content,hint,uppercase):
            writeInt(&buf, Int32(18))
            FfiConverterTypeExternalContentId.write(content, into: &buf)
            FfiConverterOptionString.write(hint, into: &buf)
            FfiConverterBool.write(uppercase, into: &buf)
            
        
        case let .externalIdentity(identity):
            writeInt(&buf, Int32(19))
            FfiConverterTypeIdentity.write(identity, into: &buf)
            
        
        case let .coordinateTag(coordinate,relayUrl,uppercase):
            writeInt(&buf, Int32(20))
            FfiConverterTypeCoordinate.write(coordinate, into: &buf)
            FfiConverterOptionTypeRelayUrl.write(relayUrl, into: &buf)
            FfiConverterBool.write(uppercase, into: &buf)
            
        
        case let .kindTag(kind,uppercase):
            writeInt(&buf, Int32(21))
            FfiConverterTypeKind.write(kind, into: &buf)
            FfiConverterBool.write(uppercase, into: &buf)
            
        
        case let .nip73KindTag(kind,uppercase):
            writeInt(&buf, Int32(22))
            FfiConverterTypeNip73Kind.write(kind, into: &buf)
            FfiConverterBool.write(uppercase, into: &buf)
            
        
        case let .relay(url):
            writeInt(&buf, Int32(23))
            FfiConverterTypeRelayUrl.write(url, into: &buf)
            
        
        case .allRelays:
            writeInt(&buf, Int32(24))
        
        
        case let .pow(nonce,difficulty):
            writeInt(&buf, Int32(25))
            FfiConverterString.write(nonce, into: &buf)
            FfiConverterUInt8.write(difficulty, into: &buf)
            
        
        case let .client(name,address):
            writeInt(&buf, Int32(26))
            FfiConverterString.write(name, into: &buf)
            FfiConverterOptionTypeTagClientAddress.write(address, into: &buf)
            
        
        case let .contentWarning(reason):
            writeInt(&buf, Int32(27))
            FfiConverterOptionString.write(reason, into: &buf)
            
        
        case let .expiration(timestamp):
            writeInt(&buf, Int32(28))
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            
        
        case let .subject(subject):
            writeInt(&buf, Int32(29))
            FfiConverterString.write(subject, into: &buf)
            
        
        case let .challenge(challenge):
            writeInt(&buf, Int32(30))
            FfiConverterString.write(challenge, into: &buf)
            
        
        case let .title(title):
            writeInt(&buf, Int32(31))
            FfiConverterString.write(title, into: &buf)
            
        
        case let .image(url,dimensions):
            writeInt(&buf, Int32(32))
            FfiConverterString.write(url, into: &buf)
            FfiConverterOptionTypeImageDimensions.write(dimensions, into: &buf)
            
        
        case let .thumb(url,dimensions):
            writeInt(&buf, Int32(33))
            FfiConverterString.write(url, into: &buf)
            FfiConverterOptionTypeImageDimensions.write(dimensions, into: &buf)
            
        
        case let .summary(summary):
            writeInt(&buf, Int32(34))
            FfiConverterString.write(summary, into: &buf)
            
        
        case let .description(desc):
            writeInt(&buf, Int32(35))
            FfiConverterString.write(desc, into: &buf)
            
        
        case let .bolt11(bolt11):
            writeInt(&buf, Int32(36))
            FfiConverterString.write(bolt11, into: &buf)
            
        
        case let .preimage(preimage):
            writeInt(&buf, Int32(37))
            FfiConverterString.write(preimage, into: &buf)
            
        
        case let .relays(urls):
            writeInt(&buf, Int32(38))
            FfiConverterSequenceTypeRelayUrl.write(urls, into: &buf)
            
        
        case let .amount(millisats,bolt11):
            writeInt(&buf, Int32(39))
            FfiConverterUInt64.write(millisats, into: &buf)
            FfiConverterOptionString.write(bolt11, into: &buf)
            
        
        case let .lnurl(lnurl):
            writeInt(&buf, Int32(40))
            FfiConverterString.write(lnurl, into: &buf)
            
        
        case let .name(name):
            writeInt(&buf, Int32(41))
            FfiConverterString.write(name, into: &buf)
            
        
        case let .publishedAt(timestamp):
            writeInt(&buf, Int32(42))
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            
        
        case let .urlTag(url):
            writeInt(&buf, Int32(43))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .mimeType(mime):
            writeInt(&buf, Int32(44))
            FfiConverterString.write(mime, into: &buf)
            
        
        case let .aes256Gcm(key,iv):
            writeInt(&buf, Int32(45))
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(iv, into: &buf)
            
        
        case let .server(url):
            writeInt(&buf, Int32(46))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .sha256(hash):
            writeInt(&buf, Int32(47))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .size(size):
            writeInt(&buf, Int32(48))
            FfiConverterUInt64.write(size, into: &buf)
            
        
        case let .dim(dimensions):
            writeInt(&buf, Int32(49))
            FfiConverterTypeImageDimensions.write(dimensions, into: &buf)
            
        
        case let .magnet(uri):
            writeInt(&buf, Int32(50))
            FfiConverterString.write(uri, into: &buf)
            
        
        case let .blurhash(blurhash):
            writeInt(&buf, Int32(51))
            FfiConverterString.write(blurhash, into: &buf)
            
        
        case let .streaming(url):
            writeInt(&buf, Int32(52))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .recording(url):
            writeInt(&buf, Int32(53))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .starts(timestamp):
            writeInt(&buf, Int32(54))
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            
        
        case let .ends(timestamp):
            writeInt(&buf, Int32(55))
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            
        
        case let .liveEventStatusTag(status):
            writeInt(&buf, Int32(56))
            FfiConverterTypeLiveEventStatus.write(status, into: &buf)
            
        
        case let .currentParticipants(num):
            writeInt(&buf, Int32(57))
            FfiConverterUInt64.write(num, into: &buf)
            
        
        case let .totalParticipants(num):
            writeInt(&buf, Int32(58))
            FfiConverterUInt64.write(num, into: &buf)
            
        
        case let .absoluteUrl(url):
            writeInt(&buf, Int32(59))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .method(method):
            writeInt(&buf, Int32(60))
            FfiConverterTypeHttpMethod.write(method, into: &buf)
            
        
        case let .payload(hash):
            writeInt(&buf, Int32(61))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .anon(msg):
            writeInt(&buf, Int32(62))
            FfiConverterOptionString.write(msg, into: &buf)
            
        
        case let .proxy(id,`protocol`):
            writeInt(&buf, Int32(63))
            FfiConverterString.write(id, into: &buf)
            FfiConverterTypeProtocol.write(`protocol`, into: &buf)
            
        
        case let .emoji(shortcode,url):
            writeInt(&buf, Int32(64))
            FfiConverterString.write(shortcode, into: &buf)
            FfiConverterString.write(url, into: &buf)
            
        
        case .encrypted:
            writeInt(&buf, Int32(65))
        
        
        case let .request(event):
            writeInt(&buf, Int32(66))
            FfiConverterTypeEvent.write(event, into: &buf)
            
        
        case let .dataVendingMachineStatusTag(status,extraInfo):
            writeInt(&buf, Int32(67))
            FfiConverterTypeDataVendingMachineStatus.write(status, into: &buf)
            FfiConverterOptionString.write(extraInfo, into: &buf)
            
        
        case let .labelNamespace(namespace):
            writeInt(&buf, Int32(68))
            FfiConverterString.write(namespace, into: &buf)
            
        
        case let .label(value,namespace):
            writeInt(&buf, Int32(69))
            FfiConverterString.write(value, into: &buf)
            FfiConverterOptionString.write(namespace, into: &buf)
            
        
        case .protected:
            writeInt(&buf, Int32(70))
        
        
        case let .alt(summary):
            writeInt(&buf, Int32(71))
            FfiConverterString.write(summary, into: &buf)
            
        
        case let .word(word):
            writeInt(&buf, Int32(72))
            FfiConverterString.write(word, into: &buf)
            
        
        case let .web(urls):
            writeInt(&buf, Int32(73))
            FfiConverterSequenceString.write(urls, into: &buf)
            
        
        case let .dependency(dep):
            writeInt(&buf, Int32(74))
            FfiConverterString.write(dep, into: &buf)
            
        
        case let .`extension`(ext):
            writeInt(&buf, Int32(75))
            FfiConverterString.write(ext, into: &buf)
            
        
        case let .license(license):
            writeInt(&buf, Int32(76))
            FfiConverterString.write(license, into: &buf)
            
        
        case let .runtime(runtime):
            writeInt(&buf, Int32(77))
            FfiConverterString.write(runtime, into: &buf)
            
        
        case let .repository(url):
            writeInt(&buf, Int32(78))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .nip88PollEndsAt(timestamp):
            writeInt(&buf, Int32(79))
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            
        
        case let .nip88PollOption(option):
            writeInt(&buf, Int32(80))
            FfiConverterTypePollOption.write(option, into: &buf)
            
        
        case let .nip88PollResponse(response):
            writeInt(&buf, Int32(81))
            FfiConverterString.write(response, into: &buf)
            
        
        case let .nip88PollType(pollType):
            writeInt(&buf, Int32(82))
            FfiConverterTypePollType.write(pollType, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTagStandard_lift(_ buf: RustBuffer) throws -> TagStandard {
    return try FfiConverterTypeTagStandard.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTagStandard_lower(_ value: TagStandard) -> RustBuffer {
    return FfiConverterTypeTagStandard.lower(value)
}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Transaction State
 */

public enum TransactionState {
    
    /**
     * Pending
     */
    case pending
    /**
     * Settled
     */
    case settled
    /**
     * Expired (for invoices)
     */
    case expired
    /**
     * Failed (for payments)
     */
    case failed
}


#if compiler(>=6)
extension TransactionState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionState: FfiConverterRustBuffer {
    typealias SwiftType = TransactionState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pending
        
        case 2: return .settled
        
        case 3: return .expired
        
        case 4: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pending:
            writeInt(&buf, Int32(1))
        
        
        case .settled:
            writeInt(&buf, Int32(2))
        
        
        case .expired:
            writeInt(&buf, Int32(3))
        
        
        case .failed:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionState_lift(_ buf: RustBuffer) throws -> TransactionState {
    return try FfiConverterTypeTransactionState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionState_lower(_ value: TransactionState) -> RustBuffer {
    return FfiConverterTypeTransactionState.lower(value)
}


extension TransactionState: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Transaction Type
 */

public enum TransactionType {
    
    /**
     * Incoming payments
     */
    case incoming
    /**
     * Outgoing payments
     */
    case outgoing
}


#if compiler(>=6)
extension TransactionType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionType: FfiConverterRustBuffer {
    typealias SwiftType = TransactionType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .incoming
        
        case 2: return .outgoing
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .incoming:
            writeInt(&buf, Int32(1))
        
        
        case .outgoing:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionType_lift(_ buf: RustBuffer) throws -> TransactionType {
    return try FfiConverterTypeTransactionType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionType_lower(_ value: TransactionType) -> RustBuffer {
    return FfiConverterTypeTransactionType.lower(value)
}


extension TransactionType: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WebSocketMessage {
    
    case text(text: String
    )
    case binary(bytes: Data
    )
    case ping(bytes: Data
    )
    case pong(bytes: Data
    )
    case close(frame: WebSocketCloseFrame?
    )
}


#if compiler(>=6)
extension WebSocketMessage: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWebSocketMessage: FfiConverterRustBuffer {
    typealias SwiftType = WebSocketMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WebSocketMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text(text: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .binary(bytes: try FfiConverterData.read(from: &buf)
        )
        
        case 3: return .ping(bytes: try FfiConverterData.read(from: &buf)
        )
        
        case 4: return .pong(bytes: try FfiConverterData.read(from: &buf)
        )
        
        case 5: return .close(frame: try FfiConverterOptionTypeWebSocketCloseFrame.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WebSocketMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .text(text):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(text, into: &buf)
            
        
        case let .binary(bytes):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(bytes, into: &buf)
            
        
        case let .ping(bytes):
            writeInt(&buf, Int32(3))
            FfiConverterData.write(bytes, into: &buf)
            
        
        case let .pong(bytes):
            writeInt(&buf, Int32(4))
            FfiConverterData.write(bytes, into: &buf)
            
        
        case let .close(frame):
            writeInt(&buf, Int32(5))
            FfiConverterOptionTypeWebSocketCloseFrame.write(frame, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWebSocketMessage_lift(_ buf: RustBuffer) throws -> WebSocketMessage {
    return try FfiConverterTypeWebSocketMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWebSocketMessage_lower(_ value: WebSocketMessage) -> RustBuffer {
    return FfiConverterTypeWebSocketMessage.lower(value)
}


extension WebSocketMessage: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZapType {
    
    /**
     * Public
     */
    case `public`
    /**
     * Private
     */
    case `private`
    /**
     * Anonymous
     */
    case anonymous
}


#if compiler(>=6)
extension ZapType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeZapType: FfiConverterRustBuffer {
    typealias SwiftType = ZapType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZapType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`public`
        
        case 2: return .`private`
        
        case 3: return .anonymous
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZapType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`public`:
            writeInt(&buf, Int32(1))
        
        
        case .`private`:
            writeInt(&buf, Int32(2))
        
        
        case .anonymous:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeZapType_lift(_ buf: RustBuffer) throws -> ZapType {
    return try FfiConverterTypeZapType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeZapType_lower(_ value: ZapType) -> RustBuffer {
    return FfiConverterTypeZapType.lower(value)
}


extension ZapType: Equatable, Hashable {}






#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDuration.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDuration.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAdmitStatus: FfiConverterRustBuffer {
    typealias SwiftType = AdmitStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAdmitStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAdmitStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEvent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEvent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeEventId: FfiConverterRustBuffer {
    typealias SwiftType = EventId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeKind: FfiConverterRustBuffer {
    typealias SwiftType = Kind?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeKind.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeKind.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMetadata: FfiConverterRustBuffer {
    typealias SwiftType = Metadata?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMetadata.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMetadata.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeNostrSigner: FfiConverterRustBuffer {
    typealias SwiftType = NostrSigner?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNostrSigner.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNostrSigner.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePublicKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePublicKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRelayOptions: FfiConverterRustBuffer {
    typealias SwiftType = RelayOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRelayOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRelayOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRelayUrl: FfiConverterRustBuffer {
    typealias SwiftType = RelayUrl?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRelayUrl.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRelayUrl.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSaveEventStatus: FfiConverterRustBuffer {
    typealias SwiftType = SaveEventStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSaveEventStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSaveEventStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSingleLetterTag: FfiConverterRustBuffer {
    typealias SwiftType = SingleLetterTag?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSingleLetterTag.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSingleLetterTag.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSubscribeAutoCloseOptions: FfiConverterRustBuffer {
    typealias SwiftType = SubscribeAutoCloseOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSubscribeAutoCloseOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSubscribeAutoCloseOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTag: FfiConverterRustBuffer {
    typealias SwiftType = Tag?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTag.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTag.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Timestamp?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTimestamp.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTimestamp.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeWebSocketAdapterWrapper: FfiConverterRustBuffer {
    typealias SwiftType = WebSocketAdapterWrapper?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWebSocketAdapterWrapper.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWebSocketAdapterWrapper.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFeeSchedules: FfiConverterRustBuffer {
    typealias SwiftType = FeeSchedules?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFeeSchedules.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFeeSchedules.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeImage: FfiConverterRustBuffer {
    typealias SwiftType = Image?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeImageDimensions: FfiConverterRustBuffer {
    typealias SwiftType = ImageDimensions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImageDimensions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImageDimensions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLimitation: FfiConverterRustBuffer {
    typealias SwiftType = Limitation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLimitation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLimitation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLiveEventHost: FfiConverterRustBuffer {
    typealias SwiftType = LiveEventHost?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLiveEventHost.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLiveEventHost.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeNostrParserOptions: FfiConverterRustBuffer {
    typealias SwiftType = NostrParserOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNostrParserOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNostrParserOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTagClientAddress: FfiConverterRustBuffer {
    typealias SwiftType = TagClientAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTagClientAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTagClientAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeWebSocketCloseFrame: FfiConverterRustBuffer {
    typealias SwiftType = WebSocketCloseFrame?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWebSocketCloseFrame.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWebSocketCloseFrame.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeCommentTarget: FfiConverterRustBuffer {
    typealias SwiftType = CommentTarget?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCommentTarget.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCommentTarget.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeJsonValue: FfiConverterRustBuffer {
    typealias SwiftType = JsonValue?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeJsonValue.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeJsonValue.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeKindStandard: FfiConverterRustBuffer {
    typealias SwiftType = KindStandard?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeKindStandard.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeKindStandard.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLiveEventStatus: FfiConverterRustBuffer {
    typealias SwiftType = LiveEventStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLiveEventStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLiveEventStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMarker: FfiConverterRustBuffer {
    typealias SwiftType = Marker?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMarker.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMarker.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRejectedReason: FfiConverterRustBuffer {
    typealias SwiftType = RejectedReason?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRejectedReason.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRejectedReason.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRelayMetadata: FfiConverterRustBuffer {
    typealias SwiftType = RelayMetadata?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRelayMetadata.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRelayMetadata.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTagStandard: FfiConverterRustBuffer {
    typealias SwiftType = TagStandard?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTagStandard.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTagStandard.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTransactionState: FfiConverterRustBuffer {
    typealias SwiftType = TransactionState?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTransactionState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTransactionState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTransactionType: FfiConverterRustBuffer {
    typealias SwiftType = TransactionType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTransactionType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTransactionType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeWebSocketMessage: FfiConverterRustBuffer {
    typealias SwiftType = WebSocketMessage?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWebSocketMessage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWebSocketMessage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceUInt16: FfiConverterRustBuffer {
    typealias SwiftType = [UInt16]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeEventId: FfiConverterRustBuffer {
    typealias SwiftType = [EventId]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeEventId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeEventId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = [Filter]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFilter.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFilter.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeKind: FfiConverterRustBuffer {
    typealias SwiftType = [Kind]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeKind.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeKind.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePublicKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePublicKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeRetentionKind: FfiConverterRustBuffer {
    typealias SwiftType = [RetentionKind]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeRetentionKind.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeRetentionKind.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDictionaryStringTypeJsonValue: FfiConverterRustBuffer {
    typealias SwiftType = [String: JsonValue]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringTypeJsonValue.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringTypeJsonValue.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt16: FfiConverterRustBuffer {
    typealias SwiftType = [UInt16]

    public static func write(_ value: [UInt16], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt16.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt16] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt16]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt16.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeClientMessage: FfiConverterRustBuffer {
    typealias SwiftType = [ClientMessage]

    public static func write(_ value: [ClientMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeClientMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ClientMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [ClientMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeClientMessage.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCoordinate: FfiConverterRustBuffer {
    typealias SwiftType = [Coordinate]

    public static func write(_ value: [Coordinate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCoordinate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Coordinate] {
        let len: Int32 = try readInt(&buf)
        var seq = [Coordinate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCoordinate.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = [Event]

    public static func write(_ value: [Event], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEvent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Event] {
        let len: Int32 = try readInt(&buf)
        var seq = [Event]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEvent.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEventId: FfiConverterRustBuffer {
    typealias SwiftType = [EventId]

    public static func write(_ value: [EventId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEventId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EventId] {
        let len: Int32 = try readInt(&buf)
        var seq = [EventId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEventId.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = [Filter]

    public static func write(_ value: [Filter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Filter] {
        let len: Int32 = try readInt(&buf)
        var seq = [Filter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFilter.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeKind: FfiConverterRustBuffer {
    typealias SwiftType = [Kind]

    public static func write(_ value: [Kind], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeKind.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Kind] {
        let len: Int32 = try readInt(&buf)
        var seq = [Kind]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeKind.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    public static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRelayUrl: FfiConverterRustBuffer {
    typealias SwiftType = [RelayUrl]

    public static func write(_ value: [RelayUrl], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRelayUrl.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RelayUrl] {
        let len: Int32 = try readInt(&buf)
        var seq = [RelayUrl]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRelayUrl.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeShippingMethod: FfiConverterRustBuffer {
    typealias SwiftType = [ShippingMethod]

    public static func write(_ value: [ShippingMethod], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeShippingMethod.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ShippingMethod] {
        let len: Int32 = try readInt(&buf)
        var seq = [ShippingMethod]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeShippingMethod.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTag: FfiConverterRustBuffer {
    typealias SwiftType = [Tag]

    public static func write(_ value: [Tag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Tag] {
        let len: Int32 = try readInt(&buf)
        var seq = [Tag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTag.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeContact: FfiConverterRustBuffer {
    typealias SwiftType = [Contact]

    public static func write(_ value: [Contact], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeContact.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Contact] {
        let len: Int32 = try readInt(&buf)
        var seq = [Contact]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeContact.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEmojiInfo: FfiConverterRustBuffer {
    typealias SwiftType = [EmojiInfo]

    public static func write(_ value: [EmojiInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEmojiInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EmojiInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [EmojiInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEmojiInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFeeSchedule: FfiConverterRustBuffer {
    typealias SwiftType = [FeeSchedule]

    public static func write(_ value: [FeeSchedule], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFeeSchedule.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FeeSchedule] {
        let len: Int32 = try readInt(&buf)
        var seq = [FeeSchedule]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFeeSchedule.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeGenericTag: FfiConverterRustBuffer {
    typealias SwiftType = [GenericTag]

    public static func write(_ value: [GenericTag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGenericTag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GenericTag] {
        let len: Int32 = try readInt(&buf)
        var seq = [GenericTag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGenericTag.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeImage: FfiConverterRustBuffer {
    typealias SwiftType = [Image]

    public static func write(_ value: [Image], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeImage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Image] {
        let len: Int32 = try readInt(&buf)
        var seq = [Image]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeImage.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeKeysendTLVRecord: FfiConverterRustBuffer {
    typealias SwiftType = [KeysendTlvRecord]

    public static func write(_ value: [KeysendTlvRecord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeKeysendTLVRecord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [KeysendTlvRecord] {
        let len: Int32 = try readInt(&buf)
        var seq = [KeysendTlvRecord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeKeysendTLVRecord.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLookupInvoiceResponse: FfiConverterRustBuffer {
    typealias SwiftType = [LookupInvoiceResponse]

    public static func write(_ value: [LookupInvoiceResponse], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLookupInvoiceResponse.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LookupInvoiceResponse] {
        let len: Int32 = try readInt(&buf)
        var seq = [LookupInvoiceResponse]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLookupInvoiceResponse.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeNegentropyItem: FfiConverterRustBuffer {
    typealias SwiftType = [NegentropyItem]

    public static func write(_ value: [NegentropyItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNegentropyItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NegentropyItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [NegentropyItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNegentropyItem.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePayInvoiceRequest: FfiConverterRustBuffer {
    typealias SwiftType = [PayInvoiceRequest]

    public static func write(_ value: [PayInvoiceRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePayInvoiceRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PayInvoiceRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [PayInvoiceRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePayInvoiceRequest.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePayKeysendRequest: FfiConverterRustBuffer {
    typealias SwiftType = [PayKeysendRequest]

    public static func write(_ value: [PayKeysendRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePayKeysendRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PayKeysendRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [PayKeysendRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePayKeysendRequest.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePerson: FfiConverterRustBuffer {
    typealias SwiftType = [Person]

    public static func write(_ value: [Person], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerson.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Person] {
        let len: Int32 = try readInt(&buf)
        var seq = [Person]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerson.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeReconciliationSendFailureItem: FfiConverterRustBuffer {
    typealias SwiftType = [ReconciliationSendFailureItem]

    public static func write(_ value: [ReconciliationSendFailureItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReconciliationSendFailureItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ReconciliationSendFailureItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [ReconciliationSendFailureItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReconciliationSendFailureItem.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRetention: FfiConverterRustBuffer {
    typealias SwiftType = [Retention]

    public static func write(_ value: [Retention], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRetention.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Retention] {
        let len: Int32 = try readInt(&buf)
        var seq = [Retention]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRetention.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeShippingCost: FfiConverterRustBuffer {
    typealias SwiftType = [ShippingCost]

    public static func write(_ value: [ShippingCost], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeShippingCost.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ShippingCost] {
        let len: Int32 = try readInt(&buf)
        var seq = [ShippingCost]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeShippingCost.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeShippingMethodRecord: FfiConverterRustBuffer {
    typealias SwiftType = [ShippingMethodRecord]

    public static func write(_ value: [ShippingMethodRecord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeShippingMethodRecord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ShippingMethodRecord] {
        let len: Int32 = try readInt(&buf)
        var seq = [ShippingMethodRecord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeShippingMethodRecord.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeJsonValue: FfiConverterRustBuffer {
    typealias SwiftType = [JsonValue]

    public static func write(_ value: [JsonValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeJsonValue.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [JsonValue] {
        let len: Int32 = try readInt(&buf)
        var seq = [JsonValue]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeJsonValue.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMethod: FfiConverterRustBuffer {
    typealias SwiftType = [Method]

    public static func write(_ value: [Method], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMethod.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Method] {
        let len: Int32 = try readInt(&buf)
        var seq = [Method]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMethod.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeNostrParserToken: FfiConverterRustBuffer {
    typealias SwiftType = [NostrParserToken]

    public static func write(_ value: [NostrParserToken], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNostrParserToken.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NostrParserToken] {
        let len: Int32 = try readInt(&buf)
        var seq = [NostrParserToken]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNostrParserToken.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRetentionKind: FfiConverterRustBuffer {
    typealias SwiftType = [RetentionKind]

    public static func write(_ value: [RetentionKind], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRetentionKind.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RetentionKind] {
        let len: Int32 = try readInt(&buf)
        var seq = [RetentionKind]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRetentionKind.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTagStandard: FfiConverterRustBuffer {
    typealias SwiftType = [TagStandard]

    public static func write(_ value: [TagStandard], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTagStandard.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TagStandard] {
        let len: Int32 = try readInt(&buf)
        var seq = [TagStandard]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTagStandard.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]

    public static func write(_ value: [[String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[String]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[String]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeJsonValue: FfiConverterRustBuffer {
    public static func write(_ value: [String: JsonValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeJsonValue.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: JsonValue] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: JsonValue]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeJsonValue.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringSequenceTypeFilter: FfiConverterRustBuffer {
    public static func write(_ value: [String: [Filter]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeFilter.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [Filter]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [Filter]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeFilter.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringDictionaryTypeRelayUrlSequenceTypeFilter: FfiConverterRustBuffer {
    public static func write(_ value: [String: [RelayUrl: [Filter]]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryTypeRelayUrlSequenceTypeFilter.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [RelayUrl: [Filter]]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [RelayUrl: [Filter]]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryTypeRelayUrlSequenceTypeFilter.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeRelayUrlString: FfiConverterRustBuffer {
    public static func write(_ value: [RelayUrl: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeRelayUrl.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RelayUrl: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [RelayUrl: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeRelayUrl.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeRelayUrlTypeFilter: FfiConverterRustBuffer {
    public static func write(_ value: [RelayUrl: Filter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeRelayUrl.write(key, into: &buf)
            FfiConverterTypeFilter.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RelayUrl: Filter] {
        let len: Int32 = try readInt(&buf)
        var dict = [RelayUrl: Filter]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeRelayUrl.read(from: &buf)
            let value = try FfiConverterTypeFilter.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeRelayUrlTypeRelay: FfiConverterRustBuffer {
    public static func write(_ value: [RelayUrl: Relay], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeRelayUrl.write(key, into: &buf)
            FfiConverterTypeRelay.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RelayUrl: Relay] {
        let len: Int32 = try readInt(&buf)
        var dict = [RelayUrl: Relay]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeRelayUrl.read(from: &buf)
            let value = try FfiConverterTypeRelay.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeRelayUrlTypeRelayStatus: FfiConverterRustBuffer {
    public static func write(_ value: [RelayUrl: RelayStatus], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeRelayUrl.write(key, into: &buf)
            FfiConverterTypeRelayStatus.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RelayUrl: RelayStatus] {
        let len: Int32 = try readInt(&buf)
        var dict = [RelayUrl: RelayStatus]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeRelayUrl.read(from: &buf)
            let value = try FfiConverterTypeRelayStatus.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeRelayUrlOptionTypeRelayMetadata: FfiConverterRustBuffer {
    public static func write(_ value: [RelayUrl: RelayMetadata?], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeRelayUrl.write(key, into: &buf)
            FfiConverterOptionTypeRelayMetadata.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RelayUrl: RelayMetadata?] {
        let len: Int32 = try readInt(&buf)
        var dict = [RelayUrl: RelayMetadata?]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeRelayUrl.read(from: &buf)
            let value = try FfiConverterOptionTypeRelayMetadata.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeRelayUrlSequenceTypeFilter: FfiConverterRustBuffer {
    public static func write(_ value: [RelayUrl: [Filter]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeRelayUrl.write(key, into: &buf)
            FfiConverterSequenceTypeFilter.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RelayUrl: [Filter]] {
        let len: Int32 = try readInt(&buf)
        var dict = [RelayUrl: [Filter]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeRelayUrl.read(from: &buf)
            let value = try FfiConverterSequenceTypeFilter.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeRelayUrlSequenceTypeReconciliationSendFailureItem: FfiConverterRustBuffer {
    public static func write(_ value: [RelayUrl: [ReconciliationSendFailureItem]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeRelayUrl.write(key, into: &buf)
            FfiConverterSequenceTypeReconciliationSendFailureItem.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RelayUrl: [ReconciliationSendFailureItem]] {
        let len: Int32 = try readInt(&buf)
        var dict = [RelayUrl: [ReconciliationSendFailureItem]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeRelayUrl.read(from: &buf)
            let value = try FfiConverterSequenceTypeReconciliationSendFailureItem.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureNostrSdkFfiInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate let UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
fileprivate protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountNostrSdk() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
public func decryptReceivedPrivateZapMessage(secretKey: SecretKey, privateZap: Event)throws  -> Event  {
    return try  FfiConverterTypeEvent_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_func_decrypt_received_private_zap_message(
        FfiConverterTypeSecretKey_lower(secretKey),
        FfiConverterTypeEvent_lower(privateZap),$0
    )
})
}
public func decryptSentPrivateZapMessage(secretKey: SecretKey, publicKey: PublicKey, privateZap: Event)throws  -> Event  {
    return try  FfiConverterTypeEvent_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_func_decrypt_sent_private_zap_message(
        FfiConverterTypeSecretKey_lower(secretKey),
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterTypeEvent_lower(privateZap),$0
    )
})
}
/**
 * Extracts the relay info (url, optional read/write flag) from the event
 */
public func extractRelayList(event: Event) -> [RelayUrl: RelayMetadata?]  {
    return try!  FfiConverterDictionaryTypeRelayUrlOptionTypeRelayMetadata.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_func_extract_relay_list(
        FfiConverterTypeEvent_lower(event),$0
    )
})
}
/**
 * Generate shared key
 *
 * **Important: use of a strong cryptographic hash function may be critical to security! Do NOT use
 * unless you understand cryptographical implications.**
 */
public func generateSharedKey(secretKey: SecretKey, publicKey: PublicKey)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_func_generate_shared_key(
        FfiConverterTypeSecretKey_lower(secretKey),
        FfiConverterTypePublicKey_lower(publicKey),$0
    )
})
}
/**
 * Gets the number of leading zero bits. Result is between 0 and 255.
 */
public func getLeadingZeroBits(bytes: Data) -> UInt8  {
    return try!  FfiConverterUInt8.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_func_get_leading_zero_bits(
        FfiConverterData.lower(bytes),$0
    )
})
}
/**
 * Returns all possible ID prefixes (hex) that have the specified number of leading zero bits.
 *
 * Possible values: 0-255
 */
public func getPrefixesForDifficulty(leadingZeroBits: UInt8) -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_func_get_prefixes_for_difficulty(
        FfiConverterUInt8.lower(leadingZeroBits),$0
    )
})
}
/**
 * Build Gift Wrap
 *
 * <https://github.com/nostr-protocol/nips/blob/master/59.md>
 */
public func giftWrap(signer: NostrSigner, receiverPubkey: PublicKey, rumor: UnsignedEvent, extraTags: [Tag] = [])async throws  -> Event  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_func_gift_wrap(FfiConverterTypeNostrSigner_lower(signer),FfiConverterTypePublicKey_lower(receiverPubkey),FfiConverterTypeUnsignedEvent_lower(rumor),FfiConverterSequenceTypeTag.lower(extraTags)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvent_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
/**
 * Build Gift Wrap from Seal
 *
 * <https://github.com/nostr-protocol/nips/blob/master/59.md>
 */
public func giftWrapFromSeal(receiver: PublicKey, seal: Event, extraTags: [Tag] = [])throws  -> Event  {
    return try  FfiConverterTypeEvent_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_func_gift_wrap_from_seal(
        FfiConverterTypePublicKey_lower(receiver),
        FfiConverterTypeEvent_lower(seal),
        FfiConverterSequenceTypeTag.lower(extraTags),$0
    )
})
}
/**
 * Get git hash version of `rust-nostr` libraries
 */
public func gitHashVersion() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_func_git_hash_version($0
    )
})
}
public func initLogger(level: LogLevel)  {try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_func_init_logger(
        FfiConverterTypeLogLevel_lower(level),$0
    )
}
}
/**
 * Private Direct message
 *
 * <https://github.com/nostr-protocol/nips/blob/master/17.md>
 */
public func makePrivateMsg(signer: NostrSigner, receiver: PublicKey, message: String, rumorExtraTags: [Tag] = [])async throws  -> Event  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_sdk_ffi_fn_func_make_private_msg(FfiConverterTypeNostrSigner_lower(signer),FfiConverterTypePublicKey_lower(receiver),FfiConverterString.lower(message),FfiConverterSequenceTypeTag.lower(rumorExtraTags)
                )
            },
            pollFunc: ffi_nostr_sdk_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_sdk_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_sdk_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEvent_lift,
            errorHandler: FfiConverterTypeNostrSdkError_lift
        )
}
public func nip04Decrypt(secretKey: SecretKey, publicKey: PublicKey, encryptedContent: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_func_nip04_decrypt(
        FfiConverterTypeSecretKey_lower(secretKey),
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterString.lower(encryptedContent),$0
    )
})
}
public func nip04Encrypt(secretKey: SecretKey, publicKey: PublicKey, content: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_func_nip04_encrypt(
        FfiConverterTypeSecretKey_lower(secretKey),
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterString.lower(content),$0
    )
})
}
/**
 * Verify a NIP-05 from JSON
 */
public func nip05VerifyFromJson(publicKey: PublicKey, address: Nip05Address, json: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_func_nip05_verify_from_json(
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterTypeNip05Address_lower(address),
        FfiConverterString.lower(json),$0
    )
})
}
/**
 * Extract NIP22 parent comment target
 */
public func nip22ExtractParent(event: Event) -> CommentTarget?  {
    return try!  FfiConverterOptionTypeCommentTarget.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_func_nip22_extract_parent(
        FfiConverterTypeEvent_lower(event),$0
    )
})
}
/**
 * Extract NIP22 root comment target
 */
public func nip22ExtractRoot(event: Event) -> CommentTarget?  {
    return try!  FfiConverterOptionTypeCommentTarget.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_func_nip22_extract_root(
        FfiConverterTypeEvent_lower(event),$0
    )
})
}
public func nip44Decrypt(secretKey: SecretKey, publicKey: PublicKey, payload: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_func_nip44_decrypt(
        FfiConverterTypeSecretKey_lower(secretKey),
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterString.lower(payload),$0
    )
})
}
public func nip44Encrypt(secretKey: SecretKey, publicKey: PublicKey, content: String, version: Nip44Version)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_func_nip44_encrypt(
        FfiConverterTypeSecretKey_lower(secretKey),
        FfiConverterTypePublicKey_lower(publicKey),
        FfiConverterString.lower(content),
        FfiConverterTypeNip44Version_lower(version),$0
    )
})
}
public func nip57AnonymousZapRequest(data: ZapRequestData)throws  -> Event  {
    return try  FfiConverterTypeEvent_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_func_nip57_anonymous_zap_request(
        FfiConverterTypeZapRequestData_lower(data),$0
    )
})
}
public func nip57PrivateZapRequest(data: ZapRequestData, keys: Keys)throws  -> Event  {
    return try  FfiConverterTypeEvent_lift(try rustCallWithError(FfiConverterTypeNostrSdkError_lift) {
    uniffi_nostr_sdk_ffi_fn_func_nip57_private_zap_request(
        FfiConverterTypeZapRequestData_lower(data),
        FfiConverterTypeKeys_lower(keys),$0
    )
})
}
/**
 * Convert tag kind to string
 */
public func tagKindToString(kind: TagKind) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_sdk_ffi_fn_func_tag_kind_to_string(
        FfiConverterTypeTagKind_lower(kind),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_nostr_sdk_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_decrypt_received_private_zap_message() != 55155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_decrypt_sent_private_zap_message() != 30641) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_extract_relay_list() != 7761) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_generate_shared_key() != 60318) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_get_leading_zero_bits() != 2779) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_get_prefixes_for_difficulty() != 12958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_gift_wrap() != 44375) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_gift_wrap_from_seal() != 30742) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_git_hash_version() != 2908) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_init_logger() != 38847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_make_private_msg() != 13683) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_nip04_decrypt() != 23337) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_nip04_encrypt() != 29489) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_nip05_verify_from_json() != 24282) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_nip22_extract_parent() != 43973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_nip22_extract_root() != 22471) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_nip44_decrypt() != 18954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_nip44_encrypt() != 41114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_nip57_anonymous_zap_request() != 19524) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_nip57_private_zap_request() != 33299) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_func_tag_kind_to_string() != 44698) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_admitpolicy_admit_connection() != 33878) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_admitpolicy_admit_event() != 29006) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_add_discovery_relay() != 60047) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_add_read_relay() != 51524) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_add_relay() != 27015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_add_relay_with_opts() != 15099) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_add_write_relay() != 9505) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_automatic_authentication() != 51347) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_connect() != 19131) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_connect_relay() != 45307) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_database() != 35722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_disconnect() != 33822) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_disconnect_relay() != 59325) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_fetch_combined_events() != 8445) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_fetch_events() != 22564) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_fetch_events_from() != 43272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_fetch_metadata() != 7347) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_force_remove_all_relays() != 54159) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_force_remove_relay() != 46552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap() != 35151) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_gift_wrap_to() != 2) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_handle_notifications() != 8916) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_relay() != 4314) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_relays() != 54123) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_remove_all_relays() != 12546) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_remove_relay() != 28580) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event() != 58506) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder() != 23280) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event_builder_to() != 58152) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_event_to() != 25484) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_msg_to() != 44425) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_private_msg() != 64645) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_send_private_msg_to() != 37895) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_set_metadata() != 31801) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_shutdown() != 4321) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_sign_event_builder() != 14074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_signer() != 31951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_stream_events() != 35273) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_stream_events_from() != 5468) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_stream_events_targeted() != 40632) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscribe() != 45449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_to() != 54463) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id() != 37609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscribe_with_id_to() != 9029) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscription() != 58353) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_subscriptions() != 20835) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_sync() != 10419) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_try_connect() != 8744) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe() != 16499) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_unsubscribe_all() != 37740) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_unwrap_gift_wrap() != 24699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_client_wait_for_connection() != 388) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_admit_policy() != 1024) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_build() != 61424) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_database() != 21061) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_gossip() != 52386) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_opts() != 19869) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_signer() != 30905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientbuilder_websocket_transport() != 48944) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientmessage_as_enum() != 46388) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientmessage_as_json() != 4674) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientoptions_autoconnect() != 32443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientoptions_automatic_authentication() != 18664) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientoptions_ban_relay_on_mismatch() != 51741) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientoptions_connection() != 7210) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientoptions_gossip() != 30879) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientoptions_max_avg_latency() != 30357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientoptions_relay_limits() != 65443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_clientoptions_verify_subscriptions() != 14184) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_connection_addr() != 43068) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_connection_mode() != 217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_connection_target() != 61648) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_coordinate_identifier() != 38994) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_coordinate_kind() != 7837) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_coordinate_public_key() != 29286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_coordinate_verify() != 52656) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_backend() != 43310) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_save_event() != 15070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_check_id() != 56541) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_event_by_id() != 41704) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_count() != 13210) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_query() != 50605) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_delete() != 38569) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrdatabase_wipe() != 40503) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_backend() != 7020) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_get_public_key() != 1696) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_sign_event() != 35436) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip04_encrypt() != 382) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip04_decrypt() != 58024) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip44_encrypt() != 25563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customnostrsigner_nip44_decrypt() != 7340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customwebsockettransport_support_ping() != 65059) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_customwebsockettransport_connect() != 8221) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_decrypt() != 50130) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_key_security() != 9516) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_to_bech32() != 44747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_encryptedsecretkey_version() != 19336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_event_as_json() != 3171) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_event_as_pretty_json() != 15571) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_event_author() != 33777) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_event_content() != 63997) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_event_created_at() != 44671) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_event_id() != 10840) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_event_is_expired() != 16390) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_event_is_protected() != 60470) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_event_kind() != 37638) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_event_signature() != 24839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_event_tags() != 32843) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_event_verify() != 3329) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_event_verify_id() != 50510) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_event_verify_signature() != 21120) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_allow_self_tagging() != 57727) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_build() != 10100) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_custom_created_at() != 20379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_dedup_tags() != 16426) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_pow() != 47148) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_sign() != 24133) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_sign_with_keys() != 46872) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_eventbuilder_tags() != 22610) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_eventid_as_bytes() != 22930) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_eventid_to_bech32() != 35036) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_eventid_to_hex() != 62987) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_eventid_to_nostr_uri() != 15047) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_eventstream_next() != 5894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_events_contains() != 39963) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_events_first() != 11892) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_events_is_empty() != 16727) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_events_len() != 22082) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_events_merge() != 57155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_events_to_vec() != 14351) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filemetadata_aes_256_gcm() != 15419) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filemetadata_blurhash() != 58338) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filemetadata_dimensions() != 7956) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filemetadata_magnet() != 49047) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filemetadata_size() != 53216) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_as_json() != 6808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_as_record() != 6560) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_author() != 30570) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_authors() != 55524) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_coordinate() != 29286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_coordinates() != 2599) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_custom_tag() != 11314) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_custom_tags() != 44033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_event() != 9919) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_events() != 6127) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_hashtag() != 45839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_hashtags() != 34615) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_id() != 61970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_identifier() != 32910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_identifiers() != 38883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_ids() != 23011) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_is_empty() != 21971) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_kind() != 4634) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_kinds() != 4092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_limit() != 14746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_match_event() != 43992) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_pubkey() != 17463) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_pubkeys() != 13058) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_reference() != 5361) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_references() != 54226) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_remove_authors() != 9364) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_remove_coordinates() != 47805) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_remove_custom_tags() != 243) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_remove_events() != 30094) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_remove_hashtags() != 33949) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_remove_identifiers() != 53765) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_remove_ids() != 11079) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_remove_kinds() != 55693) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_remove_limit() != 45828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_remove_pubkeys() != 22880) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_remove_references() != 62395) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_remove_search() != 29028) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_remove_since() != 30254) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_remove_until() != 41736) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_search() != 36347) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_since() != 19595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_filter_until() != 6520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle_msg() != 15394) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_handlenotification_handle() != 42681) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_amount() != 2543) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_extra_info() != 21313) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_jobfeedbackdata_payload() != 45291) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_keys_public_key() != 21581) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_keys_secret_key() != 60506) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_keys_sign_schnorr() != 55396) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_kind_as_std() != 65021) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_kind_as_u16() != 33899) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_kind_is_addressable() != 13541) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_kind_is_ephemeral() != 12268) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_kind_is_job_request() != 21807) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_kind_is_job_result() != 3971) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_kind_is_regular() != 26650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_kind_is_replaceable() != 31494) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_localrelay_notify_event() != 34103) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_localrelay_run() != 38051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_localrelay_shutdown() != 2728) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_localrelay_url() != 24416) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_metadata_as_json() != 2258) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_metadata_as_pretty_json() != 48195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_metadata_as_record() != 2519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_get_balance() != 30742) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_get_info() != 19865) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_list_transactions() != 15654) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_lookup_invoice() != 28952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_make_invoice() != 56020) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_invoice() != 842) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_pay_keysend() != 38155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nwc_status() != 31309) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip05address_domain() != 60519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip05address_name() != 49203) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip05address_url() != 34756) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip05profile_nip46() != 41040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip05profile_public_key() != 56263) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip05profile_relays() != 9573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip19_as_enum() != 62711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_coordinate() != 31239) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_relays() != 52695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_to_bech32() != 787) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip19coordinate_to_nostr_uri() != 21870) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip19event_author() != 8504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip19event_event_id() != 9799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip19event_kind() != 12835) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip19event_relays() != 46165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip19event_to_bech32() != 12367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip19event_to_nostr_uri() != 31723) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip19profile_public_key() != 32958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip19profile_relays() != 15918) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip19profile_to_bech32() != 36717) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip19profile_to_nostr_uri() != 28973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip21_as_enum() != 7140) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip21_to_nostr_uri() != 28944) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_api_url() != 37164) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_as_json() != 57964) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_content_types() != 2290) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_delegated_to_url() != 39958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip96serverconfig_download_url() != 23548) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip96uploadrequest_authorization() != 1841) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip96uploadrequest_url() != 61137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_as_json() != 35122) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_download_url() != 58228) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_is_success() != 32550) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nip96uploadresponse_message() != 51400) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_bunker_uri() != 57336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_get_public_key() != 16592) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip04_decrypt() != 9737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip04_encrypt() != 32405) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip44_decrypt() != 57892) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_nip44_encrypt() != 7459) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_relays() != 38451) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnect_sign_event() != 11201) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_as_json() != 14883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_description() != 63846) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_icons() != 20500) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrconnectmetadata_url() != 5634) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_count() != 5629) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_delete() != 57958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_event_by_id() != 41668) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_metadata() != 5609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_query() != 62424) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_save_event() != 50750) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrdatabase_wipe() != 58001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrparser_parse() != 36801) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_backend() != 42053) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_get_public_key() != 57508) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_decrypt() != 21362) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip04_encrypt() != 56434) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_decrypt() != 9052) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_nip44_encrypt() != 24375) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrsigner_sign_event() != 15564) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_relay() != 717) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnectoptions_timeout() != 18259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_lud16() != 20036) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_public_key() != 21325) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_relays() != 29202) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_nostrwalletconnecturi_secret() != 15591) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_publickey_to_bech32() != 28181) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_publickey_to_hex() != 25698) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_publickey_to_nostr_uri() != 54491) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_querypolicy_admit_query() != 2747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_ban() != 43872) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_batch_msg() != 32031) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_connect() != 29641) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_connection_mode() != 52002) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_count_events() != 58311) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_disconnect() != 22001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_fetch_events() != 61339) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_is_connected() != 18284) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_opts() != 21198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_queue() != 23174) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_send_event() != 30621) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_send_msg() != 53871) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_stats() != 58574) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_status() != 52365) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe() != 11379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscribe_with_id() != 41014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscription() != 47719) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_subscriptions() != 31310) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_sync() != 50084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_sync_with_items() != 50768) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_try_connect() != 39036) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe() != 62991) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_unsubscribe_all() != 18626) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relay_url() != 28519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_addr() != 20999) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_auth_dm() != 45806) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_database() != 15598) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_default_filter_limit() != 28899) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_max_connections() != 13259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_max_filter_limit() != 4872) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_max_subid_length() != 35156) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_min_pow() != 24936) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_nip42() != 31708) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_port() != 42976) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_query_policy() != 34124) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_rate_limit() != 56357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaybuilder_write_policy() != 17411) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_attempts() != 52060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_received() != 157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_bytes_sent() != 64970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_connected_at() != 27772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_first_connection_timestamp() != 32759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_latency() != 14031) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_success() != 52759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayconnectionstats_success_rate() != 58744) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_as_json() != 18024) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_contact() != 33791) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_description() != 55506) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_fees() != 52643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_icon() != 37182) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_language_tags() != 5241) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_limitation() != 63667) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_name() != 54729) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_payments_url() != 50516) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_posting_policy() != 57849) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_pubkey() != 52169) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_relay_countries() != 43620) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_retention() != 48273) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_software() != 34250) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_supported_nips() != 11144) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_tags() != 65245) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayinformationdocument_version() != 38302) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags() != 29781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_num_tags_per_kind() != 54489) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size() != 17341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_event_max_size_per_kind() != 30650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaylimits_message_max_size() != 39217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaymessage_as_enum() != 673) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relaymessage_as_json() != 14562) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_adjust_retry_interval() != 25372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_ban_relay_on_mismatch() != 13665) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_connection_mode() != 24699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_limits() != 10405) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_max_avg_latency() != 58939) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_ping() != 51607) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_read() != 47081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_reconnect() != 48820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_retry_interval() != 30532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_verify_subscriptions() != 38529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayoptions_write() != 45946) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayurl_is_local_addr() != 6616) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_relayurl_is_onion() != 31914) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_request_method() != 17520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_request_params() != 39349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_saveeventstatus_is_success() != 48824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_saveeventstatus_rejection_reason() != 37739) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_secretkey_encrypt() != 49692) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_secretkey_to_bech32() != 38599) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_secretkey_to_hex() != 57941) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_get_shipping_cost() != 56592) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_name() != 13755) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_shippingmethod_regions() != 233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_singlelettertag_is_lowercase() != 53511) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_singlelettertag_is_uppercase() != 16786) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_stalldata_as_json() != 14626) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_stalldata_as_record() != 30522) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_stalldata_currency() != 40639) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_stalldata_description() != 50371) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_stalldata_id() != 34671) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_stalldata_name() != 15071) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_stalldata_shipping() != 17698) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_exit_policy() != 62279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_idle_timeout() != 9446) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeautocloseoptions_timeout() != 16202) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_subscribeoptions_close_on() != 54857) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_syncoptions_direction() != 15360) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_syncoptions_dry_run() != 15725) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_syncoptions_initial_timeout() != 19180) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tag_as_standardized() != 39092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tag_as_vec() != 22150) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tag_content() != 43772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tag_is_protected() != 61999) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tag_is_reply() != 26678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tag_is_root() != 42913) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tag_kind() != 28437) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tag_kind_str() != 21836) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tag_len() != 35144) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tag_single_letter_tag() != 50942) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_coordinates() != 39150) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_event_ids() != 44166) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_expiration() != 15697) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_filter() != 6442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_filter_standardized() != 23694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_find() != 19756) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_find_standardized() != 61199) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_first() != 16571) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_get() != 2938) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_hashtags() != 50724) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_identifier() != 44864) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_is_empty() != 16467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_last() != 22526) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_len() != 28453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_public_keys() != 15566) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_tags_to_vec() != 38520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_timestamp_add_duration() != 59895) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_timestamp_as_secs() != 7797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_timestamp_sub_duration() != 14720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_timestamp_to_human_datetime() != 24020) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_add_signature() != 33695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_as_json() != 14388) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_as_pretty_json() != 3289) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_author() != 33632) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_content() != 61788) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_created_at() != 2838) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_id() != 26673) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_kind() != 24650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_sign() != 17648) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_sign_with_keys() != 65226) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_unsignedevent_tags() != 23219) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift__none() != 31106) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift_rumor() != 9051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_unwrappedgift_sender() != 65176) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_send() != 56567) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_recv() != 39160) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_websocketadapter_close_connection() != 35891) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_writepolicy_admit_event() != 49227) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_amount() != 38837) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_event_id() != 60606) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_lnurl() != 11688) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_method_zaprequestdata_message() != 38998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_admitstatus_rejected() != 54055) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_admitstatus_success() != 33678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_client_new() != 54751) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_clientbuilder_new() != 11332) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_auth() != 45144) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_close() != 12470) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_count() != 5292) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_event() != 35014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_from_enum() != 42986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_from_json() != 27860) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_clientmessage_req() != 60557) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_clientoptions_new() != 16931) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_connection_new() != 32544) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_coordinate_new() != 25471) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_coordinate_parse() != 59337) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_encryptedsecretkey_from_bech32() != 27546) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_encryptedsecretkey_new() != 35289) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_event_from_json() != 14737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_articles_curation_set() != 36328) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_auth() != 56367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_award_badge() != 41119) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_blocked_relays() != 40799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_bookmarks() != 63306) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_bookmarks_set() != 23068) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel() != 21555) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel_metadata() != 4153) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_channel_msg() != 10299) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_comment() != 57486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_communities() != 54557) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_contact_list() != 11242) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_define_badge() != 89) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_delete() != 50417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_emoji_set() != 6114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_emojis() != 43073) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_file_metadata() != 8053) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_follow_set() != 32344) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_issue() != 26026) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_patch() != 34800) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_git_repository_announcement() != 58206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_hide_channel_msg() != 8353) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_http_auth() != 42464) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_interest_set() != 54183) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_interests() != 55071) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_feedback() != 11871) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_request() != 14986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_job_result() != 48936) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_label() != 51492) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_live_event() != 35589) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_live_event_msg() != 34422) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_long_form_text_note() != 4671) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_metadata() != 34149) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_mute_channel_user() != 64300) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_mute_list() != 34705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_new() != 61972) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_nostr_connect() != 10416) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_pinned_notes() != 5335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_private_msg_rumor() != 6901) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_product_data() != 57627) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_profile_badges() != 15894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_public_chats() != 65509) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_public_zap_request() != 49461) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_reaction() != 35984) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_relay_list() != 46091) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_relay_set() != 52775) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_report() != 9803) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_repost() != 44582) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_seal() != 55824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_search_relays() != 26737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_stall_data() != 14247) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_text_note() != 19143) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_text_note_reply() != 31849) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_videos_curation_set() != 19505) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventbuilder_zap_receipt() != 16189) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventid_from_bytes() != 63077) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventid_new() != 57964) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_eventid_parse() != 39522) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_filemetadata_new() != 27821) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_filter_from_json() != 60806) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_filter_from_record() != 32151) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_filter_new() != 58026) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_jobfeedbackdata_new() != 39189) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_keys_from_mnemonic() != 25690) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_keys_generate() != 61718) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_keys_new() != 46666) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_keys_parse() != 27763) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_kind_from_std() != 49333) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_kind_new() != 53039) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_localrelay_new() != 58754) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_metadata_from_json() != 39685) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_metadata_from_record() != 29877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nwc_new() != 24213) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nwc_with_opts() != 29036) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip05address_parse() != 52756) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip05profile_from_json() != 19324) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip19_from_bech32() != 12847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_from_bech32() != 9233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_from_nostr_uri() != 4130) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip19coordinate_new() != 2829) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_bech32() != 48940) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_event() != 59343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_from_nostr_uri() != 20420) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip19event_new() != 52064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_from_bech32() != 56532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_from_nostr_uri() != 54372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip19profile_new() != 54759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip21_parse() != 2093) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip96serverconfig_from_json() != 41163) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip96uploadrequest_create() != 51933) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nip96uploadresponse_from_json() != 22627) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnect_new() != 60022) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnectmetadata_new() != 55577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrconnecturi_parse() != 36627) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_custom() != 8545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrdatabase_lmdb() != 21752) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrgossip_in_memory() != 46331) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrparser_new() != 55036) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_custom() != 7081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_keys() != 41683) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrsigner_nostr_connect() != 3051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnectoptions_new() != 35456) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnecturi_new() != 9060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_nostrwalletconnecturi_parse() != 31940) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_publickey_from_bytes() != 38006) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_publickey_parse() != 50593) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaybuilder_new() != 36778) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relayinformationdocument_from_json() != 24725) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_disable() != 39641) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaylimits_new() != 1364) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_auth() != 49391) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_closed() != 12776) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_count() != 38897) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_eose() != 61100) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_event() != 41233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_from_enum() != 34939) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_from_json() != 52163) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_notice() != 17916) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relaymessage_ok() != 56502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relayoptions_new() != 32157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_relayurl_parse() != 11922) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_request_new() != 22154) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_request_parse() != 38336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_saveeventstatus_rejected() != 31405) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_saveeventstatus_success() != 51549) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_from_bytes() != 33002) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_generate() != 2297) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_secretkey_parse() != 41672) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_shippingmethod_new() != 54442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_singlelettertag_lowercase() != 25781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_singlelettertag_uppercase() != 26245) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_from_json() != 26421) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_from_record() != 10070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_stalldata_new() != 11283) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_subscribeautocloseoptions_new() != 39595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_subscribeoptions_new() != 56214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_syncoptions_new() != 7169) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_alt() != 61627) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_client() != 18574) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_coordinate() != 21232) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_custom() != 55533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_description() != 31007) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_event() != 3596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_event_report() != 12542) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_expiration() != 25703) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_from_standardized() != 10696) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_hashtag() != 56828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_identifier() != 5344) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_image() != 35229) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_parse() != 63294) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_pow() != 46606) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_protected() != 21460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_public_key() != 4984) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_public_key_report() != 44501) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_reference() != 43166) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_relay_metadata() != 53501) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tag_title() != 51619) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tags_from_list() != 61074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_tags_parse() != 21642) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_from_secs() != 64753) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_max() != 61689) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_min() != 59395) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_timestamp_now() != 13059) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_unsignedevent_from_json() != 8735) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_unwrappedgift_from_gift_wrap() != 4603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_websocketadapterwrapper_new() != 27365) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_sdk_ffi_checksum_constructor_zaprequestdata_new() != 63828) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitAdmitPolicy()
    uniffiCallbackInitCustomNostrDatabase()
    uniffiCallbackInitCustomNostrSigner()
    uniffiCallbackInitCustomWebSocketTransport()
    uniffiCallbackInitHandleNotification()
    uniffiCallbackInitQueryPolicy()
    uniffiCallbackInitWebSocketAdapter()
    uniffiCallbackInitWritePolicy()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureNostrSdkFfiInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all