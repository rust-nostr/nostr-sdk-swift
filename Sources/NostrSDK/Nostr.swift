// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(nostr_ffiFFI)
import nostr_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_nostr_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_nostr_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol ClientMessageProtocol : AnyObject {
    
    /**
     * Clone `ClientMessage` and convert it to `ClientMessageEnum`
     */
    func asEnum()  -> ClientMessageEnum
    
    func asJson() throws  -> String
    
}

open class ClientMessage:
    CustomDebugStringConvertible,
    Equatable,
    ClientMessageProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_clientmessage(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_clientmessage(pointer, $0) }
    }

    
    /**
     * Create new `AUTH` message
     */
public static func auth(event: Event) -> ClientMessage {
    return try!  FfiConverterTypeClientMessage.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_clientmessage_auth(
        FfiConverterTypeEvent.lower(event),$0
    )
})
}
    
    /**
     * Create new `CLOSE` message
     */
public static func close(subscriptionId: String) -> ClientMessage {
    return try!  FfiConverterTypeClientMessage.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_clientmessage_close(
        FfiConverterString.lower(subscriptionId),$0
    )
})
}
    
    /**
     * Create new `COUNT` message
     */
public static func count(subscriptionId: String, filters: [Filter]) -> ClientMessage {
    return try!  FfiConverterTypeClientMessage.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_clientmessage_count(
        FfiConverterString.lower(subscriptionId),
        FfiConverterSequenceTypeFilter.lower(filters),$0
    )
})
}
    
    /**
     * Create new `EVENT` message
     */
public static func event(event: Event) -> ClientMessage {
    return try!  FfiConverterTypeClientMessage.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_clientmessage_event(
        FfiConverterTypeEvent.lower(event),$0
    )
})
}
    
    /**
     * Convert `ClientMessageEnum` to `ClientMessage`
     */
public static func fromEnum(e: ClientMessageEnum) -> ClientMessage {
    return try!  FfiConverterTypeClientMessage.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_clientmessage_from_enum(
        FfiConverterTypeClientMessageEnum.lower(e),$0
    )
})
}
    
    /**
     * Deserialize `ClientMessage` from JSON string
     *
     * **This method NOT verify the event signature!**
     */
public static func fromJson(json: String)throws  -> ClientMessage {
    return try  FfiConverterTypeClientMessage.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_clientmessage_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    
    /**
     * Create new `REQ` message
     */
public static func req(subscriptionId: String, filters: [Filter]) -> ClientMessage {
    return try!  FfiConverterTypeClientMessage.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_clientmessage_req(
        FfiConverterString.lower(subscriptionId),
        FfiConverterSequenceTypeFilter.lower(filters),$0
    )
})
}
    

    
    /**
     * Clone `ClientMessage` and convert it to `ClientMessageEnum`
     */
open func asEnum() -> ClientMessageEnum {
    return try!  FfiConverterTypeClientMessageEnum.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_clientmessage_as_enum(self.uniffiClonePointer(),$0
    )
})
}
    
open func asJson()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_clientmessage_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_clientmessage_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: ClientMessage, other: ClientMessage) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_clientmessage_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeClientMessage.lower(other),$0
    )
}
        )
    }

}

public struct FfiConverterTypeClientMessage: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientMessage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientMessage {
        return ClientMessage(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientMessage) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientMessage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientMessage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientMessage_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientMessage {
    return try FfiConverterTypeClientMessage.lift(pointer)
}

public func FfiConverterTypeClientMessage_lower(_ value: ClientMessage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientMessage.lower(value)
}




public protocol ContactProtocol : AnyObject {
    
    func alias()  -> String?
    
    func publicKey()  -> PublicKey
    
    func relayUrl()  -> String?
    
}

open class Contact:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    ContactProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_contact(self.pointer, $0) }
    }
public convenience init(pk: PublicKey, relayUrl: String?, alias: String?) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_contact_new(
        FfiConverterTypePublicKey.lower(pk),
        FfiConverterOptionString.lower(relayUrl),
        FfiConverterOptionString.lower(alias),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_contact(pointer, $0) }
    }

    

    
open func alias() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_contact_alias(self.uniffiClonePointer(),$0
    )
})
}
    
open func publicKey() -> PublicKey {
    return try!  FfiConverterTypePublicKey.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_contact_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
open func relayUrl() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_contact_relay_url(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_contact_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Contact, other: Contact) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_contact_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeContact.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_contact_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeContact: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Contact

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Contact {
        return Contact(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Contact) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Contact {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Contact, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeContact_lift(_ pointer: UnsafeMutableRawPointer) throws -> Contact {
    return try FfiConverterTypeContact.lift(pointer)
}

public func FfiConverterTypeContact_lower(_ value: Contact) -> UnsafeMutableRawPointer {
    return FfiConverterTypeContact.lower(value)
}




/**
 * Coordinate for event (`a` tag)
 */
public protocol CoordinateProtocol : AnyObject {
    
    func identifier()  -> String
    
    func kind()  -> Kind
    
    func publicKey()  -> PublicKey
    
    func relays()  -> [String]
    
    func toBech32() throws  -> String
    
    func toNostrUri() throws  -> String
    
}

/**
 * Coordinate for event (`a` tag)
 */
open class Coordinate:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    CoordinateProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_coordinate(self.pointer, $0) }
    }
public convenience init(kind: Kind, publicKey: PublicKey) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_coordinate_new(
        FfiConverterTypeKind.lower(kind),
        FfiConverterTypePublicKey.lower(publicKey),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_coordinate(pointer, $0) }
    }

    
public static func fromBech32(bech32: String)throws  -> Coordinate {
    return try  FfiConverterTypeCoordinate.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_coordinate_from_bech32(
        FfiConverterString.lower(bech32),$0
    )
})
}
    
public static func fromNostrUri(uri: String)throws  -> Coordinate {
    return try  FfiConverterTypeCoordinate.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_coordinate_from_nostr_uri(
        FfiConverterString.lower(uri),$0
    )
})
}
    
public static func parse(coordinate: String)throws  -> Coordinate {
    return try  FfiConverterTypeCoordinate.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_coordinate_parse(
        FfiConverterString.lower(coordinate),$0
    )
})
}
    

    
open func identifier() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_coordinate_identifier(self.uniffiClonePointer(),$0
    )
})
}
    
open func kind() -> Kind {
    return try!  FfiConverterTypeKind.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_coordinate_kind(self.uniffiClonePointer(),$0
    )
})
}
    
open func publicKey() -> PublicKey {
    return try!  FfiConverterTypePublicKey.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_coordinate_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
open func relays() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_coordinate_relays(self.uniffiClonePointer(),$0
    )
})
}
    
open func toBech32()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_coordinate_to_bech32(self.uniffiClonePointer(),$0
    )
})
}
    
open func toNostrUri()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_coordinate_to_nostr_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_coordinate_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Coordinate, other: Coordinate) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_coordinate_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeCoordinate.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_coordinate_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeCoordinate: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Coordinate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Coordinate {
        return Coordinate(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Coordinate) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Coordinate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Coordinate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeCoordinate_lift(_ pointer: UnsafeMutableRawPointer) throws -> Coordinate {
    return try FfiConverterTypeCoordinate.lift(pointer)
}

public func FfiConverterTypeCoordinate_lower(_ value: Coordinate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCoordinate.lower(value)
}




/**
 * Encrypted Secret Key
 */
public protocol EncryptedSecretKeyProtocol : AnyObject {
    
    /**
     * Get encrypted secret key security
     */
    func keySecurity()  -> KeySecurity
    
    func toBech32() throws  -> String
    
    /**
     * Decrypt secret key
     */
    func toSecretKey(password: String) throws  -> SecretKey
    
    /**
     * Get encrypted secret key version
     */
    func version()  -> EncryptedSecretKeyVersion
    
}

/**
 * Encrypted Secret Key
 */
open class EncryptedSecretKey:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    EncryptedSecretKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_encryptedsecretkey(self.pointer, $0) }
    }
    /**
     * Encrypt secret key
     */
public convenience init(secretKey: SecretKey, password: String, logN: UInt8, keySecurity: KeySecurity)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_encryptedsecretkey_new(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterString.lower(password),
        FfiConverterUInt8.lower(logN),
        FfiConverterTypeKeySecurity.lower(keySecurity),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_encryptedsecretkey(pointer, $0) }
    }

    
public static func fromBech32(bech32: String)throws  -> EncryptedSecretKey {
    return try  FfiConverterTypeEncryptedSecretKey.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_encryptedsecretkey_from_bech32(
        FfiConverterString.lower(bech32),$0
    )
})
}
    

    
    /**
     * Get encrypted secret key security
     */
open func keySecurity() -> KeySecurity {
    return try!  FfiConverterTypeKeySecurity.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_encryptedsecretkey_key_security(self.uniffiClonePointer(),$0
    )
})
}
    
open func toBech32()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_encryptedsecretkey_to_bech32(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Decrypt secret key
     */
open func toSecretKey(password: String)throws  -> SecretKey {
    return try  FfiConverterTypeSecretKey.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_encryptedsecretkey_to_secret_key(self.uniffiClonePointer(),
        FfiConverterString.lower(password),$0
    )
})
}
    
    /**
     * Get encrypted secret key version
     */
open func version() -> EncryptedSecretKeyVersion {
    return try!  FfiConverterTypeEncryptedSecretKeyVersion.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_encryptedsecretkey_version(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_encryptedsecretkey_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: EncryptedSecretKey, other: EncryptedSecretKey) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_encryptedsecretkey_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeEncryptedSecretKey.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_encryptedsecretkey_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeEncryptedSecretKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EncryptedSecretKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EncryptedSecretKey {
        return EncryptedSecretKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EncryptedSecretKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedSecretKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EncryptedSecretKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeEncryptedSecretKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> EncryptedSecretKey {
    return try FfiConverterTypeEncryptedSecretKey.lift(pointer)
}

public func FfiConverterTypeEncryptedSecretKey_lower(_ value: EncryptedSecretKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEncryptedSecretKey.lower(value)
}




public protocol EventProtocol : AnyObject {
    
    func asJson() throws  -> String
    
    /**
     * Get event author (`pubkey` field)
     */
    func author()  -> PublicKey
    
    func content()  -> String
    
    /**
     * Extract coordinates from tags (`a` tag)
     *
     * **This method extract ONLY supported standard variants**
     */
    func coordinates()  -> [Coordinate]
    
    func createdAt()  -> Timestamp
    
    /**
     * Extract event IDs from tags (`e` tag)
     *
     * **This method extract ONLY supported standard variants**
     */
    func eventIds()  -> [EventId]
    
    /**
     * Get `Timestamp` expiration if set
     */
    func expiration()  -> Timestamp?
    
    func id()  -> EventId
    
    /**
     * Extract identifier (`d` tag), if exists.
     */
    func identifier()  -> String?
    
    /**
     * Check if event `Kind` is `Ephemeral`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func isEphemeral()  -> Bool
    
    /**
     * Returns `true` if the event has an expiration tag that is expired.
     * If an event has no `Expiration` tag, then it will return `false`.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/40.md>
     */
    func isExpired()  -> Bool
    
    /**
     * Check if `Kind` is a NIP90 job request
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
    func isJobRequest()  -> Bool
    
    /**
     * Check if `Kind` is a NIP90 job result
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
    func isJobResult()  -> Bool
    
    /**
     * Check if event `Kind` is `Parameterized replaceable`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func isParameterizedReplaceable()  -> Bool
    
    /**
     * Check if event `Kind` is `Regular`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func isRegular()  -> Bool
    
    /**
     * Check if event `Kind` is `Replaceable`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func isReplaceable()  -> Bool
    
    func kind()  -> Kind
    
    /**
     * Extract public keys from tags (`p` tag)
     *
     * **This method extract ONLY supported standard variants**
     */
    func publicKeys()  -> [PublicKey]
    
    func signature()  -> String
    
    func tags()  -> [Tag]
    
    /**
     * Verify both `EventId` and `Signature`
     */
    func verify()  -> Bool
    
    /**
     * Verify if the `EventId` it's composed correctly
     */
    func verifyId() throws 
    
    /**
     * Verify only event `Signature`
     */
    func verifySignature() throws 
    
}

open class Event:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    EventProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_event(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_event(pointer, $0) }
    }

    
public static func fromJson(json: String)throws  -> Event {
    return try  FfiConverterTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_event_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    

    
open func asJson()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_event_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get event author (`pubkey` field)
     */
open func author() -> PublicKey {
    return try!  FfiConverterTypePublicKey.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_author(self.uniffiClonePointer(),$0
    )
})
}
    
open func content() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_content(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Extract coordinates from tags (`a` tag)
     *
     * **This method extract ONLY supported standard variants**
     */
open func coordinates() -> [Coordinate] {
    return try!  FfiConverterSequenceTypeCoordinate.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_coordinates(self.uniffiClonePointer(),$0
    )
})
}
    
open func createdAt() -> Timestamp {
    return try!  FfiConverterTypeTimestamp.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_created_at(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Extract event IDs from tags (`e` tag)
     *
     * **This method extract ONLY supported standard variants**
     */
open func eventIds() -> [EventId] {
    return try!  FfiConverterSequenceTypeEventId.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_event_ids(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get `Timestamp` expiration if set
     */
open func expiration() -> Timestamp? {
    return try!  FfiConverterOptionTypeTimestamp.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_expiration(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> EventId {
    return try!  FfiConverterTypeEventId.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Extract identifier (`d` tag), if exists.
     */
open func identifier() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_identifier(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if event `Kind` is `Ephemeral`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
open func isEphemeral() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_is_ephemeral(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns `true` if the event has an expiration tag that is expired.
     * If an event has no `Expiration` tag, then it will return `false`.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/40.md>
     */
open func isExpired() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_is_expired(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if `Kind` is a NIP90 job request
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
open func isJobRequest() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_is_job_request(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if `Kind` is a NIP90 job result
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
open func isJobResult() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_is_job_result(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if event `Kind` is `Parameterized replaceable`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
open func isParameterizedReplaceable() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_is_parameterized_replaceable(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if event `Kind` is `Regular`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
open func isRegular() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_is_regular(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if event `Kind` is `Replaceable`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
open func isReplaceable() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_is_replaceable(self.uniffiClonePointer(),$0
    )
})
}
    
open func kind() -> Kind {
    return try!  FfiConverterTypeKind.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_kind(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Extract public keys from tags (`p` tag)
     *
     * **This method extract ONLY supported standard variants**
     */
open func publicKeys() -> [PublicKey] {
    return try!  FfiConverterSequenceTypePublicKey.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_public_keys(self.uniffiClonePointer(),$0
    )
})
}
    
open func signature() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_signature(self.uniffiClonePointer(),$0
    )
})
}
    
open func tags() -> [Tag] {
    return try!  FfiConverterSequenceTypeTag.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_tags(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Verify both `EventId` and `Signature`
     */
open func verify() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_verify(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Verify if the `EventId` it's composed correctly
     */
open func verifyId()throws  {try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_event_verify_id(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Verify only event `Signature`
     */
open func verifySignature()throws  {try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_event_verify_signature(self.uniffiClonePointer(),$0
    )
}
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Event, other: Event) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeEvent.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_event_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeEvent: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Event

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Event {
        return Event(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Event) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Event, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeEvent_lift(_ pointer: UnsafeMutableRawPointer) throws -> Event {
    return try FfiConverterTypeEvent.lift(pointer)
}

public func FfiConverterTypeEvent_lower(_ value: Event) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEvent.lower(value)
}




public protocol EventBuilderProtocol : AnyObject {
    
    /**
     * Add tags
     */
    func addTags(tags: [Tag])  -> EventBuilder
    
    /**
     * Set a custom `created_at` UNIX timestamp
     */
    func customCreatedAt(createdAt: Timestamp)  -> EventBuilder
    
    func toEvent(keys: Keys) throws  -> Event
    
    func toPowEvent(keys: Keys, difficulty: UInt8) throws  -> Event
    
    func toUnsignedEvent(publicKey: PublicKey)  -> UnsignedEvent
    
    func toUnsignedPowEvent(publicKey: PublicKey, difficulty: UInt8)  -> UnsignedEvent
    
}

open class EventBuilder:
    CustomDebugStringConvertible,
    Equatable,
    EventBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_eventbuilder(self.pointer, $0) }
    }
public convenience init(kind: Kind, content: String, tags: [Tag]) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_new(
        FfiConverterTypeKind.lower(kind),
        FfiConverterString.lower(content),
        FfiConverterSequenceTypeTag.lower(tags),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_eventbuilder(pointer, $0) }
    }

    
    /**
     * Article Curation sets
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func articlesCurationSets(list: ArticlesCuration) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_articles_curation_sets(
        FfiConverterTypeArticlesCuration.lower(list),$0
    )
})
}
    
public static func auth(challenge: String, relayUrl: String)throws  -> EventBuilder {
    return try  FfiConverterTypeEventBuilder.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_auth(
        FfiConverterString.lower(challenge),
        FfiConverterString.lower(relayUrl),$0
    )
})
}
    
public static func awardBadge(badgeDefinition: Event, awardedPubkeys: [Tag])throws  -> EventBuilder {
    return try  FfiConverterTypeEventBuilder.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_award_badge(
        FfiConverterTypeEvent.lower(badgeDefinition),
        FfiConverterSequenceTypeTag.lower(awardedPubkeys),$0
    )
})
}
    
    /**
     * Blocked relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func blockedRelays(relay: [String]) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_blocked_relays(
        FfiConverterSequenceString.lower(relay),$0
    )
})
}
    
    /**
     * Bookmarks
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func bookmarks(list: Bookmarks)throws  -> EventBuilder {
    return try  FfiConverterTypeEventBuilder.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_bookmarks(
        FfiConverterTypeBookmarks.lower(list),$0
    )
})
}
    
    /**
     * Bookmark sets
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func bookmarksSets(list: Bookmarks)throws  -> EventBuilder {
    return try  FfiConverterTypeEventBuilder.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_bookmarks_sets(
        FfiConverterTypeBookmarks.lower(list),$0
    )
})
}
    
public static func channel(metadata: Metadata) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_channel(
        FfiConverterTypeMetadata.lower(metadata),$0
    )
})
}
    
public static func channelMetadata(channelId: EventId, relayUrl: String?, metadata: Metadata)throws  -> EventBuilder {
    return try  FfiConverterTypeEventBuilder.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_channel_metadata(
        FfiConverterTypeEventId.lower(channelId),
        FfiConverterOptionString.lower(relayUrl),
        FfiConverterTypeMetadata.lower(metadata),$0
    )
})
}
    
public static func channelMsg(channelId: EventId, relayUrl: String, content: String)throws  -> EventBuilder {
    return try  FfiConverterTypeEventBuilder.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_channel_msg(
        FfiConverterTypeEventId.lower(channelId),
        FfiConverterString.lower(relayUrl),
        FfiConverterString.lower(content),$0
    )
})
}
    
    /**
     * Communities
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func communities(communities: [Coordinate]) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_communities(
        FfiConverterSequenceTypeCoordinate.lower(communities),$0
    )
})
}
    
public static func contactList(list: [Contact]) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_contact_list(
        FfiConverterSequenceTypeContact.lower(list),$0
    )
})
}
    
public static func defineBadge(badgeId: String, name: String?, description: String?, image: String?, imageDimensions: ImageDimensions?, thumbnails: [Image]) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_define_badge(
        FfiConverterString.lower(badgeId),
        FfiConverterOptionString.lower(name),
        FfiConverterOptionString.lower(description),
        FfiConverterOptionString.lower(image),
        FfiConverterOptionTypeImageDimensions.lower(imageDimensions),
        FfiConverterSequenceTypeImage.lower(thumbnails),$0
    )
})
}
    
    /**
     * Create delete event
     */
public static func delete(ids: [EventId], reason: String?) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_delete(
        FfiConverterSequenceTypeEventId.lower(ids),
        FfiConverterOptionString.lower(reason),$0
    )
})
}
    
    /**
     * Emoji sets
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func emojiSets(emojis: [EmojiInfo]) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_emoji_sets(
        FfiConverterSequenceTypeEmojiInfo.lower(emojis),$0
    )
})
}
    
    /**
     * Emojis
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func emojis(list: Emojis) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_emojis(
        FfiConverterTypeEmojis.lower(list),$0
    )
})
}
    
    /**
     * Create encrypted direct msg event
     *
     * <div class="warning"><strong>Unsecure!</strong> Deprecated in favor of NIP-17!</div>
     */
public static func encryptedDirectMsg(senderKeys: Keys, receiverPubkey: PublicKey, content: String, replyTo: EventId?)throws  -> EventBuilder {
    return try  FfiConverterTypeEventBuilder.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_encrypted_direct_msg(
        FfiConverterTypeKeys.lower(senderKeys),
        FfiConverterTypePublicKey.lower(receiverPubkey),
        FfiConverterString.lower(content),
        FfiConverterOptionTypeEventId.lower(replyTo),$0
    )
})
}
    
public static func fileMetadata(description: String, metadata: FileMetadata) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_file_metadata(
        FfiConverterString.lower(description),
        FfiConverterTypeFileMetadata.lower(metadata),$0
    )
})
}
    
    /**
     * Follow sets
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func followSets(publickKeys: [PublicKey]) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_follow_sets(
        FfiConverterSequenceTypePublicKey.lower(publickKeys),$0
    )
})
}
    
public static func hideChannelMsg(messageId: EventId, reason: String?) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_hide_channel_msg(
        FfiConverterTypeEventId.lower(messageId),
        FfiConverterOptionString.lower(reason),$0
    )
})
}
    
public static func httpAuth(data: HttpData) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_http_auth(
        FfiConverterTypeHttpData.lower(data),$0
    )
})
}
    
    /**
     * Interests
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func interests(list: Interests) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_interests(
        FfiConverterTypeInterests.lower(list),$0
    )
})
}
    
public static func jobFeedback(jobRequest: Event, status: DataVendingMachineStatus, extraInfo: String?, amountMillisats: UInt64, bolt11: String?, payload: String?) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_job_feedback(
        FfiConverterTypeEvent.lower(jobRequest),
        FfiConverterTypeDataVendingMachineStatus.lower(status),
        FfiConverterOptionString.lower(extraInfo),
        FfiConverterUInt64.lower(amountMillisats),
        FfiConverterOptionString.lower(bolt11),
        FfiConverterOptionString.lower(payload),$0
    )
})
}
    
    /**
     * Data Vending Machine - Job Request
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
public static func jobRequest(kind: Kind, tags: [Tag])throws  -> EventBuilder {
    return try  FfiConverterTypeEventBuilder.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_job_request(
        FfiConverterTypeKind.lower(kind),
        FfiConverterSequenceTypeTag.lower(tags),$0
    )
})
}
    
public static func jobResult(jobRequest: Event, amountMillisats: UInt64, bolt11: String?)throws  -> EventBuilder {
    return try  FfiConverterTypeEventBuilder.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_job_result(
        FfiConverterTypeEvent.lower(jobRequest),
        FfiConverterUInt64.lower(amountMillisats),
        FfiConverterOptionString.lower(bolt11),$0
    )
})
}
    
    /**
     * Label
     *
     * <https://github.com/nostr-protocol/nips/blob/master/32.md>
     */
public static func label(labelNamespace: String, labels: [String]) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_label(
        FfiConverterString.lower(labelNamespace),
        FfiConverterSequenceString.lower(labels),$0
    )
})
}
    
public static func liveEvent(liveEvent: LiveEvent) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event(
        FfiConverterTypeLiveEvent.lower(liveEvent),$0
    )
})
}
    
public static func liveEventMsg(liveEventId: String, liveEventHost: PublicKey, content: String, relayUrl: String?, tags: [Tag])throws  -> EventBuilder {
    return try  FfiConverterTypeEventBuilder.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event_msg(
        FfiConverterString.lower(liveEventId),
        FfiConverterTypePublicKey.lower(liveEventHost),
        FfiConverterString.lower(content),
        FfiConverterOptionString.lower(relayUrl),
        FfiConverterSequenceTypeTag.lower(tags),$0
    )
})
}
    
public static func longFormTextNote(content: String, tags: [Tag]) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_long_form_text_note(
        FfiConverterString.lower(content),
        FfiConverterSequenceTypeTag.lower(tags),$0
    )
})
}
    
public static func metadata(metadata: Metadata) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_metadata(
        FfiConverterTypeMetadata.lower(metadata),$0
    )
})
}
    
public static func muteChannelUser(publicKey: PublicKey, reason: String?) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_mute_channel_user(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterOptionString.lower(reason),$0
    )
})
}
    
    /**
     * Mute list
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func muteList(list: MuteList) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_mute_list(
        FfiConverterTypeMuteList.lower(list),$0
    )
})
}
    
public static func nostrConnect(senderKeys: Keys, receiverPubkey: PublicKey, msg: NostrConnectMessage)throws  -> EventBuilder {
    return try  FfiConverterTypeEventBuilder.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_nostr_connect(
        FfiConverterTypeKeys.lower(senderKeys),
        FfiConverterTypePublicKey.lower(receiverPubkey),
        FfiConverterTypeNostrConnectMessage.lower(msg),$0
    )
})
}
    
    /**
     * Pinned notes
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func pinnedNotes(ids: [EventId]) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_pinned_notes(
        FfiConverterSequenceTypeEventId.lower(ids),$0
    )
})
}
    
    /**
     * Private Direct message rumor
     *
     * <div class="warning">
     * This constructor compose ONLY the rumor for the private direct message!
     * NOT USE THIS IF YOU DON'T KNOW WHAT YOU ARE DOING!
     * </div>
     *
     * <https://github.com/nostr-protocol/nips/blob/master/17.md>
     */
public static func privateMsgRumor(receiver: PublicKey, message: String, replyTo: EventId? = nil) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_private_msg_rumor(
        FfiConverterTypePublicKey.lower(receiver),
        FfiConverterString.lower(message),
        FfiConverterOptionTypeEventId.lower(replyTo),$0
    )
})
}
    
public static func productData(data: ProductData) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_product_data(
        FfiConverterTypeProductData.lower(data),$0
    )
})
}
    
public static func profileBadges(badgeDefinitions: [Event], badgeAwards: [Event], pubkeyAwarded: PublicKey)throws  -> EventBuilder {
    return try  FfiConverterTypeEventBuilder.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_profile_badges(
        FfiConverterSequenceTypeEvent.lower(badgeDefinitions),
        FfiConverterSequenceTypeEvent.lower(badgeAwards),
        FfiConverterTypePublicKey.lower(pubkeyAwarded),$0
    )
})
}
    
    /**
     * Public chats
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func publicChats(chat: [EventId]) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_public_chats(
        FfiConverterSequenceTypeEventId.lower(chat),$0
    )
})
}
    
    /**
     * Create **public** zap request event
     *
     * **This event MUST NOT be broadcasted to relays**, instead must be sent to a recipient's LNURL pay callback url.
     *
     * To build a **private** or **anonymous** zap request use `nip57_private_zap_request(...)` or `nip57_anonymous_zap_request(...)` functions.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/57.md>
     */
public static func publicZapRequest(data: ZapRequestData) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_public_zap_request(
        FfiConverterTypeZapRequestData.lower(data),$0
    )
})
}
    
    /**
     * Add reaction (like/upvote, dislike/downvote or emoji) to an event
     */
public static func reaction(event: Event, reaction: String) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_reaction(
        FfiConverterTypeEvent.lower(event),
        FfiConverterString.lower(reaction),$0
    )
})
}
    
    /**
     * Add reaction (like/upvote, dislike/downvote or emoji) to an event
     */
public static func reactionExtended(eventId: EventId, publicKey: PublicKey, kind: Kind, reaction: String) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_reaction_extended(
        FfiConverterTypeEventId.lower(eventId),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterTypeKind.lower(kind),
        FfiConverterString.lower(reaction),$0
    )
})
}
    
public static func relayList(map: [String: RelayMetadata?])throws  -> EventBuilder {
    return try  FfiConverterTypeEventBuilder.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_relay_list(
        FfiConverterDictionaryStringOptionTypeRelayMetadata.lower(map),$0
    )
})
}
    
    /**
     * Relay sets
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func relaySets(relay: [String]) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_relay_sets(
        FfiConverterSequenceString.lower(relay),$0
    )
})
}
    
public static func report(tags: [Tag], content: String) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_report(
        FfiConverterSequenceTypeTag.lower(tags),
        FfiConverterString.lower(content),$0
    )
})
}
    
public static func repost(event: Event, relayUrl: String?) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_repost(
        FfiConverterTypeEvent.lower(event),
        FfiConverterOptionString.lower(relayUrl),$0
    )
})
}
    
    /**
     * Search relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func searchRelays(relay: [String]) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_search_relays(
        FfiConverterSequenceString.lower(relay),$0
    )
})
}
    
public static func stallData(data: StallData) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_stall_data(
        FfiConverterTypeStallData.lower(data),$0
    )
})
}
    
public static func textNote(content: String, tags: [Tag]) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_text_note(
        FfiConverterString.lower(content),
        FfiConverterSequenceTypeTag.lower(tags),$0
    )
})
}
    
    /**
     * Text note reply
     *
     * If no `root` is passed, the `rely_to` will be used for root `e` tag.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/10.md>
     */
public static func textNoteReply(content: String, replyTo: Event, root: Event?, relayUrl: String?) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_text_note_reply(
        FfiConverterString.lower(content),
        FfiConverterTypeEvent.lower(replyTo),
        FfiConverterOptionTypeEvent.lower(root),
        FfiConverterOptionString.lower(relayUrl),$0
    )
})
}
    
    /**
     * Videos Curation sets
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
public static func videosCurationSets(video: [Coordinate]) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_videos_curation_sets(
        FfiConverterSequenceTypeCoordinate.lower(video),$0
    )
})
}
    
public static func zapReceipt(bolt11: String, preimage: String?, zapRequest: Event) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_zap_receipt(
        FfiConverterString.lower(bolt11),
        FfiConverterOptionString.lower(preimage),
        FfiConverterTypeEvent.lower(zapRequest),$0
    )
})
}
    

    
    /**
     * Add tags
     */
open func addTags(tags: [Tag]) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_eventbuilder_add_tags(self.uniffiClonePointer(),
        FfiConverterSequenceTypeTag.lower(tags),$0
    )
})
}
    
    /**
     * Set a custom `created_at` UNIX timestamp
     */
open func customCreatedAt(createdAt: Timestamp) -> EventBuilder {
    return try!  FfiConverterTypeEventBuilder.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_eventbuilder_custom_created_at(self.uniffiClonePointer(),
        FfiConverterTypeTimestamp.lower(createdAt),$0
    )
})
}
    
open func toEvent(keys: Keys)throws  -> Event {
    return try  FfiConverterTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_eventbuilder_to_event(self.uniffiClonePointer(),
        FfiConverterTypeKeys.lower(keys),$0
    )
})
}
    
open func toPowEvent(keys: Keys, difficulty: UInt8)throws  -> Event {
    return try  FfiConverterTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_eventbuilder_to_pow_event(self.uniffiClonePointer(),
        FfiConverterTypeKeys.lower(keys),
        FfiConverterUInt8.lower(difficulty),$0
    )
})
}
    
open func toUnsignedEvent(publicKey: PublicKey) -> UnsignedEvent {
    return try!  FfiConverterTypeUnsignedEvent.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_event(self.uniffiClonePointer(),
        FfiConverterTypePublicKey.lower(publicKey),$0
    )
})
}
    
open func toUnsignedPowEvent(publicKey: PublicKey, difficulty: UInt8) -> UnsignedEvent {
    return try!  FfiConverterTypeUnsignedEvent.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_pow_event(self.uniffiClonePointer(),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterUInt8.lower(difficulty),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_eventbuilder_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: EventBuilder, other: EventBuilder) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_eventbuilder_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeEventBuilder.lower(other),$0
    )
}
        )
    }

}

public struct FfiConverterTypeEventBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeEventBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBuilder {
    return try FfiConverterTypeEventBuilder.lift(pointer)
}

public func FfiConverterTypeEventBuilder_lower(_ value: EventBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventBuilder.lower(value)
}




public protocol EventIdProtocol : AnyObject {
    
    func asBytes()  -> Data
    
    func toBech32() throws  -> String
    
    func toHex()  -> String
    
    func toNostrUri() throws  -> String
    
}

open class EventId:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    EventIdProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_eventid(self.pointer, $0) }
    }
public convenience init(publicKey: PublicKey, createdAt: Timestamp, kind: Kind, tags: [Tag], content: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventid_new(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterTypeTimestamp.lower(createdAt),
        FfiConverterTypeKind.lower(kind),
        FfiConverterSequenceTypeTag.lower(tags),
        FfiConverterString.lower(content),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_eventid(pointer, $0) }
    }

    
public static func fromBech32(bech32: String)throws  -> EventId {
    return try  FfiConverterTypeEventId.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventid_from_bech32(
        FfiConverterString.lower(bech32),$0
    )
})
}
    
public static func fromBytes(bytes: Data)throws  -> EventId {
    return try  FfiConverterTypeEventId.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventid_from_bytes(
        FfiConverterData.lower(bytes),$0
    )
})
}
    
public static func fromHex(hex: String)throws  -> EventId {
    return try  FfiConverterTypeEventId.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventid_from_hex(
        FfiConverterString.lower(hex),$0
    )
})
}
    
public static func fromNostrUri(uri: String)throws  -> EventId {
    return try  FfiConverterTypeEventId.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventid_from_nostr_uri(
        FfiConverterString.lower(uri),$0
    )
})
}
    
    /**
     * Try to parse event ID from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
     */
public static func parse(id: String)throws  -> EventId {
    return try  FfiConverterTypeEventId.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventid_parse(
        FfiConverterString.lower(id),$0
    )
})
}
    

    
open func asBytes() -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_eventid_as_bytes(self.uniffiClonePointer(),$0
    )
})
}
    
open func toBech32()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_eventid_to_bech32(self.uniffiClonePointer(),$0
    )
})
}
    
open func toHex() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_eventid_to_hex(self.uniffiClonePointer(),$0
    )
})
}
    
open func toNostrUri()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_eventid_to_nostr_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_eventid_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: EventId, other: EventId) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_eventid_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeEventId.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_eventid_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeEventId: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventId

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventId {
        return EventId(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventId) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventId {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventId, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeEventId_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventId {
    return try FfiConverterTypeEventId.lift(pointer)
}

public func FfiConverterTypeEventId_lower(_ value: EventId) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventId.lower(value)
}




public protocol FileMetadataProtocol : AnyObject {
    
    func aes256Gcm(key: String, iv: String)  -> FileMetadata
    
    /**
     * Add blurhash
     */
    func blurhash(blurhash: String)  -> FileMetadata
    
    /**
     * Add file size (pixels)
     */
    func dimensions(dim: ImageDimensions)  -> FileMetadata
    
    /**
     * Add magnet
     */
    func magnet(magnet: String)  -> FileMetadata
    
    /**
     * Add file size (bytes)
     */
    func size(size: UInt64)  -> FileMetadata
    
}

open class FileMetadata:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    FileMetadataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_filemetadata(self.pointer, $0) }
    }
public convenience init(url: String, mimeType: String, hash: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_filemetadata_new(
        FfiConverterString.lower(url),
        FfiConverterString.lower(mimeType),
        FfiConverterString.lower(hash),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_filemetadata(pointer, $0) }
    }

    

    
open func aes256Gcm(key: String, iv: String) -> FileMetadata {
    return try!  FfiConverterTypeFileMetadata.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filemetadata_aes_256_gcm(self.uniffiClonePointer(),
        FfiConverterString.lower(key),
        FfiConverterString.lower(iv),$0
    )
})
}
    
    /**
     * Add blurhash
     */
open func blurhash(blurhash: String) -> FileMetadata {
    return try!  FfiConverterTypeFileMetadata.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filemetadata_blurhash(self.uniffiClonePointer(),
        FfiConverterString.lower(blurhash),$0
    )
})
}
    
    /**
     * Add file size (pixels)
     */
open func dimensions(dim: ImageDimensions) -> FileMetadata {
    return try!  FfiConverterTypeFileMetadata.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filemetadata_dimensions(self.uniffiClonePointer(),
        FfiConverterTypeImageDimensions.lower(dim),$0
    )
})
}
    
    /**
     * Add magnet
     */
open func magnet(magnet: String) -> FileMetadata {
    return try!  FfiConverterTypeFileMetadata.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filemetadata_magnet(self.uniffiClonePointer(),
        FfiConverterString.lower(magnet),$0
    )
})
}
    
    /**
     * Add file size (bytes)
     */
open func size(size: UInt64) -> FileMetadata {
    return try!  FfiConverterTypeFileMetadata.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filemetadata_size(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(size),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_filemetadata_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: FileMetadata, other: FileMetadata) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_filemetadata_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeFileMetadata.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_filemetadata_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeFileMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FileMetadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FileMetadata {
        return FileMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FileMetadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FileMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeFileMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> FileMetadata {
    return try FfiConverterTypeFileMetadata.lift(pointer)
}

public func FfiConverterTypeFileMetadata_lower(_ value: FileMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFileMetadata.lower(value)
}




public protocol FilterProtocol : AnyObject {
    
    func asJson() throws  -> String
    
    func asRecord()  -> FilterRecord
    
    /**
     * Add event author Public Key
     */
    func author(author: PublicKey)  -> Filter
    
    func authors(authors: [PublicKey])  -> Filter
    
    func customTag(tag: SingleLetterTag, content: [String])  -> Filter
    
    /**
     * Add event ID (`e` tag)
     */
    func event(eventId: EventId)  -> Filter
    
    /**
     * Add event IDs (`e` tag)
     */
    func events(ids: [EventId])  -> Filter
    
    func hashtag(hashtag: String)  -> Filter
    
    func hashtags(hashtags: [String])  -> Filter
    
    func id(id: EventId)  -> Filter
    
    func identifier(identifier: String)  -> Filter
    
    func identifiers(identifiers: [String])  -> Filter
    
    func ids(ids: [EventId])  -> Filter
    
    func isEmpty()  -> Bool
    
    func kind(kind: Kind)  -> Filter
    
    func kinds(kinds: [Kind])  -> Filter
    
    func limit(limit: UInt64)  -> Filter
    
    /**
     * Determine if `Filter` match given `Event`.
     *
     * The `search` filed is not supported yet!
     */
    func matchEvent(event: Event)  -> Bool
    
    /**
     * Add Public Key (`p` tag)
     */
    func pubkey(pubkey: PublicKey)  -> Filter
    
    /**
     * Add Public Keys (`p` tag)
     */
    func pubkeys(pubkeys: [PublicKey])  -> Filter
    
    func reference(reference: String)  -> Filter
    
    func references(references: [String])  -> Filter
    
    func removeAuthors(authors: [PublicKey])  -> Filter
    
    func removeCustomTag(tag: SingleLetterTag, content: [String])  -> Filter
    
    func removeEvents(ids: [EventId])  -> Filter
    
    func removeHashtags(hashtags: [String])  -> Filter
    
    func removeIdentifiers(identifiers: [String])  -> Filter
    
    func removeIds(ids: [EventId])  -> Filter
    
    func removeKinds(kinds: [Kind])  -> Filter
    
    func removeLimit()  -> Filter
    
    func removePubkeys(pubkeys: [PublicKey])  -> Filter
    
    func removeReferences(references: [String])  -> Filter
    
    func removeSearch()  -> Filter
    
    func removeSince()  -> Filter
    
    func removeUntil()  -> Filter
    
    func search(text: String)  -> Filter
    
    func since(timestamp: Timestamp)  -> Filter
    
    func until(timestamp: Timestamp)  -> Filter
    
}

open class Filter:
    CustomDebugStringConvertible,
    Equatable,
    FilterProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_filter(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_filter_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_filter(pointer, $0) }
    }

    
public static func fromJson(json: String)throws  -> Filter {
    return try  FfiConverterTypeFilter.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_filter_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    
public static func fromRecord(record: FilterRecord) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_filter_from_record(
        FfiConverterTypeFilterRecord.lower(record),$0
    )
})
}
    

    
open func asJson()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_filter_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
open func asRecord() -> FilterRecord {
    return try!  FfiConverterTypeFilterRecord.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_as_record(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Add event author Public Key
     */
open func author(author: PublicKey) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_author(self.uniffiClonePointer(),
        FfiConverterTypePublicKey.lower(author),$0
    )
})
}
    
open func authors(authors: [PublicKey]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_authors(self.uniffiClonePointer(),
        FfiConverterSequenceTypePublicKey.lower(authors),$0
    )
})
}
    
open func customTag(tag: SingleLetterTag, content: [String]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_custom_tag(self.uniffiClonePointer(),
        FfiConverterTypeSingleLetterTag.lower(tag),
        FfiConverterSequenceString.lower(content),$0
    )
})
}
    
    /**
     * Add event ID (`e` tag)
     */
open func event(eventId: EventId) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_event(self.uniffiClonePointer(),
        FfiConverterTypeEventId.lower(eventId),$0
    )
})
}
    
    /**
     * Add event IDs (`e` tag)
     */
open func events(ids: [EventId]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_events(self.uniffiClonePointer(),
        FfiConverterSequenceTypeEventId.lower(ids),$0
    )
})
}
    
open func hashtag(hashtag: String) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_hashtag(self.uniffiClonePointer(),
        FfiConverterString.lower(hashtag),$0
    )
})
}
    
open func hashtags(hashtags: [String]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_hashtags(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(hashtags),$0
    )
})
}
    
open func id(id: EventId) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_id(self.uniffiClonePointer(),
        FfiConverterTypeEventId.lower(id),$0
    )
})
}
    
open func identifier(identifier: String) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_identifier(self.uniffiClonePointer(),
        FfiConverterString.lower(identifier),$0
    )
})
}
    
open func identifiers(identifiers: [String]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_identifiers(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(identifiers),$0
    )
})
}
    
open func ids(ids: [EventId]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_ids(self.uniffiClonePointer(),
        FfiConverterSequenceTypeEventId.lower(ids),$0
    )
})
}
    
open func isEmpty() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_is_empty(self.uniffiClonePointer(),$0
    )
})
}
    
open func kind(kind: Kind) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_kind(self.uniffiClonePointer(),
        FfiConverterTypeKind.lower(kind),$0
    )
})
}
    
open func kinds(kinds: [Kind]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_kinds(self.uniffiClonePointer(),
        FfiConverterSequenceTypeKind.lower(kinds),$0
    )
})
}
    
open func limit(limit: UInt64) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_limit(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(limit),$0
    )
})
}
    
    /**
     * Determine if `Filter` match given `Event`.
     *
     * The `search` filed is not supported yet!
     */
open func matchEvent(event: Event) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_match_event(self.uniffiClonePointer(),
        FfiConverterTypeEvent.lower(event),$0
    )
})
}
    
    /**
     * Add Public Key (`p` tag)
     */
open func pubkey(pubkey: PublicKey) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_pubkey(self.uniffiClonePointer(),
        FfiConverterTypePublicKey.lower(pubkey),$0
    )
})
}
    
    /**
     * Add Public Keys (`p` tag)
     */
open func pubkeys(pubkeys: [PublicKey]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_pubkeys(self.uniffiClonePointer(),
        FfiConverterSequenceTypePublicKey.lower(pubkeys),$0
    )
})
}
    
open func reference(reference: String) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_reference(self.uniffiClonePointer(),
        FfiConverterString.lower(reference),$0
    )
})
}
    
open func references(references: [String]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_references(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(references),$0
    )
})
}
    
open func removeAuthors(authors: [PublicKey]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_remove_authors(self.uniffiClonePointer(),
        FfiConverterSequenceTypePublicKey.lower(authors),$0
    )
})
}
    
open func removeCustomTag(tag: SingleLetterTag, content: [String]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_remove_custom_tag(self.uniffiClonePointer(),
        FfiConverterTypeSingleLetterTag.lower(tag),
        FfiConverterSequenceString.lower(content),$0
    )
})
}
    
open func removeEvents(ids: [EventId]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_remove_events(self.uniffiClonePointer(),
        FfiConverterSequenceTypeEventId.lower(ids),$0
    )
})
}
    
open func removeHashtags(hashtags: [String]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_remove_hashtags(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(hashtags),$0
    )
})
}
    
open func removeIdentifiers(identifiers: [String]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_remove_identifiers(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(identifiers),$0
    )
})
}
    
open func removeIds(ids: [EventId]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_remove_ids(self.uniffiClonePointer(),
        FfiConverterSequenceTypeEventId.lower(ids),$0
    )
})
}
    
open func removeKinds(kinds: [Kind]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_remove_kinds(self.uniffiClonePointer(),
        FfiConverterSequenceTypeKind.lower(kinds),$0
    )
})
}
    
open func removeLimit() -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_remove_limit(self.uniffiClonePointer(),$0
    )
})
}
    
open func removePubkeys(pubkeys: [PublicKey]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_remove_pubkeys(self.uniffiClonePointer(),
        FfiConverterSequenceTypePublicKey.lower(pubkeys),$0
    )
})
}
    
open func removeReferences(references: [String]) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_remove_references(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(references),$0
    )
})
}
    
open func removeSearch() -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_remove_search(self.uniffiClonePointer(),$0
    )
})
}
    
open func removeSince() -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_remove_since(self.uniffiClonePointer(),$0
    )
})
}
    
open func removeUntil() -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_remove_until(self.uniffiClonePointer(),$0
    )
})
}
    
open func search(text: String) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_search(self.uniffiClonePointer(),
        FfiConverterString.lower(text),$0
    )
})
}
    
open func since(timestamp: Timestamp) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_since(self.uniffiClonePointer(),
        FfiConverterTypeTimestamp.lower(timestamp),$0
    )
})
}
    
open func until(timestamp: Timestamp) -> Filter {
    return try!  FfiConverterTypeFilter.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_until(self.uniffiClonePointer(),
        FfiConverterTypeTimestamp.lower(timestamp),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Filter, other: Filter) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_filter_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeFilter.lower(other),$0
    )
}
        )
    }

}

public struct FfiConverterTypeFilter: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Filter

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Filter {
        return Filter(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Filter) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Filter {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Filter, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeFilter_lift(_ pointer: UnsafeMutableRawPointer) throws -> Filter {
    return try FfiConverterTypeFilter.lift(pointer)
}

public func FfiConverterTypeFilter_lower(_ value: Filter) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFilter.lower(value)
}




public protocol ImageDimensionsProtocol : AnyObject {
    
    func height()  -> UInt64
    
    func width()  -> UInt64
    
}

open class ImageDimensions:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    ImageDimensionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_imagedimensions(self.pointer, $0) }
    }
public convenience init(width: UInt64, height: UInt64) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_imagedimensions_new(
        FfiConverterUInt64.lower(width),
        FfiConverterUInt64.lower(height),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_imagedimensions(pointer, $0) }
    }

    

    
open func height() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_imagedimensions_height(self.uniffiClonePointer(),$0
    )
})
}
    
open func width() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_imagedimensions_width(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_imagedimensions_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: ImageDimensions, other: ImageDimensions) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_imagedimensions_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeImageDimensions.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_imagedimensions_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeImageDimensions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ImageDimensions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ImageDimensions {
        return ImageDimensions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ImageDimensions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageDimensions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ImageDimensions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeImageDimensions_lift(_ pointer: UnsafeMutableRawPointer) throws -> ImageDimensions {
    return try FfiConverterTypeImageDimensions.lift(pointer)
}

public func FfiConverterTypeImageDimensions_lower(_ value: ImageDimensions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeImageDimensions.lower(value)
}




public protocol KeysProtocol : AnyObject {
    
    func publicKey()  -> PublicKey
    
    func secretKey() throws  -> SecretKey
    
    func signSchnorr(message: Data) throws  -> String
    
}

open class Keys:
    CustomDebugStringConvertible,
    Equatable,
    KeysProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_keys(self.pointer, $0) }
    }
public convenience init(secretKey: SecretKey) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_keys_new(
        FfiConverterTypeSecretKey.lower(secretKey),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_keys(pointer, $0) }
    }

    
    /**
     * Derive `Keys` from BIP-39 mnemonics (ENGLISH wordlist).
     *
     * <https://github.com/nostr-protocol/nips/blob/master/06.md>
     */
public static func fromMnemonic(mnemonic: String, passphrase: String?)throws  -> Keys {
    return try  FfiConverterTypeKeys.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_keys_from_mnemonic(
        FfiConverterString.lower(mnemonic),
        FfiConverterOptionString.lower(passphrase),$0
    )
})
}
    
    /**
     * Derive `Keys` from BIP-39 mnemonics with **custom** `account`, `type` and/or `index` (ENGLISH wordlist).
     *
     * <https://github.com/nostr-protocol/nips/blob/master/06.md>
     */
public static func fromMnemonicAdvanced(mnemonic: String, passphrase: String?, account: UInt32?, typ: UInt32?, index: UInt32?)throws  -> Keys {
    return try  FfiConverterTypeKeys.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_keys_from_mnemonic_advanced(
        FfiConverterString.lower(mnemonic),
        FfiConverterOptionString.lower(passphrase),
        FfiConverterOptionUInt32.lower(account),
        FfiConverterOptionUInt32.lower(typ),
        FfiConverterOptionUInt32.lower(index),$0
    )
})
}
    
    /**
     * Derive `Keys` from BIP-39 mnemonics with **custom account** (ENGLISH wordlist).
     *
     * <https://github.com/nostr-protocol/nips/blob/master/06.md>
     */
public static func fromMnemonicWithAccount(mnemonic: String, passphrase: String?, account: UInt32?)throws  -> Keys {
    return try  FfiConverterTypeKeys.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_keys_from_mnemonic_with_account(
        FfiConverterString.lower(mnemonic),
        FfiConverterOptionString.lower(passphrase),
        FfiConverterOptionUInt32.lower(account),$0
    )
})
}
    
public static func fromPublicKey(publicKey: PublicKey) -> Keys {
    return try!  FfiConverterTypeKeys.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_keys_from_public_key(
        FfiConverterTypePublicKey.lower(publicKey),$0
    )
})
}
    
    /**
     * Generate random `Keys`
     */
public static func generate() -> Keys {
    return try!  FfiConverterTypeKeys.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_keys_generate($0
    )
})
}
    
    /**
     * Try to parse keys from **secret key** `hex` or `bech32`
     */
public static func parse(secretKey: String)throws  -> Keys {
    return try  FfiConverterTypeKeys.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_keys_parse(
        FfiConverterString.lower(secretKey),$0
    )
})
}
    
public static func vanity(prefixes: [String], bech32: Bool, numCores: UInt8)throws  -> Keys {
    return try  FfiConverterTypeKeys.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_keys_vanity(
        FfiConverterSequenceString.lower(prefixes),
        FfiConverterBool.lower(bech32),
        FfiConverterUInt8.lower(numCores),$0
    )
})
}
    

    
open func publicKey() -> PublicKey {
    return try!  FfiConverterTypePublicKey.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_keys_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
open func secretKey()throws  -> SecretKey {
    return try  FfiConverterTypeSecretKey.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_keys_secret_key(self.uniffiClonePointer(),$0
    )
})
}
    
open func signSchnorr(message: Data)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_keys_sign_schnorr(self.uniffiClonePointer(),
        FfiConverterData.lower(message),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_keys_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Keys, other: Keys) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_keys_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeKeys.lower(other),$0
    )
}
        )
    }

}

public struct FfiConverterTypeKeys: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Keys

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Keys {
        return Keys(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Keys) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Keys {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Keys, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeKeys_lift(_ pointer: UnsafeMutableRawPointer) throws -> Keys {
    return try FfiConverterTypeKeys.lift(pointer)
}

public func FfiConverterTypeKeys_lower(_ value: Keys) -> UnsafeMutableRawPointer {
    return FfiConverterTypeKeys.lower(value)
}




/**
 * Event Kind
 */
public protocol KindProtocol : AnyObject {
    
    func asEnum()  -> KindEnum
    
    /**
     * Get kind as 16-bit unsigned number
     */
    func asU16()  -> UInt16
    
    /**
     * Get kind as 64-bit unsigned number
     */
    func asU64()  -> UInt64
    
}

/**
 * Event Kind
 */
open class Kind:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    KindProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_kind(self.pointer, $0) }
    }
public convenience init(kind: UInt16) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_kind_new(
        FfiConverterUInt16.lower(kind),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_kind(pointer, $0) }
    }

    
public static func fromEnum(e: KindEnum) -> Kind {
    return try!  FfiConverterTypeKind.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_kind_from_enum(
        FfiConverterTypeKindEnum.lower(e),$0
    )
})
}
    

    
open func asEnum() -> KindEnum {
    return try!  FfiConverterTypeKindEnum.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_kind_as_enum(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get kind as 16-bit unsigned number
     */
open func asU16() -> UInt16 {
    return try!  FfiConverterUInt16.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_kind_as_u16(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get kind as 64-bit unsigned number
     */
open func asU64() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_kind_as_u64(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_kind_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Kind, other: Kind) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_kind_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeKind.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_kind_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeKind: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Kind

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Kind {
        return Kind(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Kind) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Kind {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Kind, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeKind_lift(_ pointer: UnsafeMutableRawPointer) throws -> Kind {
    return try FfiConverterTypeKind.lift(pointer)
}

public func FfiConverterTypeKind_lower(_ value: Kind) -> UnsafeMutableRawPointer {
    return FfiConverterTypeKind.lower(value)
}




public protocol MetadataProtocol : AnyObject {
    
    func asJson() throws  -> String
    
    func asRecord()  -> MetadataRecord
    
    func getAbout()  -> String?
    
    func getBanner()  -> String?
    
    func getCustomField(key: String) throws  -> JsonValue?
    
    func getDisplayName()  -> String?
    
    func getLud06()  -> String?
    
    func getLud16()  -> String?
    
    func getName()  -> String?
    
    func getNip05()  -> String?
    
    func getPicture()  -> String?
    
    func getWebsite()  -> String?
    
    func setAbout(about: String)  -> Metadata
    
    func setBanner(banner: String) throws  -> Metadata
    
    func setCustomField(key: String, value: JsonValue) throws  -> Metadata
    
    func setDisplayName(displayName: String)  -> Metadata
    
    func setLud06(lud06: String)  -> Metadata
    
    func setLud16(lud16: String)  -> Metadata
    
    func setName(name: String)  -> Metadata
    
    func setNip05(nip05: String)  -> Metadata
    
    func setPicture(picture: String) throws  -> Metadata
    
    func setWebsite(website: String) throws  -> Metadata
    
}

open class Metadata:
    CustomDebugStringConvertible,
    Equatable,
    MetadataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_metadata(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_metadata_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_metadata(pointer, $0) }
    }

    
public static func fromJson(json: String)throws  -> Metadata {
    return try  FfiConverterTypeMetadata.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_metadata_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    
public static func fromRecord(r: MetadataRecord) -> Metadata {
    return try!  FfiConverterTypeMetadata.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_metadata_from_record(
        FfiConverterTypeMetadataRecord.lower(r),$0
    )
})
}
    

    
open func asJson()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_metadata_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
open func asRecord() -> MetadataRecord {
    return try!  FfiConverterTypeMetadataRecord.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_as_record(self.uniffiClonePointer(),$0
    )
})
}
    
open func getAbout() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_get_about(self.uniffiClonePointer(),$0
    )
})
}
    
open func getBanner() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_get_banner(self.uniffiClonePointer(),$0
    )
})
}
    
open func getCustomField(key: String)throws  -> JsonValue? {
    return try  FfiConverterOptionTypeJsonValue.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_metadata_get_custom_field(self.uniffiClonePointer(),
        FfiConverterString.lower(key),$0
    )
})
}
    
open func getDisplayName() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_get_display_name(self.uniffiClonePointer(),$0
    )
})
}
    
open func getLud06() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_get_lud06(self.uniffiClonePointer(),$0
    )
})
}
    
open func getLud16() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_get_lud16(self.uniffiClonePointer(),$0
    )
})
}
    
open func getName() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_get_name(self.uniffiClonePointer(),$0
    )
})
}
    
open func getNip05() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_get_nip05(self.uniffiClonePointer(),$0
    )
})
}
    
open func getPicture() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_get_picture(self.uniffiClonePointer(),$0
    )
})
}
    
open func getWebsite() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_get_website(self.uniffiClonePointer(),$0
    )
})
}
    
open func setAbout(about: String) -> Metadata {
    return try!  FfiConverterTypeMetadata.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_set_about(self.uniffiClonePointer(),
        FfiConverterString.lower(about),$0
    )
})
}
    
open func setBanner(banner: String)throws  -> Metadata {
    return try  FfiConverterTypeMetadata.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_metadata_set_banner(self.uniffiClonePointer(),
        FfiConverterString.lower(banner),$0
    )
})
}
    
open func setCustomField(key: String, value: JsonValue)throws  -> Metadata {
    return try  FfiConverterTypeMetadata.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_metadata_set_custom_field(self.uniffiClonePointer(),
        FfiConverterString.lower(key),
        FfiConverterTypeJsonValue.lower(value),$0
    )
})
}
    
open func setDisplayName(displayName: String) -> Metadata {
    return try!  FfiConverterTypeMetadata.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_set_display_name(self.uniffiClonePointer(),
        FfiConverterString.lower(displayName),$0
    )
})
}
    
open func setLud06(lud06: String) -> Metadata {
    return try!  FfiConverterTypeMetadata.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_set_lud06(self.uniffiClonePointer(),
        FfiConverterString.lower(lud06),$0
    )
})
}
    
open func setLud16(lud16: String) -> Metadata {
    return try!  FfiConverterTypeMetadata.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_set_lud16(self.uniffiClonePointer(),
        FfiConverterString.lower(lud16),$0
    )
})
}
    
open func setName(name: String) -> Metadata {
    return try!  FfiConverterTypeMetadata.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_set_name(self.uniffiClonePointer(),
        FfiConverterString.lower(name),$0
    )
})
}
    
open func setNip05(nip05: String) -> Metadata {
    return try!  FfiConverterTypeMetadata.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_set_nip05(self.uniffiClonePointer(),
        FfiConverterString.lower(nip05),$0
    )
})
}
    
open func setPicture(picture: String)throws  -> Metadata {
    return try  FfiConverterTypeMetadata.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_metadata_set_picture(self.uniffiClonePointer(),
        FfiConverterString.lower(picture),$0
    )
})
}
    
open func setWebsite(website: String)throws  -> Metadata {
    return try  FfiConverterTypeMetadata.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_metadata_set_website(self.uniffiClonePointer(),
        FfiConverterString.lower(website),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Metadata, other: Metadata) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_metadata_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeMetadata.lower(other),$0
    )
}
        )
    }

}

public struct FfiConverterTypeMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Metadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Metadata {
        return Metadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Metadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Metadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Metadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> Metadata {
    return try FfiConverterTypeMetadata.lift(pointer)
}

public func FfiConverterTypeMetadata_lower(_ value: Metadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMetadata.lower(value)
}




public protocol Nip19Protocol : AnyObject {
    
    func asEnum()  -> Nip19Enum
    
}

open class Nip19:
    CustomDebugStringConvertible,
    Equatable,
    Nip19Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_nip19(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_nip19(pointer, $0) }
    }

    
public static func fromBech32(bech32: String)throws  -> Nip19 {
    return try  FfiConverterTypeNip19.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nip19_from_bech32(
        FfiConverterString.lower(bech32),$0
    )
})
}
    

    
open func asEnum() -> Nip19Enum {
    return try!  FfiConverterTypeNip19Enum.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip19_as_enum(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip19_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Nip19, other: Nip19) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip19_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNip19.lower(other),$0
    )
}
        )
    }

}

public struct FfiConverterTypeNip19: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip19

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19 {
        return Nip19(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip19) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip19 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip19, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNip19_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19 {
    return try FfiConverterTypeNip19.lift(pointer)
}

public func FfiConverterTypeNip19_lower(_ value: Nip19) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip19.lower(value)
}




public protocol Nip19EventProtocol : AnyObject {
    
    func author()  -> PublicKey?
    
    func eventId()  -> EventId
    
    func relays()  -> [String]
    
    func toBech32() throws  -> String
    
    func toNostrUri() throws  -> String
    
}

open class Nip19Event:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    Nip19EventProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_nip19event(self.pointer, $0) }
    }
public convenience init(eventId: EventId, author: PublicKey? = nil, relays: [String] = []) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_nip19event_new(
        FfiConverterTypeEventId.lower(eventId),
        FfiConverterOptionTypePublicKey.lower(author),
        FfiConverterSequenceString.lower(relays),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_nip19event(pointer, $0) }
    }

    
public static func fromBech32(bech32: String)throws  -> Nip19Event {
    return try  FfiConverterTypeNip19Event.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nip19event_from_bech32(
        FfiConverterString.lower(bech32),$0
    )
})
}
    
public static func fromNostrUri(uri: String)throws  -> Nip19Event {
    return try  FfiConverterTypeNip19Event.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nip19event_from_nostr_uri(
        FfiConverterString.lower(uri),$0
    )
})
}
    

    
open func author() -> PublicKey? {
    return try!  FfiConverterOptionTypePublicKey.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip19event_author(self.uniffiClonePointer(),$0
    )
})
}
    
open func eventId() -> EventId {
    return try!  FfiConverterTypeEventId.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip19event_event_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func relays() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip19event_relays(self.uniffiClonePointer(),$0
    )
})
}
    
open func toBech32()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_nip19event_to_bech32(self.uniffiClonePointer(),$0
    )
})
}
    
open func toNostrUri()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_nip19event_to_nostr_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip19event_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Nip19Event, other: Nip19Event) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip19event_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNip19Event.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip19event_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeNip19Event: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip19Event

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19Event {
        return Nip19Event(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip19Event) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip19Event {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip19Event, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNip19Event_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19Event {
    return try FfiConverterTypeNip19Event.lift(pointer)
}

public func FfiConverterTypeNip19Event_lower(_ value: Nip19Event) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip19Event.lower(value)
}




public protocol Nip19ProfileProtocol : AnyObject {
    
    func publicKey()  -> PublicKey
    
    func relays()  -> [String]
    
    func toBech32() throws  -> String
    
    func toNostrUri() throws  -> String
    
}

open class Nip19Profile:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    Nip19ProfileProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_nip19profile(self.pointer, $0) }
    }
    /**
     * New NIP19 profile
     */
public convenience init(publicKey: PublicKey, relays: [String] = [])throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nip19profile_new(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterSequenceString.lower(relays),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_nip19profile(pointer, $0) }
    }

    
public static func fromBech32(bech32: String)throws  -> Nip19Profile {
    return try  FfiConverterTypeNip19Profile.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nip19profile_from_bech32(
        FfiConverterString.lower(bech32),$0
    )
})
}
    
public static func fromNostrUri(uri: String)throws  -> Nip19Profile {
    return try  FfiConverterTypeNip19Profile.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nip19profile_from_nostr_uri(
        FfiConverterString.lower(uri),$0
    )
})
}
    

    
open func publicKey() -> PublicKey {
    return try!  FfiConverterTypePublicKey.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip19profile_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
open func relays() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip19profile_relays(self.uniffiClonePointer(),$0
    )
})
}
    
open func toBech32()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_nip19profile_to_bech32(self.uniffiClonePointer(),$0
    )
})
}
    
open func toNostrUri()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_nip19profile_to_nostr_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip19profile_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Nip19Profile, other: Nip19Profile) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip19profile_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNip19Profile.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip19profile_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeNip19Profile: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip19Profile

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19Profile {
        return Nip19Profile(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip19Profile) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip19Profile {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip19Profile, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNip19Profile_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19Profile {
    return try FfiConverterTypeNip19Profile.lift(pointer)
}

public func FfiConverterTypeNip19Profile_lower(_ value: Nip19Profile) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip19Profile.lower(value)
}




public protocol Nip21Protocol : AnyObject {
    
    func asEnum()  -> Nip21Enum
    
    /**
     * Serialize to NIP21 nostr URI
     */
    func toNostrUri() throws  -> String
    
}

open class Nip21:
    CustomDebugStringConvertible,
    Equatable,
    Nip21Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_nip21(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_nip21(pointer, $0) }
    }

    
    /**
     * Parse NIP21 string
     */
public static func parse(uri: String)throws  -> Nip21 {
    return try  FfiConverterTypeNip21.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nip21_parse(
        FfiConverterString.lower(uri),$0
    )
})
}
    

    
open func asEnum() -> Nip21Enum {
    return try!  FfiConverterTypeNip21Enum.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip21_as_enum(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Serialize to NIP21 nostr URI
     */
open func toNostrUri()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_nip21_to_nostr_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip21_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Nip21, other: Nip21) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nip21_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNip21.lower(other),$0
    )
}
        )
    }

}

public struct FfiConverterTypeNip21: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip21

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip21 {
        return Nip21(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip21) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip21 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip21, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNip21_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip21 {
    return try FfiConverterTypeNip21.lift(pointer)
}

public func FfiConverterTypeNip21_lower(_ value: Nip21) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip21.lower(value)
}




public protocol NostrConnectMetadataProtocol : AnyObject {
    
    /**
     * Serialize as JSON string
     */
    func asJson() throws  -> String
    
    /**
     * Description of the `App`
     */
    func description(description: String)  -> NostrConnectMetadata
    
    /**
     * List of URLs for icons of the `App`
     */
    func icons(icons: [String])  -> NostrConnectMetadata
    
    /**
     * URL of the website requesting the connection
     */
    func url(url: String) throws  -> NostrConnectMetadata
    
}

open class NostrConnectMetadata:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    NostrConnectMetadataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_nostrconnectmetadata(self.pointer, $0) }
    }
    /**
     * New Nostr Connect Metadata
     */
public convenience init(name: String) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_nostrconnectmetadata_new(
        FfiConverterString.lower(name),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_nostrconnectmetadata(pointer, $0) }
    }

    

    
    /**
     * Serialize as JSON string
     */
open func asJson()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_nostrconnectmetadata_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Description of the `App`
     */
open func description(description: String) -> NostrConnectMetadata {
    return try!  FfiConverterTypeNostrConnectMetadata.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrconnectmetadata_description(self.uniffiClonePointer(),
        FfiConverterString.lower(description),$0
    )
})
}
    
    /**
     * List of URLs for icons of the `App`
     */
open func icons(icons: [String]) -> NostrConnectMetadata {
    return try!  FfiConverterTypeNostrConnectMetadata.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrconnectmetadata_icons(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(icons),$0
    )
})
}
    
    /**
     * URL of the website requesting the connection
     */
open func url(url: String)throws  -> NostrConnectMetadata {
    return try  FfiConverterTypeNostrConnectMetadata.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_nostrconnectmetadata_url(self.uniffiClonePointer(),
        FfiConverterString.lower(url),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrconnectmetadata_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: NostrConnectMetadata, other: NostrConnectMetadata) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrconnectmetadata_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNostrConnectMetadata.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrconnectmetadata_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeNostrConnectMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrConnectMetadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectMetadata {
        return NostrConnectMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrConnectMetadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrConnectMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrConnectMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectMetadata {
    return try FfiConverterTypeNostrConnectMetadata.lift(pointer)
}

public func FfiConverterTypeNostrConnectMetadata_lower(_ value: NostrConnectMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrConnectMetadata.lower(value)
}




public protocol NostrConnectUriProtocol : AnyObject {
    
    func asString()  -> String
    
}

open class NostrConnectUri:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    NostrConnectUriProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_nostrconnecturi(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_nostrconnecturi(pointer, $0) }
    }

    
public static func parse(uri: String)throws  -> NostrConnectUri {
    return try  FfiConverterTypeNostrConnectURI.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nostrconnecturi_parse(
        FfiConverterString.lower(uri),$0
    )
})
}
    

    
open func asString() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrconnecturi_as_string(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrconnecturi_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: NostrConnectUri, other: NostrConnectUri) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrconnecturi_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNostrConnectURI.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrconnecturi_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeNostrConnectURI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrConnectUri

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectUri {
        return NostrConnectUri(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrConnectUri) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectUri {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrConnectUri, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrConnectURI_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectUri {
    return try FfiConverterTypeNostrConnectURI.lift(pointer)
}

public func FfiConverterTypeNostrConnectURI_lower(_ value: NostrConnectUri) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrConnectURI.lower(value)
}




public protocol NostrLibraryProtocol : AnyObject {
    
    func gitHashVersion()  -> String?
    
}

open class NostrLibrary:
    NostrLibraryProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_nostrlibrary(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_nostrlibrary_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_nostrlibrary(pointer, $0) }
    }

    

    
open func gitHashVersion() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrlibrary_git_hash_version(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeNostrLibrary: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrLibrary

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrLibrary {
        return NostrLibrary(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrLibrary) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrLibrary {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrLibrary, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrLibrary_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrLibrary {
    return try FfiConverterTypeNostrLibrary.lift(pointer)
}

public func FfiConverterTypeNostrLibrary_lower(_ value: NostrLibrary) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrLibrary.lower(value)
}




/**
 * Nostr Connect URI
 */
public protocol NostrWalletConnectUriProtocol : AnyObject {
    
    /**
     * A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured.
     */
    func lud16()  -> String?
    
    /**
     * App Pubkey
     */
    func publicKey()  -> PublicKey
    
    /**
     * URL of the relay of choice where the `App` is connected and the `Signer` must send and listen for messages.
     */
    func relayUrl()  -> String
    
    /**
     * 32-byte randomly generated hex encoded string
     */
    func secret()  -> SecretKey
    
}

/**
 * Nostr Connect URI
 */
open class NostrWalletConnectUri:
    CustomDebugStringConvertible,
    Equatable,
    NostrWalletConnectUriProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_nostrwalletconnecturi(self.pointer, $0) }
    }
    /**
     * Create new Nostr Wallet Connect URI
     */
public convenience init(publicKey: PublicKey, relayUrl: String, randomSecretKey: SecretKey, lud16: String?)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nostrwalletconnecturi_new(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(relayUrl),
        FfiConverterTypeSecretKey.lower(randomSecretKey),
        FfiConverterOptionString.lower(lud16),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_nostrwalletconnecturi(pointer, $0) }
    }

    
public static func parse(uri: String)throws  -> NostrWalletConnectUri {
    return try  FfiConverterTypeNostrWalletConnectURI.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nostrwalletconnecturi_parse(
        FfiConverterString.lower(uri),$0
    )
})
}
    

    
    /**
     * A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured.
     */
open func lud16() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_lud16(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * App Pubkey
     */
open func publicKey() -> PublicKey {
    return try!  FfiConverterTypePublicKey.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * URL of the relay of choice where the `App` is connected and the `Signer` must send and listen for messages.
     */
open func relayUrl() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_relay_url(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * 32-byte randomly generated hex encoded string
     */
open func secret() -> SecretKey {
    return try!  FfiConverterTypeSecretKey.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_secret(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: NostrWalletConnectUri, other: NostrWalletConnectUri) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeNostrWalletConnectURI.lower(other),$0
    )
}
        )
    }

}

public struct FfiConverterTypeNostrWalletConnectURI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrWalletConnectUri

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrWalletConnectUri {
        return NostrWalletConnectUri(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrWalletConnectUri) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrWalletConnectUri {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrWalletConnectUri, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNostrWalletConnectURI_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrWalletConnectUri {
    return try FfiConverterTypeNostrWalletConnectURI.lift(pointer)
}

public func FfiConverterTypeNostrWalletConnectURI_lower(_ value: NostrWalletConnectUri) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrWalletConnectURI.lower(value)
}




public protocol PublicKeyProtocol : AnyObject {
    
    func toBech32() throws  -> String
    
    func toHex()  -> String
    
    func toNostrUri() throws  -> String
    
}

open class PublicKey:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    PublicKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_publickey(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_publickey(pointer, $0) }
    }

    
public static func fromBech32(bech32: String)throws  -> PublicKey {
    return try  FfiConverterTypePublicKey.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_publickey_from_bech32(
        FfiConverterString.lower(bech32),$0
    )
})
}
    
public static func fromBytes(bytes: Data)throws  -> PublicKey {
    return try  FfiConverterTypePublicKey.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_publickey_from_bytes(
        FfiConverterData.lower(bytes),$0
    )
})
}
    
public static func fromHex(hex: String)throws  -> PublicKey {
    return try  FfiConverterTypePublicKey.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_publickey_from_hex(
        FfiConverterString.lower(hex),$0
    )
})
}
    
public static func fromNostrUri(uri: String)throws  -> PublicKey {
    return try  FfiConverterTypePublicKey.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_publickey_from_nostr_uri(
        FfiConverterString.lower(uri),$0
    )
})
}
    
    /**
     * Try to parse public key from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
     */
public static func parse(publicKey: String)throws  -> PublicKey {
    return try  FfiConverterTypePublicKey.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_publickey_parse(
        FfiConverterString.lower(publicKey),$0
    )
})
}
    

    
open func toBech32()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_publickey_to_bech32(self.uniffiClonePointer(),$0
    )
})
}
    
open func toHex() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_publickey_to_hex(self.uniffiClonePointer(),$0
    )
})
}
    
open func toNostrUri()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_publickey_to_nostr_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_publickey_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: PublicKey, other: PublicKey) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_publickey_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypePublicKey.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_publickey_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypePublicKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PublicKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PublicKey {
        return PublicKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PublicKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypePublicKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(pointer)
}

public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypePublicKey.lower(value)
}




public protocol RawEventProtocol : AnyObject {
    
    func asJson() throws  -> String
    
    func asRecord()  -> RawEventRecord
    
}

open class RawEvent:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    RawEventProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_rawevent(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_rawevent(pointer, $0) }
    }

    
public static func fromJson(json: String)throws  -> RawEvent {
    return try  FfiConverterTypeRawEvent.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_rawevent_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    
public static func fromRecord(r: RawEventRecord) -> RawEvent {
    return try!  FfiConverterTypeRawEvent.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_rawevent_from_record(
        FfiConverterTypeRawEventRecord.lower(r),$0
    )
})
}
    

    
open func asJson()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_rawevent_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
open func asRecord() -> RawEventRecord {
    return try!  FfiConverterTypeRawEventRecord.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_rawevent_as_record(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_rawevent_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: RawEvent, other: RawEvent) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_rawevent_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeRawEvent.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_rawevent_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeRawEvent: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RawEvent

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RawEvent {
        return RawEvent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RawEvent) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RawEvent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RawEvent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRawEvent_lift(_ pointer: UnsafeMutableRawPointer) throws -> RawEvent {
    return try FfiConverterTypeRawEvent.lift(pointer)
}

public func FfiConverterTypeRawEvent_lower(_ value: RawEvent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRawEvent.lower(value)
}




public protocol RelayInformationDocumentProtocol : AnyObject {
    
    func contact()  -> String?
    
    func description()  -> String?
    
    func fees()  -> FeeSchedules?
    
    func icon()  -> String?
    
    func languageTags()  -> [String]
    
    func limitation()  -> Limitation?
    
    func name()  -> String?
    
    func paymentsUrl()  -> String?
    
    func postingPolicy()  -> String?
    
    func pubkey()  -> String?
    
    func relayCountries()  -> [String]
    
    func retention()  -> [Retention]
    
    func software()  -> String?
    
    func supportedNips()  -> [UInt16]?
    
    func tags()  -> [String]
    
    func version()  -> String?
    
}

open class RelayInformationDocument:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    RelayInformationDocumentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_relayinformationdocument(self.pointer, $0) }
    }
    /**
     * Create new empty [`RelayInformationDocument`]
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_relayinformationdocument_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_relayinformationdocument(pointer, $0) }
    }

    
public static func get(url: String, proxy: String?)async throws  -> RelayInformationDocument {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_ffi_fn_constructor_relayinformationdocument_get(FfiConverterString.lower(url),FfiConverterOptionString.lower(proxy)
                )
            },
            pollFunc: ffi_nostr_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeRelayInformationDocument.lift,
            errorHandler: FfiConverterTypeNostrError.lift
        )
}
    

    
open func contact() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_contact(self.uniffiClonePointer(),$0
    )
})
}
    
open func description() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_description(self.uniffiClonePointer(),$0
    )
})
}
    
open func fees() -> FeeSchedules? {
    return try!  FfiConverterOptionTypeFeeSchedules.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_fees(self.uniffiClonePointer(),$0
    )
})
}
    
open func icon() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_icon(self.uniffiClonePointer(),$0
    )
})
}
    
open func languageTags() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_language_tags(self.uniffiClonePointer(),$0
    )
})
}
    
open func limitation() -> Limitation? {
    return try!  FfiConverterOptionTypeLimitation.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_limitation(self.uniffiClonePointer(),$0
    )
})
}
    
open func name() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_name(self.uniffiClonePointer(),$0
    )
})
}
    
open func paymentsUrl() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_payments_url(self.uniffiClonePointer(),$0
    )
})
}
    
open func postingPolicy() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_posting_policy(self.uniffiClonePointer(),$0
    )
})
}
    
open func pubkey() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_pubkey(self.uniffiClonePointer(),$0
    )
})
}
    
open func relayCountries() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_relay_countries(self.uniffiClonePointer(),$0
    )
})
}
    
open func retention() -> [Retention] {
    return try!  FfiConverterSequenceTypeRetention.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_retention(self.uniffiClonePointer(),$0
    )
})
}
    
open func software() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_software(self.uniffiClonePointer(),$0
    )
})
}
    
open func supportedNips() -> [UInt16]? {
    return try!  FfiConverterOptionSequenceUInt16.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_supported_nips(self.uniffiClonePointer(),$0
    )
})
}
    
open func tags() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_tags(self.uniffiClonePointer(),$0
    )
})
}
    
open func version() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_version(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: RelayInformationDocument, other: RelayInformationDocument) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeRelayInformationDocument.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_relayinformationdocument_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeRelayInformationDocument: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayInformationDocument

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayInformationDocument {
        return RelayInformationDocument(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayInformationDocument) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayInformationDocument {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayInformationDocument, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayInformationDocument_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayInformationDocument {
    return try FfiConverterTypeRelayInformationDocument.lift(pointer)
}

public func FfiConverterTypeRelayInformationDocument_lower(_ value: RelayInformationDocument) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayInformationDocument.lower(value)
}




public protocol RelayMessageProtocol : AnyObject {
    
    /**
     * Clone `RelayMessage` and convert it to `RelayMessageEnum`
     */
    func asEnum()  -> RelayMessageEnum
    
    func asJson() throws  -> String
    
}

open class RelayMessage:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    RelayMessageProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_relaymessage(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_relaymessage(pointer, $0) }
    }

    
    /**
     * Create new `AUTH` message
     */
public static func auth(challenge: String) -> RelayMessage {
    return try!  FfiConverterTypeRelayMessage.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_relaymessage_auth(
        FfiConverterString.lower(challenge),$0
    )
})
}
    
    /**
     * Create new `CLOSED` message
     */
public static func closed(subscriptionId: String, message: String) -> RelayMessage {
    return try!  FfiConverterTypeRelayMessage.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_relaymessage_closed(
        FfiConverterString.lower(subscriptionId),
        FfiConverterString.lower(message),$0
    )
})
}
    
    /**
     * Create new `EVENT` message
     */
public static func count(subscriptionId: String, count: Double) -> RelayMessage {
    return try!  FfiConverterTypeRelayMessage.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_relaymessage_count(
        FfiConverterString.lower(subscriptionId),
        FfiConverterDouble.lower(count),$0
    )
})
}
    
    /**
     * Create new `EOSE` message
     */
public static func eose(subscriptionId: String) -> RelayMessage {
    return try!  FfiConverterTypeRelayMessage.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_relaymessage_eose(
        FfiConverterString.lower(subscriptionId),$0
    )
})
}
    
    /**
     * Create new `EVENT` message
     */
public static func event(subscriptionId: String, event: Event) -> RelayMessage {
    return try!  FfiConverterTypeRelayMessage.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_relaymessage_event(
        FfiConverterString.lower(subscriptionId),
        FfiConverterTypeEvent.lower(event),$0
    )
})
}
    
    /**
     * Convert `RelayMessageEnum` to `RelayMessage`
     */
public static func fromEnum(e: RelayMessageEnum) -> RelayMessage {
    return try!  FfiConverterTypeRelayMessage.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_relaymessage_from_enum(
        FfiConverterTypeRelayMessageEnum.lower(e),$0
    )
})
}
    
    /**
     * Deserialize `RelayMessage` from JSON string
     *
     * **This method NOT verify the event signature!**
     */
public static func fromJson(json: String)throws  -> RelayMessage {
    return try  FfiConverterTypeRelayMessage.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_relaymessage_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    
    /**
     * Create new `NOTICE` message
     */
public static func notice(message: String) -> RelayMessage {
    return try!  FfiConverterTypeRelayMessage.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_relaymessage_notice(
        FfiConverterString.lower(message),$0
    )
})
}
    
    /**
     * Create new `OK` message
     */
public static func ok(eventId: EventId, status: Bool, message: String) -> RelayMessage {
    return try!  FfiConverterTypeRelayMessage.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_relaymessage_ok(
        FfiConverterTypeEventId.lower(eventId),
        FfiConverterBool.lower(status),
        FfiConverterString.lower(message),$0
    )
})
}
    

    
    /**
     * Clone `RelayMessage` and convert it to `RelayMessageEnum`
     */
open func asEnum() -> RelayMessageEnum {
    return try!  FfiConverterTypeRelayMessageEnum.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_relaymessage_as_enum(self.uniffiClonePointer(),$0
    )
})
}
    
open func asJson()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_relaymessage_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_relaymessage_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: RelayMessage, other: RelayMessage) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_relaymessage_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeRelayMessage.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_relaymessage_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeRelayMessage: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayMessage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayMessage {
        return RelayMessage(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayMessage) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayMessage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayMessage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRelayMessage_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayMessage {
    return try FfiConverterTypeRelayMessage.lift(pointer)
}

public func FfiConverterTypeRelayMessage_lower(_ value: RelayMessage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayMessage.lower(value)
}




/**
 * NIP47 Request
 */
public protocol RequestProtocol : AnyObject {
    
    func method()  -> Method
    
    func params()  -> RequestParams
    
}

/**
 * NIP47 Request
 */
open class Request:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    RequestProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_request(self.pointer, $0) }
    }
public convenience init(method: Method, params: RequestParams) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_request_new(
        FfiConverterTypeMethod.lower(method),
        FfiConverterTypeRequestParams.lower(params),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_request(pointer, $0) }
    }

    
public static func parse(json: String)throws  -> Request {
    return try  FfiConverterTypeRequest.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_request_parse(
        FfiConverterString.lower(json),$0
    )
})
}
    

    
open func method() -> Method {
    return try!  FfiConverterTypeMethod.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_request_method(self.uniffiClonePointer(),$0
    )
})
}
    
open func params() -> RequestParams {
    return try!  FfiConverterTypeRequestParams.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_request_params(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_request_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Request, other: Request) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_request_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeRequest.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_request_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Request

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Request {
        return Request(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Request) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Request {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Request, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> Request {
    return try FfiConverterTypeRequest.lift(pointer)
}

public func FfiConverterTypeRequest_lower(_ value: Request) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRequest.lower(value)
}




/**
 * NIP47 Response
 */
public protocol ResponseProtocol : AnyObject {
    
}

/**
 * NIP47 Response
 */
open class Response:
    CustomDebugStringConvertible,
    Equatable,
    ResponseProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_response(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_response(pointer, $0) }
    }

    

    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_response_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Response, other: Response) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_response_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeResponse.lower(other),$0
    )
}
        )
    }

}

public struct FfiConverterTypeResponse: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Response

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Response {
        return Response(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Response) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Response {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Response, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeResponse_lift(_ pointer: UnsafeMutableRawPointer) throws -> Response {
    return try FfiConverterTypeResponse.lift(pointer)
}

public func FfiConverterTypeResponse_lower(_ value: Response) -> UnsafeMutableRawPointer {
    return FfiConverterTypeResponse.lower(value)
}




public protocol SecretKeyProtocol : AnyObject {
    
    /**
     * Encrypt `SecretKey`
     *
     * By default, `LOG_N` is set to `16` and `KeySecurity` to `Unknown`.
     * To use custom values check `EncryptedSecretKey` constructor.
     */
    func encrypt(password: String) throws  -> EncryptedSecretKey
    
    func toBech32() throws  -> String
    
    func toHex()  -> String
    
}

open class SecretKey:
    CustomDebugStringConvertible,
    Equatable,
    SecretKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_secretkey(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_secretkey(pointer, $0) }
    }

    
public static func fromBech32(bech32: String)throws  -> SecretKey {
    return try  FfiConverterTypeSecretKey.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_secretkey_from_bech32(
        FfiConverterString.lower(bech32),$0
    )
})
}
    
public static func fromBytes(bytes: Data)throws  -> SecretKey {
    return try  FfiConverterTypeSecretKey.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_secretkey_from_bytes(
        FfiConverterData.lower(bytes),$0
    )
})
}
    
public static func fromHex(hex: String)throws  -> SecretKey {
    return try  FfiConverterTypeSecretKey.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_secretkey_from_hex(
        FfiConverterString.lower(hex),$0
    )
})
}
    
    /**
     * Generate random secret key
     */
public static func generate() -> SecretKey {
    return try!  FfiConverterTypeSecretKey.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_secretkey_generate($0
    )
})
}
    
    /**
     * Try to parse secret key from `hex` or `bech32`
     */
public static func parse(secretKey: String)throws  -> SecretKey {
    return try  FfiConverterTypeSecretKey.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_secretkey_parse(
        FfiConverterString.lower(secretKey),$0
    )
})
}
    

    
    /**
     * Encrypt `SecretKey`
     *
     * By default, `LOG_N` is set to `16` and `KeySecurity` to `Unknown`.
     * To use custom values check `EncryptedSecretKey` constructor.
     */
open func encrypt(password: String)throws  -> EncryptedSecretKey {
    return try  FfiConverterTypeEncryptedSecretKey.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_secretkey_encrypt(self.uniffiClonePointer(),
        FfiConverterString.lower(password),$0
    )
})
}
    
open func toBech32()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_secretkey_to_bech32(self.uniffiClonePointer(),$0
    )
})
}
    
open func toHex() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_secretkey_to_hex(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_secretkey_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: SecretKey, other: SecretKey) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_secretkey_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeSecretKey.lower(other),$0
    )
}
        )
    }

}

public struct FfiConverterTypeSecretKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SecretKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SecretKey {
        return SecretKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SecretKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecretKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SecretKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSecretKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> SecretKey {
    return try FfiConverterTypeSecretKey.lift(pointer)
}

public func FfiConverterTypeSecretKey_lower(_ value: SecretKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSecretKey.lower(value)
}




public protocol ShippingMethodProtocol : AnyObject {
    
    /**
     * Get the product shipping cost of the shipping method
     */
    func getShippingCost()  -> ShippingCost
    
    /**
     * Set the name of the shipping method
     */
    func name(name: String)  -> ShippingMethod
    
    /**
     * Add a region to the shipping method
     */
    func regions(regions: [String])  -> ShippingMethod
    
}

open class ShippingMethod:
    ShippingMethodProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_shippingmethod(self.pointer, $0) }
    }
    /**
     * Create a new shipping method
     */
public convenience init(id: String, cost: Double) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_shippingmethod_new(
        FfiConverterString.lower(id),
        FfiConverterDouble.lower(cost),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_shippingmethod(pointer, $0) }
    }

    

    
    /**
     * Get the product shipping cost of the shipping method
     */
open func getShippingCost() -> ShippingCost {
    return try!  FfiConverterTypeShippingCost.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_shippingmethod_get_shipping_cost(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Set the name of the shipping method
     */
open func name(name: String) -> ShippingMethod {
    return try!  FfiConverterTypeShippingMethod.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_shippingmethod_name(self.uniffiClonePointer(),
        FfiConverterString.lower(name),$0
    )
})
}
    
    /**
     * Add a region to the shipping method
     */
open func regions(regions: [String]) -> ShippingMethod {
    return try!  FfiConverterTypeShippingMethod.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_shippingmethod_regions(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(regions),$0
    )
})
}
    

}

public struct FfiConverterTypeShippingMethod: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ShippingMethod

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ShippingMethod {
        return ShippingMethod(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ShippingMethod) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShippingMethod {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ShippingMethod, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeShippingMethod_lift(_ pointer: UnsafeMutableRawPointer) throws -> ShippingMethod {
    return try FfiConverterTypeShippingMethod.lift(pointer)
}

public func FfiConverterTypeShippingMethod_lower(_ value: ShippingMethod) -> UnsafeMutableRawPointer {
    return FfiConverterTypeShippingMethod.lower(value)
}




public protocol SingleLetterTagProtocol : AnyObject {
    
    func isLowercase()  -> Bool
    
    func isUppercase()  -> Bool
    
}

open class SingleLetterTag:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    SingleLetterTagProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_singlelettertag(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_singlelettertag(pointer, $0) }
    }

    
public static func lowercase(character: Alphabet) -> SingleLetterTag {
    return try!  FfiConverterTypeSingleLetterTag.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_singlelettertag_lowercase(
        FfiConverterTypeAlphabet.lower(character),$0
    )
})
}
    
public static func uppercase(character: Alphabet) -> SingleLetterTag {
    return try!  FfiConverterTypeSingleLetterTag.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_singlelettertag_uppercase(
        FfiConverterTypeAlphabet.lower(character),$0
    )
})
}
    

    
open func isLowercase() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_singlelettertag_is_lowercase(self.uniffiClonePointer(),$0
    )
})
}
    
open func isUppercase() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_singlelettertag_is_uppercase(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_singlelettertag_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: SingleLetterTag, other: SingleLetterTag) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_singlelettertag_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeSingleLetterTag.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_singlelettertag_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeSingleLetterTag: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SingleLetterTag

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SingleLetterTag {
        return SingleLetterTag(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SingleLetterTag) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SingleLetterTag {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SingleLetterTag, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSingleLetterTag_lift(_ pointer: UnsafeMutableRawPointer) throws -> SingleLetterTag {
    return try FfiConverterTypeSingleLetterTag.lift(pointer)
}

public func FfiConverterTypeSingleLetterTag_lower(_ value: SingleLetterTag) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSingleLetterTag.lower(value)
}




public protocol StallDataProtocol : AnyObject {
    
    func asJson() throws  -> String
    
    func asRecord()  -> StallDataRecord
    
    func currency()  -> String
    
    func description()  -> String?
    
    func id()  -> String
    
    func name()  -> String
    
    func shipping()  -> [ShippingMethod]
    
}

open class StallData:
    StallDataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_stalldata(self.pointer, $0) }
    }
public convenience init(id: String, name: String, description: String?, currency: String, shipping: [ShippingMethod]) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_stalldata_new(
        FfiConverterString.lower(id),
        FfiConverterString.lower(name),
        FfiConverterOptionString.lower(description),
        FfiConverterString.lower(currency),
        FfiConverterSequenceTypeShippingMethod.lower(shipping),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_stalldata(pointer, $0) }
    }

    
public static func fromJson(json: String)throws  -> StallData {
    return try  FfiConverterTypeStallData.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_stalldata_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    
public static func fromRecord(r: StallDataRecord) -> StallData {
    return try!  FfiConverterTypeStallData.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_stalldata_from_record(
        FfiConverterTypeStallDataRecord.lower(r),$0
    )
})
}
    

    
open func asJson()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_stalldata_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
open func asRecord() -> StallDataRecord {
    return try!  FfiConverterTypeStallDataRecord.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_stalldata_as_record(self.uniffiClonePointer(),$0
    )
})
}
    
open func currency() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_stalldata_currency(self.uniffiClonePointer(),$0
    )
})
}
    
open func description() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_stalldata_description(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_stalldata_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func name() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_stalldata_name(self.uniffiClonePointer(),$0
    )
})
}
    
open func shipping() -> [ShippingMethod] {
    return try!  FfiConverterSequenceTypeShippingMethod.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_stalldata_shipping(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeStallData: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = StallData

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> StallData {
        return StallData(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: StallData) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StallData {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: StallData, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeStallData_lift(_ pointer: UnsafeMutableRawPointer) throws -> StallData {
    return try FfiConverterTypeStallData.lift(pointer)
}

public func FfiConverterTypeStallData_lower(_ value: StallData) -> UnsafeMutableRawPointer {
    return FfiConverterTypeStallData.lower(value)
}




/**
 * Tag
 */
public protocol TagProtocol : AnyObject {
    
    /**
     * Get standardized tag
     */
    func asStandardized()  -> TagStandard?
    
    /**
     * Get array of strings
     */
    func asVec()  -> [String]
    
    /**
     * Return the **first** tag value (index `1`), if exists.
     */
    func content()  -> String?
    
    /**
     * Check if is a standard event tag with `reply` marker
     */
    func isReply()  -> Bool
    
    /**
     * Check if is a standard event tag with `root` marker
     */
    func isRoot()  -> Bool
    
    /**
     * Get tag kind
     */
    func kind()  -> TagKind
    
    /**
     * Get `SingleLetterTag`
     */
    func singleLetterTag()  -> SingleLetterTag?
    
}

/**
 * Tag
 */
open class Tag:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    TagProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_tag(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_tag(pointer, $0) }
    }

    
    /**
     * Compose `["a", "<coordinate>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
public static func coordinate(coordinate: Coordinate) -> Tag {
    return try!  FfiConverterTypeTag.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_tag_coordinate(
        FfiConverterTypeCoordinate.lower(coordinate),$0
    )
})
}
    
    /**
     * Compose custom tag
     *
     * JSON: `["<kind>", "<value-1>", "<value-2>", ...]`
     */
public static func custom(kind: TagKind, values: [String]) -> Tag {
    return try!  FfiConverterTypeTag.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_tag_custom(
        FfiConverterTypeTagKind.lower(kind),
        FfiConverterSequenceString.lower(values),$0
    )
})
}
    
    /**
     * Compose `["e", "<event-id">]`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
public static func event(eventId: EventId) -> Tag {
    return try!  FfiConverterTypeTag.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_tag_event(
        FfiConverterTypeEventId.lower(eventId),$0
    )
})
}
    
    /**
     * Compose `["e", "<event-id>", "<report>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/56.md>
     */
public static func eventReport(eventId: EventId, report: Report) -> Tag {
    return try!  FfiConverterTypeTag.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_tag_event_report(
        FfiConverterTypeEventId.lower(eventId),
        FfiConverterTypeReport.lower(report),$0
    )
})
}
    
    /**
     * Compose `["expiration", "<timestamp>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/40.md>
     */
public static func expiration(timestamp: Timestamp) -> Tag {
    return try!  FfiConverterTypeTag.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_tag_expiration(
        FfiConverterTypeTimestamp.lower(timestamp),$0
    )
})
}
    
    /**
     * Construct from standardized tag
     */
public static func fromStandardized(standardized: TagStandard)throws  -> Tag {
    return try  FfiConverterTypeTag.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_tag_from_standardized(
        FfiConverterTypeTagStandard.lower(standardized),$0
    )
})
}
    
    /**
     * Compose `["t", "<hashtag>"]` tag
     */
public static func hashtag(hashtag: String) -> Tag {
    return try!  FfiConverterTypeTag.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_tag_hashtag(
        FfiConverterString.lower(hashtag),$0
    )
})
}
    
    /**
     * Compose `["d", "<identifier>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
public static func identifier(identifier: String) -> Tag {
    return try!  FfiConverterTypeTag.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_tag_identifier(
        FfiConverterString.lower(identifier),$0
    )
})
}
    
    /**
     * Parse tag
     *
     * Return error if the tag is empty!
     */
public static func parse(data: [String])throws  -> Tag {
    return try  FfiConverterTypeTag.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_tag_parse(
        FfiConverterSequenceString.lower(data),$0
    )
})
}
    
    /**
     * Compose `["nonce", "<nonce>", "<difficulty>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/13.md>
     */
public static func pow(nonce: UInt64, difficulty: UInt8) -> Tag {
    return try!  FfiConverterTypeTag.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_tag_pow(
        FfiConverterUInt64.lower(nonce),
        FfiConverterUInt8.lower(difficulty),$0
    )
})
}
    
    /**
     * Compose `["p", "<public-key>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
public static func publicKey(publicKey: PublicKey) -> Tag {
    return try!  FfiConverterTypeTag.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_tag_public_key(
        FfiConverterTypePublicKey.lower(publicKey),$0
    )
})
}
    
    /**
     * Compose `["p", "<public-key>", "<report>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/56.md>
     */
public static func publicKeyReport(publicKey: PublicKey, report: Report) -> Tag {
    return try!  FfiConverterTypeTag.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_tag_public_key_report(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterTypeReport.lower(report),$0
    )
})
}
    
    /**
     * Compose `["r", "<relay-url>", "<metadata>"]` tag
     *
     * <https://github.com/nostr-protocol/nips/blob/master/65.md>
     */
public static func relayMetadata(relayUrl: String, metadata: RelayMetadata?)throws  -> Tag {
    return try  FfiConverterTypeTag.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_tag_relay_metadata(
        FfiConverterString.lower(relayUrl),
        FfiConverterOptionTypeRelayMetadata.lower(metadata),$0
    )
})
}
    

    
    /**
     * Get standardized tag
     */
open func asStandardized() -> TagStandard? {
    return try!  FfiConverterOptionTypeTagStandard.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_tag_as_standardized(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get array of strings
     */
open func asVec() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_tag_as_vec(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the **first** tag value (index `1`), if exists.
     */
open func content() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_tag_content(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if is a standard event tag with `reply` marker
     */
open func isReply() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_tag_is_reply(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if is a standard event tag with `root` marker
     */
open func isRoot() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_tag_is_root(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get tag kind
     */
open func kind() -> TagKind {
    return try!  FfiConverterTypeTagKind.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_tag_kind(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get `SingleLetterTag`
     */
open func singleLetterTag() -> SingleLetterTag? {
    return try!  FfiConverterOptionTypeSingleLetterTag.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_tag_single_letter_tag(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_tag_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Tag, other: Tag) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_tag_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeTag.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_tag_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeTag: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Tag

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Tag {
        return Tag(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Tag) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tag {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Tag, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeTag_lift(_ pointer: UnsafeMutableRawPointer) throws -> Tag {
    return try FfiConverterTypeTag.lift(pointer)
}

public func FfiConverterTypeTag_lower(_ value: Tag) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTag.lower(value)
}




public protocol TimestampProtocol : AnyObject {
    
    /**
     * Get timestamp as [`u64`]
     */
    func asSecs()  -> UInt64
    
    /**
     * Convert [`Timestamp`] to human datetime
     */
    func toHumanDatetime()  -> String
    
}

open class Timestamp:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    TimestampProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_timestamp(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_timestamp(pointer, $0) }
    }

    
public static func fromSecs(secs: UInt64) -> Timestamp {
    return try!  FfiConverterTypeTimestamp.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_timestamp_from_secs(
        FfiConverterUInt64.lower(secs),$0
    )
})
}
    
    /**
     * Get UNIX timestamp
     */
public static func now() -> Timestamp {
    return try!  FfiConverterTypeTimestamp.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_timestamp_now($0
    )
})
}
    

    
    /**
     * Get timestamp as [`u64`]
     */
open func asSecs() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_timestamp_as_secs(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Convert [`Timestamp`] to human datetime
     */
open func toHumanDatetime() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_timestamp_to_human_datetime(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_timestamp_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: Timestamp, other: Timestamp) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_timestamp_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeTimestamp.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_timestamp_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeTimestamp: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Timestamp

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Timestamp {
        return Timestamp(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Timestamp) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Timestamp {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Timestamp, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeTimestamp_lift(_ pointer: UnsafeMutableRawPointer) throws -> Timestamp {
    return try FfiConverterTypeTimestamp.lift(pointer)
}

public func FfiConverterTypeTimestamp_lower(_ value: Timestamp) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimestamp.lower(value)
}




public protocol UnsignedEventProtocol : AnyObject {
    
    /**
     * Add signature to unsigned event
     *
     * Internally verify the event.
     */
    func addSignature(sig: String) throws  -> Event
    
    func asJson() throws  -> String
    
    func author()  -> PublicKey
    
    func content()  -> String
    
    func createdAt()  -> Timestamp
    
    func id()  -> EventId?
    
    func kind()  -> Kind
    
    /**
     * Sign an unsigned event
     *
     * Internally: calculate event ID (if not set), sign it, compose and verify event.
     */
    func sign(keys: Keys) throws  -> Event
    
    func tags()  -> [Tag]
    
}

open class UnsignedEvent:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    UnsignedEventProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_unsignedevent(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_unsignedevent(pointer, $0) }
    }

    
public static func fromJson(json: String)throws  -> UnsignedEvent {
    return try  FfiConverterTypeUnsignedEvent.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_unsignedevent_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    

    
    /**
     * Add signature to unsigned event
     *
     * Internally verify the event.
     */
open func addSignature(sig: String)throws  -> Event {
    return try  FfiConverterTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_unsignedevent_add_signature(self.uniffiClonePointer(),
        FfiConverterString.lower(sig),$0
    )
})
}
    
open func asJson()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_unsignedevent_as_json(self.uniffiClonePointer(),$0
    )
})
}
    
open func author() -> PublicKey {
    return try!  FfiConverterTypePublicKey.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_unsignedevent_author(self.uniffiClonePointer(),$0
    )
})
}
    
open func content() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_unsignedevent_content(self.uniffiClonePointer(),$0
    )
})
}
    
open func createdAt() -> Timestamp {
    return try!  FfiConverterTypeTimestamp.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_unsignedevent_created_at(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> EventId? {
    return try!  FfiConverterOptionTypeEventId.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_unsignedevent_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func kind() -> Kind {
    return try!  FfiConverterTypeKind.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_unsignedevent_kind(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Sign an unsigned event
     *
     * Internally: calculate event ID (if not set), sign it, compose and verify event.
     */
open func sign(keys: Keys)throws  -> Event {
    return try  FfiConverterTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_unsignedevent_sign(self.uniffiClonePointer(),
        FfiConverterTypeKeys.lower(keys),$0
    )
})
}
    
open func tags() -> [Tag] {
    return try!  FfiConverterSequenceTypeTag.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_unsignedevent_tags(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_unsignedevent_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: UnsignedEvent, other: UnsignedEvent) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_unsignedevent_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeUnsignedEvent.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_unsignedevent_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeUnsignedEvent: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnsignedEvent

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsignedEvent {
        return UnsignedEvent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnsignedEvent) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsignedEvent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnsignedEvent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeUnsignedEvent_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsignedEvent {
    return try FfiConverterTypeUnsignedEvent.lift(pointer)
}

public func FfiConverterTypeUnsignedEvent_lower(_ value: UnsignedEvent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnsignedEvent.lower(value)
}




/**
 * Unwrapped Gift Wrap
 *
 * <https://github.com/nostr-protocol/nips/blob/master/59.md>
 */
public protocol UnwrappedGiftProtocol : AnyObject {
    
    /**
     * Get rumor
     */
    func rumor()  -> UnsignedEvent
    
    /**
     * Get sender public key
     */
    func sender()  -> PublicKey
    
}

/**
 * Unwrapped Gift Wrap
 *
 * <https://github.com/nostr-protocol/nips/blob/master/59.md>
 */
open class UnwrappedGift:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    UnwrappedGiftProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_unwrappedgift(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_unwrappedgift(pointer, $0) }
    }

    
    /**
     * Unwrap Gift Wrap event
     *
     * Internally verify the `seal` event
     */
public static func fromGiftWrap(receiverKeys: Keys, giftWrap: Event)throws  -> UnwrappedGift {
    return try  FfiConverterTypeUnwrappedGift.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_unwrappedgift_from_gift_wrap(
        FfiConverterTypeKeys.lower(receiverKeys),
        FfiConverterTypeEvent.lower(giftWrap),$0
    )
})
}
    

    
    /**
     * Get rumor
     */
open func rumor() -> UnsignedEvent {
    return try!  FfiConverterTypeUnsignedEvent.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_unwrappedgift_rumor(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get sender public key
     */
open func sender() -> PublicKey {
    return try!  FfiConverterTypePublicKey.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_unwrappedgift_sender(self.uniffiClonePointer(),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_unwrappedgift_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: UnwrappedGift, other: UnwrappedGift) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_unwrappedgift_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeUnwrappedGift.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_unwrappedgift_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeUnwrappedGift: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnwrappedGift

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnwrappedGift {
        return UnwrappedGift(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnwrappedGift) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnwrappedGift {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnwrappedGift, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeUnwrappedGift_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnwrappedGift {
    return try FfiConverterTypeUnwrappedGift.lift(pointer)
}

public func FfiConverterTypeUnwrappedGift_lower(_ value: UnwrappedGift) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnwrappedGift.lower(value)
}




public protocol ZapRequestDataProtocol : AnyObject {
    
    func amount(amount: UInt64)  -> ZapRequestData
    
    func eventId(eventId: EventId)  -> ZapRequestData
    
    func lnurl(lnurl: String)  -> ZapRequestData
    
    func message(message: String)  -> ZapRequestData
    
}

open class ZapRequestData:
    CustomDebugStringConvertible,
    Equatable,
    Hashable,
    ZapRequestDataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_zaprequestdata(self.pointer, $0) }
    }
public convenience init(publicKey: PublicKey, relays: [String]) {
    let pointer =
        try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_zaprequestdata_new(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterSequenceString.lower(relays),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_nostr_ffi_fn_free_zaprequestdata(pointer, $0) }
    }

    

    
open func amount(amount: UInt64) -> ZapRequestData {
    return try!  FfiConverterTypeZapRequestData.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_zaprequestdata_amount(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amount),$0
    )
})
}
    
open func eventId(eventId: EventId) -> ZapRequestData {
    return try!  FfiConverterTypeZapRequestData.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_zaprequestdata_event_id(self.uniffiClonePointer(),
        FfiConverterTypeEventId.lower(eventId),$0
    )
})
}
    
open func lnurl(lnurl: String) -> ZapRequestData {
    return try!  FfiConverterTypeZapRequestData.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_zaprequestdata_lnurl(self.uniffiClonePointer(),
        FfiConverterString.lower(lnurl),$0
    )
})
}
    
open func message(message: String) -> ZapRequestData {
    return try!  FfiConverterTypeZapRequestData.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_method_zaprequestdata_message(self.uniffiClonePointer(),
        FfiConverterString.lower(message),$0
    )
})
}
    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_zaprequestdata_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: ZapRequestData, other: ZapRequestData) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_zaprequestdata_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeZapRequestData.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_nostr_ffi_fn_method_zaprequestdata_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

public struct FfiConverterTypeZapRequestData: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZapRequestData

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapRequestData {
        return ZapRequestData(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZapRequestData) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZapRequestData {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZapRequestData, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeZapRequestData_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapRequestData {
    return try FfiConverterTypeZapRequestData.lift(pointer)
}

public func FfiConverterTypeZapRequestData_lower(_ value: ZapRequestData) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZapRequestData.lower(value)
}


/**
 * Groups of articles picked by users as interesting and/or belonging to the same category
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
public struct ArticlesCuration {
    /**
     * Coordinates
     */
    public var coordinate: [Coordinate]
    /**
     * Event IDs
     */
    public var eventIds: [EventId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Coordinates
         */coordinate: [Coordinate], 
        /**
         * Event IDs
         */eventIds: [EventId]) {
        self.coordinate = coordinate
        self.eventIds = eventIds
    }
}



public struct FfiConverterTypeArticlesCuration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArticlesCuration {
        return
            try ArticlesCuration(
                coordinate: FfiConverterSequenceTypeCoordinate.read(from: &buf), 
                eventIds: FfiConverterSequenceTypeEventId.read(from: &buf)
        )
    }

    public static func write(_ value: ArticlesCuration, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeCoordinate.write(value.coordinate, into: &buf)
        FfiConverterSequenceTypeEventId.write(value.eventIds, into: &buf)
    }
}


public func FfiConverterTypeArticlesCuration_lift(_ buf: RustBuffer) throws -> ArticlesCuration {
    return try FfiConverterTypeArticlesCuration.lift(buf)
}

public func FfiConverterTypeArticlesCuration_lower(_ value: ArticlesCuration) -> RustBuffer {
    return FfiConverterTypeArticlesCuration.lower(value)
}


/**
 * Uncategorized, "global" list of things a user wants to save
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
public struct Bookmarks {
    public var eventIds: [EventId]
    public var coordinate: [Coordinate]
    public var hashtags: [String]
    public var urls: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(eventIds: [EventId], coordinate: [Coordinate], hashtags: [String], urls: [String]) {
        self.eventIds = eventIds
        self.coordinate = coordinate
        self.hashtags = hashtags
        self.urls = urls
    }
}



public struct FfiConverterTypeBookmarks: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bookmarks {
        return
            try Bookmarks(
                eventIds: FfiConverterSequenceTypeEventId.read(from: &buf), 
                coordinate: FfiConverterSequenceTypeCoordinate.read(from: &buf), 
                hashtags: FfiConverterSequenceString.read(from: &buf), 
                urls: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: Bookmarks, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeEventId.write(value.eventIds, into: &buf)
        FfiConverterSequenceTypeCoordinate.write(value.coordinate, into: &buf)
        FfiConverterSequenceString.write(value.hashtags, into: &buf)
        FfiConverterSequenceString.write(value.urls, into: &buf)
    }
}


public func FfiConverterTypeBookmarks_lift(_ buf: RustBuffer) throws -> Bookmarks {
    return try FfiConverterTypeBookmarks.lift(buf)
}

public func FfiConverterTypeBookmarks_lower(_ value: Bookmarks) -> RustBuffer {
    return FfiConverterTypeBookmarks.lower(value)
}


/**
 * Emoji
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
public struct EmojiInfo {
    public var shortcode: String
    public var url: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(shortcode: String, url: String) {
        self.shortcode = shortcode
        self.url = url
    }
}



extension EmojiInfo: Equatable, Hashable {
    public static func ==(lhs: EmojiInfo, rhs: EmojiInfo) -> Bool {
        if lhs.shortcode != rhs.shortcode {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(shortcode)
        hasher.combine(url)
    }
}


public struct FfiConverterTypeEmojiInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmojiInfo {
        return
            try EmojiInfo(
                shortcode: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: EmojiInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.shortcode, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
    }
}


public func FfiConverterTypeEmojiInfo_lift(_ buf: RustBuffer) throws -> EmojiInfo {
    return try FfiConverterTypeEmojiInfo.lift(buf)
}

public func FfiConverterTypeEmojiInfo_lower(_ value: EmojiInfo) -> RustBuffer {
    return FfiConverterTypeEmojiInfo.lower(value)
}


/**
 * User preferred emojis and pointers to emoji sets
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
public struct Emojis {
    /**
     * Emojis
     */
    public var emojis: [EmojiInfo]
    /**
     * Coordinates
     */
    public var coordinate: [Coordinate]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Emojis
         */emojis: [EmojiInfo], 
        /**
         * Coordinates
         */coordinate: [Coordinate]) {
        self.emojis = emojis
        self.coordinate = coordinate
    }
}



public struct FfiConverterTypeEmojis: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Emojis {
        return
            try Emojis(
                emojis: FfiConverterSequenceTypeEmojiInfo.read(from: &buf), 
                coordinate: FfiConverterSequenceTypeCoordinate.read(from: &buf)
        )
    }

    public static func write(_ value: Emojis, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeEmojiInfo.write(value.emojis, into: &buf)
        FfiConverterSequenceTypeCoordinate.write(value.coordinate, into: &buf)
    }
}


public func FfiConverterTypeEmojis_lift(_ buf: RustBuffer) throws -> Emojis {
    return try FfiConverterTypeEmojis.lift(buf)
}

public func FfiConverterTypeEmojis_lower(_ value: Emojis) -> RustBuffer {
    return FfiConverterTypeEmojis.lower(value)
}


/**
 * The specific information about a fee schedule
 */
public struct FeeSchedule {
    /**
     * The fee amount
     */
    public var amount: Int32
    /**
     * The denomination of the feed
     */
    public var unit: String
    /**
     * The duration for which the fee is valid
     */
    public var period: Int32?
    /**
     * The event kinds the fee allows the client to publish to the relay
     */
    public var kinds: [String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The fee amount
         */amount: Int32, 
        /**
         * The denomination of the feed
         */unit: String, 
        /**
         * The duration for which the fee is valid
         */period: Int32?, 
        /**
         * The event kinds the fee allows the client to publish to the relay
         */kinds: [String]?) {
        self.amount = amount
        self.unit = unit
        self.period = period
        self.kinds = kinds
    }
}



extension FeeSchedule: Equatable, Hashable {
    public static func ==(lhs: FeeSchedule, rhs: FeeSchedule) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.unit != rhs.unit {
            return false
        }
        if lhs.period != rhs.period {
            return false
        }
        if lhs.kinds != rhs.kinds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(unit)
        hasher.combine(period)
        hasher.combine(kinds)
    }
}


public struct FfiConverterTypeFeeSchedule: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSchedule {
        return
            try FeeSchedule(
                amount: FfiConverterInt32.read(from: &buf), 
                unit: FfiConverterString.read(from: &buf), 
                period: FfiConverterOptionInt32.read(from: &buf), 
                kinds: FfiConverterOptionSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: FeeSchedule, into buf: inout [UInt8]) {
        FfiConverterInt32.write(value.amount, into: &buf)
        FfiConverterString.write(value.unit, into: &buf)
        FfiConverterOptionInt32.write(value.period, into: &buf)
        FfiConverterOptionSequenceString.write(value.kinds, into: &buf)
    }
}


public func FfiConverterTypeFeeSchedule_lift(_ buf: RustBuffer) throws -> FeeSchedule {
    return try FfiConverterTypeFeeSchedule.lift(buf)
}

public func FfiConverterTypeFeeSchedule_lower(_ value: FeeSchedule) -> RustBuffer {
    return FfiConverterTypeFeeSchedule.lower(value)
}


/**
 * Available fee schedules
 */
public struct FeeSchedules {
    /**
     * Fees for admission to use the relay
     */
    public var admission: [FeeSchedule]
    /**
     * Fees for subscription to use the relay
     */
    public var subscription: [FeeSchedule]
    /**
     * Fees to publish to the relay
     */
    public var publication: [FeeSchedule]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Fees for admission to use the relay
         */admission: [FeeSchedule], 
        /**
         * Fees for subscription to use the relay
         */subscription: [FeeSchedule], 
        /**
         * Fees to publish to the relay
         */publication: [FeeSchedule]) {
        self.admission = admission
        self.subscription = subscription
        self.publication = publication
    }
}



extension FeeSchedules: Equatable, Hashable {
    public static func ==(lhs: FeeSchedules, rhs: FeeSchedules) -> Bool {
        if lhs.admission != rhs.admission {
            return false
        }
        if lhs.subscription != rhs.subscription {
            return false
        }
        if lhs.publication != rhs.publication {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(admission)
        hasher.combine(subscription)
        hasher.combine(publication)
    }
}


public struct FfiConverterTypeFeeSchedules: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSchedules {
        return
            try FeeSchedules(
                admission: FfiConverterSequenceTypeFeeSchedule.read(from: &buf), 
                subscription: FfiConverterSequenceTypeFeeSchedule.read(from: &buf), 
                publication: FfiConverterSequenceTypeFeeSchedule.read(from: &buf)
        )
    }

    public static func write(_ value: FeeSchedules, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFeeSchedule.write(value.admission, into: &buf)
        FfiConverterSequenceTypeFeeSchedule.write(value.subscription, into: &buf)
        FfiConverterSequenceTypeFeeSchedule.write(value.publication, into: &buf)
    }
}


public func FfiConverterTypeFeeSchedules_lift(_ buf: RustBuffer) throws -> FeeSchedules {
    return try FfiConverterTypeFeeSchedules.lift(buf)
}

public func FfiConverterTypeFeeSchedules_lower(_ value: FeeSchedules) -> RustBuffer {
    return FfiConverterTypeFeeSchedules.lower(value)
}


public struct FilterRecord {
    public var ids: [EventId]?
    public var authors: [PublicKey]?
    public var kinds: [Kind]?
    /**
     * It's a string describing a query in a human-readable form, i.e. "best nostr apps"
     *
     * <https://github.com/nostr-protocol/nips/blob/master/50.md>
     */
    public var search: String?
    /**
     * An integer unix timestamp, events must be newer than this to pass
     */
    public var since: Timestamp?
    /**
     * An integer unix timestamp, events must be older than this to pass
     */
    public var until: Timestamp?
    /**
     * Maximum number of events to be returned in the initial query
     */
    public var limit: UInt64?
    /**
     * Generic tag queries
     */
    public var genericTags: [GenericTag]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ids: [EventId]?, authors: [PublicKey]?, kinds: [Kind]?, 
        /**
         * It's a string describing a query in a human-readable form, i.e. "best nostr apps"
         *
         * <https://github.com/nostr-protocol/nips/blob/master/50.md>
         */search: String?, 
        /**
         * An integer unix timestamp, events must be newer than this to pass
         */since: Timestamp?, 
        /**
         * An integer unix timestamp, events must be older than this to pass
         */until: Timestamp?, 
        /**
         * Maximum number of events to be returned in the initial query
         */limit: UInt64?, 
        /**
         * Generic tag queries
         */genericTags: [GenericTag]) {
        self.ids = ids
        self.authors = authors
        self.kinds = kinds
        self.search = search
        self.since = since
        self.until = until
        self.limit = limit
        self.genericTags = genericTags
    }
}



public struct FfiConverterTypeFilterRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FilterRecord {
        return
            try FilterRecord(
                ids: FfiConverterOptionSequenceTypeEventId.read(from: &buf), 
                authors: FfiConverterOptionSequenceTypePublicKey.read(from: &buf), 
                kinds: FfiConverterOptionSequenceTypeKind.read(from: &buf), 
                search: FfiConverterOptionString.read(from: &buf), 
                since: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                until: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                limit: FfiConverterOptionUInt64.read(from: &buf), 
                genericTags: FfiConverterSequenceTypeGenericTag.read(from: &buf)
        )
    }

    public static func write(_ value: FilterRecord, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypeEventId.write(value.ids, into: &buf)
        FfiConverterOptionSequenceTypePublicKey.write(value.authors, into: &buf)
        FfiConverterOptionSequenceTypeKind.write(value.kinds, into: &buf)
        FfiConverterOptionString.write(value.search, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.since, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.until, into: &buf)
        FfiConverterOptionUInt64.write(value.limit, into: &buf)
        FfiConverterSequenceTypeGenericTag.write(value.genericTags, into: &buf)
    }
}


public func FfiConverterTypeFilterRecord_lift(_ buf: RustBuffer) throws -> FilterRecord {
    return try FfiConverterTypeFilterRecord.lift(buf)
}

public func FfiConverterTypeFilterRecord_lower(_ value: FilterRecord) -> RustBuffer {
    return FfiConverterTypeFilterRecord.lower(value)
}


public struct GenericTag {
    public var key: SingleLetterTag
    public var value: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: SingleLetterTag, value: [String]) {
        self.key = key
        self.value = value
    }
}



public struct FfiConverterTypeGenericTag: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GenericTag {
        return
            try GenericTag(
                key: FfiConverterTypeSingleLetterTag.read(from: &buf), 
                value: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: GenericTag, into buf: inout [UInt8]) {
        FfiConverterTypeSingleLetterTag.write(value.key, into: &buf)
        FfiConverterSequenceString.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeGenericTag_lift(_ buf: RustBuffer) throws -> GenericTag {
    return try FfiConverterTypeGenericTag.lift(buf)
}

public func FfiConverterTypeGenericTag_lower(_ value: GenericTag) -> RustBuffer {
    return FfiConverterTypeGenericTag.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct GetBalanceResponseResult {
    /**
     * Balance amount in msats
     */
    public var balance: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Balance amount in msats
         */balance: UInt64) {
        self.balance = balance
    }
}



extension GetBalanceResponseResult: Equatable, Hashable {
    public static func ==(lhs: GetBalanceResponseResult, rhs: GetBalanceResponseResult) -> Bool {
        if lhs.balance != rhs.balance {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(balance)
    }
}


public struct FfiConverterTypeGetBalanceResponseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetBalanceResponseResult {
        return
            try GetBalanceResponseResult(
                balance: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: GetBalanceResponseResult, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.balance, into: &buf)
    }
}


public func FfiConverterTypeGetBalanceResponseResult_lift(_ buf: RustBuffer) throws -> GetBalanceResponseResult {
    return try FfiConverterTypeGetBalanceResponseResult.lift(buf)
}

public func FfiConverterTypeGetBalanceResponseResult_lower(_ value: GetBalanceResponseResult) -> RustBuffer {
    return FfiConverterTypeGetBalanceResponseResult.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct GetInfoResponseResult {
    /**
     * The alias of the lightning node
     */
    public var alias: String
    /**
     * The color of the current node in hex code format
     */
    public var color: String
    /**
     * Lightning Node's public key
     */
    public var pubkey: String
    /**
     * Active network
     */
    public var network: String
    /**
     * Current block height
     */
    public var blockHeight: UInt32
    /**
     * Most Recent Block Hash
     */
    public var blockHash: String
    /**
     * Available methods for this connection
     */
    public var methods: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The alias of the lightning node
         */alias: String, 
        /**
         * The color of the current node in hex code format
         */color: String, 
        /**
         * Lightning Node's public key
         */pubkey: String, 
        /**
         * Active network
         */network: String, 
        /**
         * Current block height
         */blockHeight: UInt32, 
        /**
         * Most Recent Block Hash
         */blockHash: String, 
        /**
         * Available methods for this connection
         */methods: [String]) {
        self.alias = alias
        self.color = color
        self.pubkey = pubkey
        self.network = network
        self.blockHeight = blockHeight
        self.blockHash = blockHash
        self.methods = methods
    }
}



extension GetInfoResponseResult: Equatable, Hashable {
    public static func ==(lhs: GetInfoResponseResult, rhs: GetInfoResponseResult) -> Bool {
        if lhs.alias != rhs.alias {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.blockHeight != rhs.blockHeight {
            return false
        }
        if lhs.blockHash != rhs.blockHash {
            return false
        }
        if lhs.methods != rhs.methods {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(alias)
        hasher.combine(color)
        hasher.combine(pubkey)
        hasher.combine(network)
        hasher.combine(blockHeight)
        hasher.combine(blockHash)
        hasher.combine(methods)
    }
}


public struct FfiConverterTypeGetInfoResponseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetInfoResponseResult {
        return
            try GetInfoResponseResult(
                alias: FfiConverterString.read(from: &buf), 
                color: FfiConverterString.read(from: &buf), 
                pubkey: FfiConverterString.read(from: &buf), 
                network: FfiConverterString.read(from: &buf), 
                blockHeight: FfiConverterUInt32.read(from: &buf), 
                blockHash: FfiConverterString.read(from: &buf), 
                methods: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: GetInfoResponseResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.alias, into: &buf)
        FfiConverterString.write(value.color, into: &buf)
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterString.write(value.network, into: &buf)
        FfiConverterUInt32.write(value.blockHeight, into: &buf)
        FfiConverterString.write(value.blockHash, into: &buf)
        FfiConverterSequenceString.write(value.methods, into: &buf)
    }
}


public func FfiConverterTypeGetInfoResponseResult_lift(_ buf: RustBuffer) throws -> GetInfoResponseResult {
    return try FfiConverterTypeGetInfoResponseResult.lift(buf)
}

public func FfiConverterTypeGetInfoResponseResult_lower(_ value: GetInfoResponseResult) -> RustBuffer {
    return FfiConverterTypeGetInfoResponseResult.lower(value)
}


public struct HttpData {
    public var url: String
    public var method: HttpMethod
    public var payload: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, method: HttpMethod, payload: String?) {
        self.url = url
        self.method = method
        self.payload = payload
    }
}



extension HttpData: Equatable, Hashable {
    public static func ==(lhs: HttpData, rhs: HttpData) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.payload != rhs.payload {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(method)
        hasher.combine(payload)
    }
}


public struct FfiConverterTypeHttpData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpData {
        return
            try HttpData(
                url: FfiConverterString.read(from: &buf), 
                method: FfiConverterTypeHttpMethod.read(from: &buf), 
                payload: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: HttpData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterTypeHttpMethod.write(value.method, into: &buf)
        FfiConverterOptionString.write(value.payload, into: &buf)
    }
}


public func FfiConverterTypeHttpData_lift(_ buf: RustBuffer) throws -> HttpData {
    return try FfiConverterTypeHttpData.lift(buf)
}

public func FfiConverterTypeHttpData_lower(_ value: HttpData) -> RustBuffer {
    return FfiConverterTypeHttpData.lower(value)
}


/**
 * External identity
 *
 * <https://github.com/nostr-protocol/nips/blob/master/39.md>
 */
public struct Identity {
    /**
     * The external identity provider
     */
    public var platform: ExternalIdentity
    /**
     * The user's identity (username) on the provider
     */
    public var ident: String
    /**
     * The user's proof on the provider
     */
    public var proof: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The external identity provider
         */platform: ExternalIdentity, 
        /**
         * The user's identity (username) on the provider
         */ident: String, 
        /**
         * The user's proof on the provider
         */proof: String) {
        self.platform = platform
        self.ident = ident
        self.proof = proof
    }
}



extension Identity: Equatable, Hashable {
    public static func ==(lhs: Identity, rhs: Identity) -> Bool {
        if lhs.platform != rhs.platform {
            return false
        }
        if lhs.ident != rhs.ident {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(platform)
        hasher.combine(ident)
        hasher.combine(proof)
    }
}


public struct FfiConverterTypeIdentity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Identity {
        return
            try Identity(
                platform: FfiConverterTypeExternalIdentity.read(from: &buf), 
                ident: FfiConverterString.read(from: &buf), 
                proof: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Identity, into buf: inout [UInt8]) {
        FfiConverterTypeExternalIdentity.write(value.platform, into: &buf)
        FfiConverterString.write(value.ident, into: &buf)
        FfiConverterString.write(value.proof, into: &buf)
    }
}


public func FfiConverterTypeIdentity_lift(_ buf: RustBuffer) throws -> Identity {
    return try FfiConverterTypeIdentity.lift(buf)
}

public func FfiConverterTypeIdentity_lower(_ value: Identity) -> RustBuffer {
    return FfiConverterTypeIdentity.lower(value)
}


public struct Image {
    public var url: String
    public var dimensions: ImageDimensions?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, dimensions: ImageDimensions?) {
        self.url = url
        self.dimensions = dimensions
    }
}



public struct FfiConverterTypeImage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Image {
        return
            try Image(
                url: FfiConverterString.read(from: &buf), 
                dimensions: FfiConverterOptionTypeImageDimensions.read(from: &buf)
        )
    }

    public static func write(_ value: Image, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterOptionTypeImageDimensions.write(value.dimensions, into: &buf)
    }
}


public func FfiConverterTypeImage_lift(_ buf: RustBuffer) throws -> Image {
    return try FfiConverterTypeImage.lift(buf)
}

public func FfiConverterTypeImage_lower(_ value: Image) -> RustBuffer {
    return FfiConverterTypeImage.lower(value)
}


/**
 * Topics a user may be interested in and pointers
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
public struct Interests {
    public var hashtags: [String]
    public var coordinate: [Coordinate]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hashtags: [String], coordinate: [Coordinate]) {
        self.hashtags = hashtags
        self.coordinate = coordinate
    }
}



public struct FfiConverterTypeInterests: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Interests {
        return
            try Interests(
                hashtags: FfiConverterSequenceString.read(from: &buf), 
                coordinate: FfiConverterSequenceTypeCoordinate.read(from: &buf)
        )
    }

    public static func write(_ value: Interests, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.hashtags, into: &buf)
        FfiConverterSequenceTypeCoordinate.write(value.coordinate, into: &buf)
    }
}


public func FfiConverterTypeInterests_lift(_ buf: RustBuffer) throws -> Interests {
    return try FfiConverterTypeInterests.lift(buf)
}

public func FfiConverterTypeInterests_lower(_ value: Interests) -> RustBuffer {
    return FfiConverterTypeInterests.lower(value)
}


/**
 * TLVs to be added to the keysend payment
 */
public struct KeysendTlvRecord {
    /**
     * TLV type
     */
    public var tlvType: UInt64
    /**
     * TLV value
     */
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * TLV type
         */tlvType: UInt64, 
        /**
         * TLV value
         */value: String) {
        self.tlvType = tlvType
        self.value = value
    }
}



extension KeysendTlvRecord: Equatable, Hashable {
    public static func ==(lhs: KeysendTlvRecord, rhs: KeysendTlvRecord) -> Bool {
        if lhs.tlvType != rhs.tlvType {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tlvType)
        hasher.combine(value)
    }
}


public struct FfiConverterTypeKeysendTLVRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeysendTlvRecord {
        return
            try KeysendTlvRecord(
                tlvType: FfiConverterUInt64.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: KeysendTlvRecord, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.tlvType, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeKeysendTLVRecord_lift(_ buf: RustBuffer) throws -> KeysendTlvRecord {
    return try FfiConverterTypeKeysendTLVRecord.lift(buf)
}

public func FfiConverterTypeKeysendTLVRecord_lower(_ value: KeysendTlvRecord) -> RustBuffer {
    return FfiConverterTypeKeysendTLVRecord.lower(value)
}


/**
 * These are limitations imposed by the relay on clients. Your client should
 * expect that requests which exceed these practical limitations are rejected or fail immediately.
 */
public struct Limitation {
    /**
     * Maximum number of bytes for incoming JSON that the relay will attempt to decode and act upon
     */
    public var maxMessageLength: Int32?
    /**
     * Total number of subscriptions that may be active on a single websocket connection
     */
    public var maxSubscriptions: Int32?
    /**
     * Maximum number of filter values in each subscription
     */
    public var maxFilters: Int32?
    /**
     * Relay will clamp each filter's limit value to this number
     */
    public var maxLimit: Int32?
    /**
     * Maximum length of subscription id as a string
     */
    public var maxSubidLength: Int32?
    /**
     * Maximum number of elements in the tags list
     */
    public var maxEventTags: Int32?
    /**
     * Maximum number of characters in the content field of any event
     */
    public var maxContentLength: Int32?
    /**
     * New events will require at least this difficulty of PoW,
     */
    public var minPowDifficulty: Int32?
    /**
     * Relay requires NIP-42 authentication to happen before a new connection may perform any other action
     */
    public var authRequired: Bool?
    /**
     * Relay requires payment before a new connection may perform any action
     */
    public var paymentRequired: Bool?
    /**
     * 'created_at' lower limit
     */
    public var createdAtLowerLimit: Timestamp?
    /**
     * 'created_at' upper limit
     */
    public var createdAtUpperLimit: Timestamp?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Maximum number of bytes for incoming JSON that the relay will attempt to decode and act upon
         */maxMessageLength: Int32?, 
        /**
         * Total number of subscriptions that may be active on a single websocket connection
         */maxSubscriptions: Int32?, 
        /**
         * Maximum number of filter values in each subscription
         */maxFilters: Int32?, 
        /**
         * Relay will clamp each filter's limit value to this number
         */maxLimit: Int32?, 
        /**
         * Maximum length of subscription id as a string
         */maxSubidLength: Int32?, 
        /**
         * Maximum number of elements in the tags list
         */maxEventTags: Int32?, 
        /**
         * Maximum number of characters in the content field of any event
         */maxContentLength: Int32?, 
        /**
         * New events will require at least this difficulty of PoW,
         */minPowDifficulty: Int32?, 
        /**
         * Relay requires NIP-42 authentication to happen before a new connection may perform any other action
         */authRequired: Bool?, 
        /**
         * Relay requires payment before a new connection may perform any action
         */paymentRequired: Bool?, 
        /**
         * 'created_at' lower limit
         */createdAtLowerLimit: Timestamp?, 
        /**
         * 'created_at' upper limit
         */createdAtUpperLimit: Timestamp?) {
        self.maxMessageLength = maxMessageLength
        self.maxSubscriptions = maxSubscriptions
        self.maxFilters = maxFilters
        self.maxLimit = maxLimit
        self.maxSubidLength = maxSubidLength
        self.maxEventTags = maxEventTags
        self.maxContentLength = maxContentLength
        self.minPowDifficulty = minPowDifficulty
        self.authRequired = authRequired
        self.paymentRequired = paymentRequired
        self.createdAtLowerLimit = createdAtLowerLimit
        self.createdAtUpperLimit = createdAtUpperLimit
    }
}



public struct FfiConverterTypeLimitation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Limitation {
        return
            try Limitation(
                maxMessageLength: FfiConverterOptionInt32.read(from: &buf), 
                maxSubscriptions: FfiConverterOptionInt32.read(from: &buf), 
                maxFilters: FfiConverterOptionInt32.read(from: &buf), 
                maxLimit: FfiConverterOptionInt32.read(from: &buf), 
                maxSubidLength: FfiConverterOptionInt32.read(from: &buf), 
                maxEventTags: FfiConverterOptionInt32.read(from: &buf), 
                maxContentLength: FfiConverterOptionInt32.read(from: &buf), 
                minPowDifficulty: FfiConverterOptionInt32.read(from: &buf), 
                authRequired: FfiConverterOptionBool.read(from: &buf), 
                paymentRequired: FfiConverterOptionBool.read(from: &buf), 
                createdAtLowerLimit: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                createdAtUpperLimit: FfiConverterOptionTypeTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: Limitation, into buf: inout [UInt8]) {
        FfiConverterOptionInt32.write(value.maxMessageLength, into: &buf)
        FfiConverterOptionInt32.write(value.maxSubscriptions, into: &buf)
        FfiConverterOptionInt32.write(value.maxFilters, into: &buf)
        FfiConverterOptionInt32.write(value.maxLimit, into: &buf)
        FfiConverterOptionInt32.write(value.maxSubidLength, into: &buf)
        FfiConverterOptionInt32.write(value.maxEventTags, into: &buf)
        FfiConverterOptionInt32.write(value.maxContentLength, into: &buf)
        FfiConverterOptionInt32.write(value.minPowDifficulty, into: &buf)
        FfiConverterOptionBool.write(value.authRequired, into: &buf)
        FfiConverterOptionBool.write(value.paymentRequired, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.createdAtLowerLimit, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.createdAtUpperLimit, into: &buf)
    }
}


public func FfiConverterTypeLimitation_lift(_ buf: RustBuffer) throws -> Limitation {
    return try FfiConverterTypeLimitation.lift(buf)
}

public func FfiConverterTypeLimitation_lower(_ value: Limitation) -> RustBuffer {
    return FfiConverterTypeLimitation.lower(value)
}


/**
 * List Invoice Request Params
 */
public struct ListTransactionsRequestParams {
    /**
     * Starting timestamp in seconds since epoch
     */
    public var from: UInt64?
    /**
     * Ending timestamp in seconds since epoch
     */
    public var until: UInt64?
    /**
     * Number of invoices to return
     */
    public var limit: UInt64?
    /**
     * Offset of the first invoice to return
     */
    public var offset: UInt64?
    /**
     * If true, include unpaid invoices
     */
    public var unpaid: Bool?
    /**
     * [`TransactionType::Incoming`] for invoices, [`TransactionType::Outgoing`] for payments, [`None`] for both
     */
    public var transactionType: TransactionType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Starting timestamp in seconds since epoch
         */from: UInt64?, 
        /**
         * Ending timestamp in seconds since epoch
         */until: UInt64?, 
        /**
         * Number of invoices to return
         */limit: UInt64?, 
        /**
         * Offset of the first invoice to return
         */offset: UInt64?, 
        /**
         * If true, include unpaid invoices
         */unpaid: Bool?, 
        /**
         * [`TransactionType::Incoming`] for invoices, [`TransactionType::Outgoing`] for payments, [`None`] for both
         */transactionType: TransactionType?) {
        self.from = from
        self.until = until
        self.limit = limit
        self.offset = offset
        self.unpaid = unpaid
        self.transactionType = transactionType
    }
}



extension ListTransactionsRequestParams: Equatable, Hashable {
    public static func ==(lhs: ListTransactionsRequestParams, rhs: ListTransactionsRequestParams) -> Bool {
        if lhs.from != rhs.from {
            return false
        }
        if lhs.until != rhs.until {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.offset != rhs.offset {
            return false
        }
        if lhs.unpaid != rhs.unpaid {
            return false
        }
        if lhs.transactionType != rhs.transactionType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(from)
        hasher.combine(until)
        hasher.combine(limit)
        hasher.combine(offset)
        hasher.combine(unpaid)
        hasher.combine(transactionType)
    }
}


public struct FfiConverterTypeListTransactionsRequestParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListTransactionsRequestParams {
        return
            try ListTransactionsRequestParams(
                from: FfiConverterOptionUInt64.read(from: &buf), 
                until: FfiConverterOptionUInt64.read(from: &buf), 
                limit: FfiConverterOptionUInt64.read(from: &buf), 
                offset: FfiConverterOptionUInt64.read(from: &buf), 
                unpaid: FfiConverterOptionBool.read(from: &buf), 
                transactionType: FfiConverterOptionTypeTransactionType.read(from: &buf)
        )
    }

    public static func write(_ value: ListTransactionsRequestParams, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.from, into: &buf)
        FfiConverterOptionUInt64.write(value.until, into: &buf)
        FfiConverterOptionUInt64.write(value.limit, into: &buf)
        FfiConverterOptionUInt64.write(value.offset, into: &buf)
        FfiConverterOptionBool.write(value.unpaid, into: &buf)
        FfiConverterOptionTypeTransactionType.write(value.transactionType, into: &buf)
    }
}


public func FfiConverterTypeListTransactionsRequestParams_lift(_ buf: RustBuffer) throws -> ListTransactionsRequestParams {
    return try FfiConverterTypeListTransactionsRequestParams.lift(buf)
}

public func FfiConverterTypeListTransactionsRequestParams_lower(_ value: ListTransactionsRequestParams) -> RustBuffer {
    return FfiConverterTypeListTransactionsRequestParams.lower(value)
}


public struct LiveEvent {
    public var id: String
    public var title: String?
    public var summary: String?
    public var image: Image?
    public var hashtags: [String]
    public var streaming: String?
    public var recording: String?
    public var start: Timestamp?
    public var ends: Timestamp?
    public var status: LiveEventStatus?
    public var currentParticipants: UInt64?
    public var totalParticipants: UInt64?
    public var relays: [String]
    public var host: LiveEventHost?
    public var speakers: [Person]
    public var participants: [Person]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, title: String?, summary: String?, image: Image?, hashtags: [String], streaming: String?, recording: String?, start: Timestamp?, ends: Timestamp?, status: LiveEventStatus?, currentParticipants: UInt64?, totalParticipants: UInt64?, relays: [String], host: LiveEventHost?, speakers: [Person], participants: [Person]) {
        self.id = id
        self.title = title
        self.summary = summary
        self.image = image
        self.hashtags = hashtags
        self.streaming = streaming
        self.recording = recording
        self.start = start
        self.ends = ends
        self.status = status
        self.currentParticipants = currentParticipants
        self.totalParticipants = totalParticipants
        self.relays = relays
        self.host = host
        self.speakers = speakers
        self.participants = participants
    }
}



public struct FfiConverterTypeLiveEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveEvent {
        return
            try LiveEvent(
                id: FfiConverterString.read(from: &buf), 
                title: FfiConverterOptionString.read(from: &buf), 
                summary: FfiConverterOptionString.read(from: &buf), 
                image: FfiConverterOptionTypeImage.read(from: &buf), 
                hashtags: FfiConverterSequenceString.read(from: &buf), 
                streaming: FfiConverterOptionString.read(from: &buf), 
                recording: FfiConverterOptionString.read(from: &buf), 
                start: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                ends: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                status: FfiConverterOptionTypeLiveEventStatus.read(from: &buf), 
                currentParticipants: FfiConverterOptionUInt64.read(from: &buf), 
                totalParticipants: FfiConverterOptionUInt64.read(from: &buf), 
                relays: FfiConverterSequenceString.read(from: &buf), 
                host: FfiConverterOptionTypeLiveEventHost.read(from: &buf), 
                speakers: FfiConverterSequenceTypePerson.read(from: &buf), 
                participants: FfiConverterSequenceTypePerson.read(from: &buf)
        )
    }

    public static func write(_ value: LiveEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.summary, into: &buf)
        FfiConverterOptionTypeImage.write(value.image, into: &buf)
        FfiConverterSequenceString.write(value.hashtags, into: &buf)
        FfiConverterOptionString.write(value.streaming, into: &buf)
        FfiConverterOptionString.write(value.recording, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.start, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.ends, into: &buf)
        FfiConverterOptionTypeLiveEventStatus.write(value.status, into: &buf)
        FfiConverterOptionUInt64.write(value.currentParticipants, into: &buf)
        FfiConverterOptionUInt64.write(value.totalParticipants, into: &buf)
        FfiConverterSequenceString.write(value.relays, into: &buf)
        FfiConverterOptionTypeLiveEventHost.write(value.host, into: &buf)
        FfiConverterSequenceTypePerson.write(value.speakers, into: &buf)
        FfiConverterSequenceTypePerson.write(value.participants, into: &buf)
    }
}


public func FfiConverterTypeLiveEvent_lift(_ buf: RustBuffer) throws -> LiveEvent {
    return try FfiConverterTypeLiveEvent.lift(buf)
}

public func FfiConverterTypeLiveEvent_lower(_ value: LiveEvent) -> RustBuffer {
    return FfiConverterTypeLiveEvent.lower(value)
}


public struct LiveEventHost {
    public var publicKey: PublicKey
    public var relayUrl: String?
    public var proof: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: PublicKey, relayUrl: String?, proof: String?) {
        self.publicKey = publicKey
        self.relayUrl = relayUrl
        self.proof = proof
    }
}



public struct FfiConverterTypeLiveEventHost: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveEventHost {
        return
            try LiveEventHost(
                publicKey: FfiConverterTypePublicKey.read(from: &buf), 
                relayUrl: FfiConverterOptionString.read(from: &buf), 
                proof: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LiveEventHost, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterOptionString.write(value.relayUrl, into: &buf)
        FfiConverterOptionString.write(value.proof, into: &buf)
    }
}


public func FfiConverterTypeLiveEventHost_lift(_ buf: RustBuffer) throws -> LiveEventHost {
    return try FfiConverterTypeLiveEventHost.lift(buf)
}

public func FfiConverterTypeLiveEventHost_lower(_ value: LiveEventHost) -> RustBuffer {
    return FfiConverterTypeLiveEventHost.lower(value)
}


/**
 * Lookup Invoice Request Params
 */
public struct LookupInvoiceRequestParams {
    /**
     * Payment hash of invoice
     */
    public var paymentHash: String?
    /**
     * Bolt11 invoice
     */
    public var invoice: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Payment hash of invoice
         */paymentHash: String?, 
        /**
         * Bolt11 invoice
         */invoice: String?) {
        self.paymentHash = paymentHash
        self.invoice = invoice
    }
}



extension LookupInvoiceRequestParams: Equatable, Hashable {
    public static func ==(lhs: LookupInvoiceRequestParams, rhs: LookupInvoiceRequestParams) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
        hasher.combine(invoice)
    }
}


public struct FfiConverterTypeLookupInvoiceRequestParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LookupInvoiceRequestParams {
        return
            try LookupInvoiceRequestParams(
                paymentHash: FfiConverterOptionString.read(from: &buf), 
                invoice: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LookupInvoiceRequestParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.paymentHash, into: &buf)
        FfiConverterOptionString.write(value.invoice, into: &buf)
    }
}


public func FfiConverterTypeLookupInvoiceRequestParams_lift(_ buf: RustBuffer) throws -> LookupInvoiceRequestParams {
    return try FfiConverterTypeLookupInvoiceRequestParams.lift(buf)
}

public func FfiConverterTypeLookupInvoiceRequestParams_lower(_ value: LookupInvoiceRequestParams) -> RustBuffer {
    return FfiConverterTypeLookupInvoiceRequestParams.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct LookupInvoiceResponseResult {
    /**
     * Transaction type
     */
    public var transactionType: TransactionType?
    /**
     * Bolt11 invoice
     */
    public var invoice: String?
    /**
     * Invoice's description
     */
    public var description: String?
    /**
     * Invoice's description hash
     */
    public var descriptionHash: String?
    /**
     * Payment preimage
     */
    public var preimage: String?
    /**
     * Payment hash
     */
    public var paymentHash: String
    /**
     * Amount in millisatoshis
     */
    public var amount: UInt64
    /**
     * Fees paid in millisatoshis
     */
    public var feesPaid: UInt64
    /**
     * Creation timestamp in seconds since epoch
     */
    public var createdAt: UInt64
    /**
     * Expiration timestamp in seconds since epoch
     */
    public var expiresAt: UInt64
    /**
     * Settled timestamp in seconds since epoch
     */
    public var settledAt: UInt64?
    /**
     * Optional metadata about the payment
     */
    public var metadata: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Transaction type
         */transactionType: TransactionType?, 
        /**
         * Bolt11 invoice
         */invoice: String?, 
        /**
         * Invoice's description
         */description: String?, 
        /**
         * Invoice's description hash
         */descriptionHash: String?, 
        /**
         * Payment preimage
         */preimage: String?, 
        /**
         * Payment hash
         */paymentHash: String, 
        /**
         * Amount in millisatoshis
         */amount: UInt64, 
        /**
         * Fees paid in millisatoshis
         */feesPaid: UInt64, 
        /**
         * Creation timestamp in seconds since epoch
         */createdAt: UInt64, 
        /**
         * Expiration timestamp in seconds since epoch
         */expiresAt: UInt64, 
        /**
         * Settled timestamp in seconds since epoch
         */settledAt: UInt64?, 
        /**
         * Optional metadata about the payment
         */metadata: String) {
        self.transactionType = transactionType
        self.invoice = invoice
        self.description = description
        self.descriptionHash = descriptionHash
        self.preimage = preimage
        self.paymentHash = paymentHash
        self.amount = amount
        self.feesPaid = feesPaid
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.settledAt = settledAt
        self.metadata = metadata
    }
}



extension LookupInvoiceResponseResult: Equatable, Hashable {
    public static func ==(lhs: LookupInvoiceResponseResult, rhs: LookupInvoiceResponseResult) -> Bool {
        if lhs.transactionType != rhs.transactionType {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.descriptionHash != rhs.descriptionHash {
            return false
        }
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.feesPaid != rhs.feesPaid {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.expiresAt != rhs.expiresAt {
            return false
        }
        if lhs.settledAt != rhs.settledAt {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionType)
        hasher.combine(invoice)
        hasher.combine(description)
        hasher.combine(descriptionHash)
        hasher.combine(preimage)
        hasher.combine(paymentHash)
        hasher.combine(amount)
        hasher.combine(feesPaid)
        hasher.combine(createdAt)
        hasher.combine(expiresAt)
        hasher.combine(settledAt)
        hasher.combine(metadata)
    }
}


public struct FfiConverterTypeLookupInvoiceResponseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LookupInvoiceResponseResult {
        return
            try LookupInvoiceResponseResult(
                transactionType: FfiConverterOptionTypeTransactionType.read(from: &buf), 
                invoice: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                descriptionHash: FfiConverterOptionString.read(from: &buf), 
                preimage: FfiConverterOptionString.read(from: &buf), 
                paymentHash: FfiConverterString.read(from: &buf), 
                amount: FfiConverterUInt64.read(from: &buf), 
                feesPaid: FfiConverterUInt64.read(from: &buf), 
                createdAt: FfiConverterUInt64.read(from: &buf), 
                expiresAt: FfiConverterUInt64.read(from: &buf), 
                settledAt: FfiConverterOptionUInt64.read(from: &buf), 
                metadata: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LookupInvoiceResponseResult, into buf: inout [UInt8]) {
        FfiConverterOptionTypeTransactionType.write(value.transactionType, into: &buf)
        FfiConverterOptionString.write(value.invoice, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.descriptionHash, into: &buf)
        FfiConverterOptionString.write(value.preimage, into: &buf)
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterUInt64.write(value.amount, into: &buf)
        FfiConverterUInt64.write(value.feesPaid, into: &buf)
        FfiConverterUInt64.write(value.createdAt, into: &buf)
        FfiConverterUInt64.write(value.expiresAt, into: &buf)
        FfiConverterOptionUInt64.write(value.settledAt, into: &buf)
        FfiConverterString.write(value.metadata, into: &buf)
    }
}


public func FfiConverterTypeLookupInvoiceResponseResult_lift(_ buf: RustBuffer) throws -> LookupInvoiceResponseResult {
    return try FfiConverterTypeLookupInvoiceResponseResult.lift(buf)
}

public func FfiConverterTypeLookupInvoiceResponseResult_lower(_ value: LookupInvoiceResponseResult) -> RustBuffer {
    return FfiConverterTypeLookupInvoiceResponseResult.lower(value)
}


/**
 * Make Invoice Request Params
 */
public struct MakeInvoiceRequestParams {
    /**
     * Amount in millisatoshis
     */
    public var amount: UInt64
    /**
     * Invoice description
     */
    public var description: String?
    /**
     * Invoice description hash
     */
    public var descriptionHash: String?
    /**
     * Invoice expiry in seconds
     */
    public var expiry: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Amount in millisatoshis
         */amount: UInt64, 
        /**
         * Invoice description
         */description: String?, 
        /**
         * Invoice description hash
         */descriptionHash: String?, 
        /**
         * Invoice expiry in seconds
         */expiry: UInt64?) {
        self.amount = amount
        self.description = description
        self.descriptionHash = descriptionHash
        self.expiry = expiry
    }
}



extension MakeInvoiceRequestParams: Equatable, Hashable {
    public static func ==(lhs: MakeInvoiceRequestParams, rhs: MakeInvoiceRequestParams) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.descriptionHash != rhs.descriptionHash {
            return false
        }
        if lhs.expiry != rhs.expiry {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(description)
        hasher.combine(descriptionHash)
        hasher.combine(expiry)
    }
}


public struct FfiConverterTypeMakeInvoiceRequestParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MakeInvoiceRequestParams {
        return
            try MakeInvoiceRequestParams(
                amount: FfiConverterUInt64.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                descriptionHash: FfiConverterOptionString.read(from: &buf), 
                expiry: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: MakeInvoiceRequestParams, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.descriptionHash, into: &buf)
        FfiConverterOptionUInt64.write(value.expiry, into: &buf)
    }
}


public func FfiConverterTypeMakeInvoiceRequestParams_lift(_ buf: RustBuffer) throws -> MakeInvoiceRequestParams {
    return try FfiConverterTypeMakeInvoiceRequestParams.lift(buf)
}

public func FfiConverterTypeMakeInvoiceRequestParams_lower(_ value: MakeInvoiceRequestParams) -> RustBuffer {
    return FfiConverterTypeMakeInvoiceRequestParams.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct MakeInvoiceResponseResult {
    /**
     * Bolt 11 invoice
     */
    public var invoice: String
    /**
     * Invoice's payment hash
     */
    public var paymentHash: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Bolt 11 invoice
         */invoice: String, 
        /**
         * Invoice's payment hash
         */paymentHash: String) {
        self.invoice = invoice
        self.paymentHash = paymentHash
    }
}



extension MakeInvoiceResponseResult: Equatable, Hashable {
    public static func ==(lhs: MakeInvoiceResponseResult, rhs: MakeInvoiceResponseResult) -> Bool {
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoice)
        hasher.combine(paymentHash)
    }
}


public struct FfiConverterTypeMakeInvoiceResponseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MakeInvoiceResponseResult {
        return
            try MakeInvoiceResponseResult(
                invoice: FfiConverterString.read(from: &buf), 
                paymentHash: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MakeInvoiceResponseResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterString.write(value.paymentHash, into: &buf)
    }
}


public func FfiConverterTypeMakeInvoiceResponseResult_lift(_ buf: RustBuffer) throws -> MakeInvoiceResponseResult {
    return try FfiConverterTypeMakeInvoiceResponseResult.lift(buf)
}

public func FfiConverterTypeMakeInvoiceResponseResult_lower(_ value: MakeInvoiceResponseResult) -> RustBuffer {
    return FfiConverterTypeMakeInvoiceResponseResult.lower(value)
}


public struct MetadataRecord {
    /**
     * Name
     */
    public var name: String?
    /**
     * Display name
     */
    public var displayName: String?
    /**
     * Description
     */
    public var about: String?
    /**
     * Website url
     */
    public var website: String?
    /**
     * Picture url
     */
    public var picture: String?
    /**
     * Banner url
     */
    public var banner: String?
    /**
     * NIP05 (ex. name@example.com)
     */
    public var nip05: String?
    /**
     * LNURL
     */
    public var lud06: String?
    /**
     * Lightning Address
     */
    public var lud16: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Name
         */name: String?, 
        /**
         * Display name
         */displayName: String?, 
        /**
         * Description
         */about: String?, 
        /**
         * Website url
         */website: String?, 
        /**
         * Picture url
         */picture: String?, 
        /**
         * Banner url
         */banner: String?, 
        /**
         * NIP05 (ex. name@example.com)
         */nip05: String?, 
        /**
         * LNURL
         */lud06: String?, 
        /**
         * Lightning Address
         */lud16: String?) {
        self.name = name
        self.displayName = displayName
        self.about = about
        self.website = website
        self.picture = picture
        self.banner = banner
        self.nip05 = nip05
        self.lud06 = lud06
        self.lud16 = lud16
    }
}



extension MetadataRecord: Equatable, Hashable {
    public static func ==(lhs: MetadataRecord, rhs: MetadataRecord) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.about != rhs.about {
            return false
        }
        if lhs.website != rhs.website {
            return false
        }
        if lhs.picture != rhs.picture {
            return false
        }
        if lhs.banner != rhs.banner {
            return false
        }
        if lhs.nip05 != rhs.nip05 {
            return false
        }
        if lhs.lud06 != rhs.lud06 {
            return false
        }
        if lhs.lud16 != rhs.lud16 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(displayName)
        hasher.combine(about)
        hasher.combine(website)
        hasher.combine(picture)
        hasher.combine(banner)
        hasher.combine(nip05)
        hasher.combine(lud06)
        hasher.combine(lud16)
    }
}


public struct FfiConverterTypeMetadataRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetadataRecord {
        return
            try MetadataRecord(
                name: FfiConverterOptionString.read(from: &buf), 
                displayName: FfiConverterOptionString.read(from: &buf), 
                about: FfiConverterOptionString.read(from: &buf), 
                website: FfiConverterOptionString.read(from: &buf), 
                picture: FfiConverterOptionString.read(from: &buf), 
                banner: FfiConverterOptionString.read(from: &buf), 
                nip05: FfiConverterOptionString.read(from: &buf), 
                lud06: FfiConverterOptionString.read(from: &buf), 
                lud16: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: MetadataRecord, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.about, into: &buf)
        FfiConverterOptionString.write(value.website, into: &buf)
        FfiConverterOptionString.write(value.picture, into: &buf)
        FfiConverterOptionString.write(value.banner, into: &buf)
        FfiConverterOptionString.write(value.nip05, into: &buf)
        FfiConverterOptionString.write(value.lud06, into: &buf)
        FfiConverterOptionString.write(value.lud16, into: &buf)
    }
}


public func FfiConverterTypeMetadataRecord_lift(_ buf: RustBuffer) throws -> MetadataRecord {
    return try FfiConverterTypeMetadataRecord.lift(buf)
}

public func FfiConverterTypeMetadataRecord_lower(_ value: MetadataRecord) -> RustBuffer {
    return FfiConverterTypeMetadataRecord.lower(value)
}


/**
 * Multi Pay Invoice Request Params
 */
public struct MultiPayInvoiceRequestParams {
    /**
     * Invoices to pay
     */
    public var invoices: [PayInvoiceRequestParams]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Invoices to pay
         */invoices: [PayInvoiceRequestParams]) {
        self.invoices = invoices
    }
}



extension MultiPayInvoiceRequestParams: Equatable, Hashable {
    public static func ==(lhs: MultiPayInvoiceRequestParams, rhs: MultiPayInvoiceRequestParams) -> Bool {
        if lhs.invoices != rhs.invoices {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoices)
    }
}


public struct FfiConverterTypeMultiPayInvoiceRequestParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiPayInvoiceRequestParams {
        return
            try MultiPayInvoiceRequestParams(
                invoices: FfiConverterSequenceTypePayInvoiceRequestParams.read(from: &buf)
        )
    }

    public static func write(_ value: MultiPayInvoiceRequestParams, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePayInvoiceRequestParams.write(value.invoices, into: &buf)
    }
}


public func FfiConverterTypeMultiPayInvoiceRequestParams_lift(_ buf: RustBuffer) throws -> MultiPayInvoiceRequestParams {
    return try FfiConverterTypeMultiPayInvoiceRequestParams.lift(buf)
}

public func FfiConverterTypeMultiPayInvoiceRequestParams_lower(_ value: MultiPayInvoiceRequestParams) -> RustBuffer {
    return FfiConverterTypeMultiPayInvoiceRequestParams.lower(value)
}


/**
 * Multi Pay Keysend Request Params
 */
public struct MultiPayKeysendRequestParams {
    /**
     * Keysends
     */
    public var keysends: [PayKeysendRequestParams]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Keysends
         */keysends: [PayKeysendRequestParams]) {
        self.keysends = keysends
    }
}



extension MultiPayKeysendRequestParams: Equatable, Hashable {
    public static func ==(lhs: MultiPayKeysendRequestParams, rhs: MultiPayKeysendRequestParams) -> Bool {
        if lhs.keysends != rhs.keysends {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(keysends)
    }
}


public struct FfiConverterTypeMultiPayKeysendRequestParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiPayKeysendRequestParams {
        return
            try MultiPayKeysendRequestParams(
                keysends: FfiConverterSequenceTypePayKeysendRequestParams.read(from: &buf)
        )
    }

    public static func write(_ value: MultiPayKeysendRequestParams, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePayKeysendRequestParams.write(value.keysends, into: &buf)
    }
}


public func FfiConverterTypeMultiPayKeysendRequestParams_lift(_ buf: RustBuffer) throws -> MultiPayKeysendRequestParams {
    return try FfiConverterTypeMultiPayKeysendRequestParams.lift(buf)
}

public func FfiConverterTypeMultiPayKeysendRequestParams_lower(_ value: MultiPayKeysendRequestParams) -> RustBuffer {
    return FfiConverterTypeMultiPayKeysendRequestParams.lower(value)
}


/**
 * Things the user doesn't want to see in their feeds
 *
 * <https://github.com/nostr-protocol/nips/blob/master/51.md>
 */
public struct MuteList {
    public var publicKeys: [PublicKey]
    public var hashtags: [String]
    public var eventIds: [EventId]
    public var words: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKeys: [PublicKey], hashtags: [String], eventIds: [EventId], words: [String]) {
        self.publicKeys = publicKeys
        self.hashtags = hashtags
        self.eventIds = eventIds
        self.words = words
    }
}



public struct FfiConverterTypeMuteList: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MuteList {
        return
            try MuteList(
                publicKeys: FfiConverterSequenceTypePublicKey.read(from: &buf), 
                hashtags: FfiConverterSequenceString.read(from: &buf), 
                eventIds: FfiConverterSequenceTypeEventId.read(from: &buf), 
                words: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: MuteList, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePublicKey.write(value.publicKeys, into: &buf)
        FfiConverterSequenceString.write(value.hashtags, into: &buf)
        FfiConverterSequenceTypeEventId.write(value.eventIds, into: &buf)
        FfiConverterSequenceString.write(value.words, into: &buf)
    }
}


public func FfiConverterTypeMuteList_lift(_ buf: RustBuffer) throws -> MuteList {
    return try FfiConverterTypeMuteList.lift(buf)
}

public func FfiConverterTypeMuteList_lower(_ value: MuteList) -> RustBuffer {
    return FfiConverterTypeMuteList.lower(value)
}


/**
 * NIP47 Error message
 */
public struct Nip47Error {
    /**
     * Error Code
     */
    public var code: ErrorCode
    /**
     * Human Readable error message
     */
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Error Code
         */code: ErrorCode, 
        /**
         * Human Readable error message
         */message: String) {
        self.code = code
        self.message = message
    }
}



extension Nip47Error: Equatable, Hashable {
    public static func ==(lhs: Nip47Error, rhs: Nip47Error) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(message)
    }
}


public struct FfiConverterTypeNIP47Error: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip47Error {
        return
            try Nip47Error(
                code: FfiConverterTypeErrorCode.read(from: &buf), 
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Nip47Error, into buf: inout [UInt8]) {
        FfiConverterTypeErrorCode.write(value.code, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
    }
}


public func FfiConverterTypeNIP47Error_lift(_ buf: RustBuffer) throws -> Nip47Error {
    return try FfiConverterTypeNIP47Error.lift(buf)
}

public func FfiConverterTypeNIP47Error_lower(_ value: Nip47Error) -> RustBuffer {
    return FfiConverterTypeNIP47Error.lower(value)
}


/**
 * Pay Invoice Request Params
 */
public struct PayInvoiceRequestParams {
    /**
     * Optional id
     */
    public var id: String?
    /**
     * Request invoice
     */
    public var invoice: String
    /**
     * Optional amount in millisatoshis
     */
    public var amount: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Optional id
         */id: String?, 
        /**
         * Request invoice
         */invoice: String, 
        /**
         * Optional amount in millisatoshis
         */amount: UInt64?) {
        self.id = id
        self.invoice = invoice
        self.amount = amount
    }
}



extension PayInvoiceRequestParams: Equatable, Hashable {
    public static func ==(lhs: PayInvoiceRequestParams, rhs: PayInvoiceRequestParams) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(invoice)
        hasher.combine(amount)
    }
}


public struct FfiConverterTypePayInvoiceRequestParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayInvoiceRequestParams {
        return
            try PayInvoiceRequestParams(
                id: FfiConverterOptionString.read(from: &buf), 
                invoice: FfiConverterString.read(from: &buf), 
                amount: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PayInvoiceRequestParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.id, into: &buf)
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterOptionUInt64.write(value.amount, into: &buf)
    }
}


public func FfiConverterTypePayInvoiceRequestParams_lift(_ buf: RustBuffer) throws -> PayInvoiceRequestParams {
    return try FfiConverterTypePayInvoiceRequestParams.lift(buf)
}

public func FfiConverterTypePayInvoiceRequestParams_lower(_ value: PayInvoiceRequestParams) -> RustBuffer {
    return FfiConverterTypePayInvoiceRequestParams.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct PayInvoiceResponseResult {
    /**
     * Response preimage
     */
    public var preimage: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Response preimage
         */preimage: String) {
        self.preimage = preimage
    }
}



extension PayInvoiceResponseResult: Equatable, Hashable {
    public static func ==(lhs: PayInvoiceResponseResult, rhs: PayInvoiceResponseResult) -> Bool {
        if lhs.preimage != rhs.preimage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(preimage)
    }
}


public struct FfiConverterTypePayInvoiceResponseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayInvoiceResponseResult {
        return
            try PayInvoiceResponseResult(
                preimage: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PayInvoiceResponseResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.preimage, into: &buf)
    }
}


public func FfiConverterTypePayInvoiceResponseResult_lift(_ buf: RustBuffer) throws -> PayInvoiceResponseResult {
    return try FfiConverterTypePayInvoiceResponseResult.lift(buf)
}

public func FfiConverterTypePayInvoiceResponseResult_lower(_ value: PayInvoiceResponseResult) -> RustBuffer {
    return FfiConverterTypePayInvoiceResponseResult.lower(value)
}


/**
 * Pay Invoice Request Params
 */
public struct PayKeysendRequestParams {
    /**
     * Optional id
     */
    public var id: String?
    /**
     * Amount in millisatoshis
     */
    public var amount: UInt64
    /**
     * Receiver's node id
     */
    public var pubkey: String
    /**
     * Optional preimage
     */
    public var preimage: String?
    /**
     * Optional TLVs to be added to the keysend payment
     */
    public var tlvRecords: [KeysendTlvRecord]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Optional id
         */id: String?, 
        /**
         * Amount in millisatoshis
         */amount: UInt64, 
        /**
         * Receiver's node id
         */pubkey: String, 
        /**
         * Optional preimage
         */preimage: String?, 
        /**
         * Optional TLVs to be added to the keysend payment
         */tlvRecords: [KeysendTlvRecord]) {
        self.id = id
        self.amount = amount
        self.pubkey = pubkey
        self.preimage = preimage
        self.tlvRecords = tlvRecords
    }
}



extension PayKeysendRequestParams: Equatable, Hashable {
    public static func ==(lhs: PayKeysendRequestParams, rhs: PayKeysendRequestParams) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.tlvRecords != rhs.tlvRecords {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(amount)
        hasher.combine(pubkey)
        hasher.combine(preimage)
        hasher.combine(tlvRecords)
    }
}


public struct FfiConverterTypePayKeysendRequestParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayKeysendRequestParams {
        return
            try PayKeysendRequestParams(
                id: FfiConverterOptionString.read(from: &buf), 
                amount: FfiConverterUInt64.read(from: &buf), 
                pubkey: FfiConverterString.read(from: &buf), 
                preimage: FfiConverterOptionString.read(from: &buf), 
                tlvRecords: FfiConverterSequenceTypeKeysendTLVRecord.read(from: &buf)
        )
    }

    public static func write(_ value: PayKeysendRequestParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.id, into: &buf)
        FfiConverterUInt64.write(value.amount, into: &buf)
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterOptionString.write(value.preimage, into: &buf)
        FfiConverterSequenceTypeKeysendTLVRecord.write(value.tlvRecords, into: &buf)
    }
}


public func FfiConverterTypePayKeysendRequestParams_lift(_ buf: RustBuffer) throws -> PayKeysendRequestParams {
    return try FfiConverterTypePayKeysendRequestParams.lift(buf)
}

public func FfiConverterTypePayKeysendRequestParams_lower(_ value: PayKeysendRequestParams) -> RustBuffer {
    return FfiConverterTypePayKeysendRequestParams.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct PayKeysendResponseResult {
    /**
     * Response preimage
     */
    public var preimage: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Response preimage
         */preimage: String) {
        self.preimage = preimage
    }
}



extension PayKeysendResponseResult: Equatable, Hashable {
    public static func ==(lhs: PayKeysendResponseResult, rhs: PayKeysendResponseResult) -> Bool {
        if lhs.preimage != rhs.preimage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(preimage)
    }
}


public struct FfiConverterTypePayKeysendResponseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayKeysendResponseResult {
        return
            try PayKeysendResponseResult(
                preimage: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PayKeysendResponseResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.preimage, into: &buf)
    }
}


public func FfiConverterTypePayKeysendResponseResult_lift(_ buf: RustBuffer) throws -> PayKeysendResponseResult {
    return try FfiConverterTypePayKeysendResponseResult.lift(buf)
}

public func FfiConverterTypePayKeysendResponseResult_lower(_ value: PayKeysendResponseResult) -> RustBuffer {
    return FfiConverterTypePayKeysendResponseResult.lower(value)
}


public struct Person {
    public var publicKey: PublicKey
    public var url: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: PublicKey, url: String?) {
        self.publicKey = publicKey
        self.url = url
    }
}



public struct FfiConverterTypePerson: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Person {
        return
            try Person(
                publicKey: FfiConverterTypePublicKey.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Person, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
    }
}


public func FfiConverterTypePerson_lift(_ buf: RustBuffer) throws -> Person {
    return try FfiConverterTypePerson.lift(buf)
}

public func FfiConverterTypePerson_lower(_ value: Person) -> RustBuffer {
    return FfiConverterTypePerson.lower(value)
}


/**
 * Payload for creating or updating product
 */
public struct ProductData {
    /**
     * UUID of the product generated by merchant
     */
    public var id: String
    /**
     * Id of the stall that this product belongs to
     */
    public var stallId: String
    /**
     * Product name
     */
    public var name: String
    /**
     * Description of the product
     */
    public var description: String?
    /**
     * Image urls of the product
     */
    public var images: [String]?
    /**
     * Currency used
     */
    public var currency: String
    /**
     * Price of the product
     */
    public var price: Double
    /**
     * Available items
     */
    public var quantity: UInt64
    /**
     * Specifications of the product
     */
    public var specs: [[String]]?
    /**
     * Shipping method costs
     */
    public var shipping: [ShippingCost]
    /**
     * Categories of the product (will be added to tags)
     */
    public var categories: [String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * UUID of the product generated by merchant
         */id: String, 
        /**
         * Id of the stall that this product belongs to
         */stallId: String, 
        /**
         * Product name
         */name: String, 
        /**
         * Description of the product
         */description: String?, 
        /**
         * Image urls of the product
         */images: [String]?, 
        /**
         * Currency used
         */currency: String, 
        /**
         * Price of the product
         */price: Double, 
        /**
         * Available items
         */quantity: UInt64, 
        /**
         * Specifications of the product
         */specs: [[String]]?, 
        /**
         * Shipping method costs
         */shipping: [ShippingCost], 
        /**
         * Categories of the product (will be added to tags)
         */categories: [String]?) {
        self.id = id
        self.stallId = stallId
        self.name = name
        self.description = description
        self.images = images
        self.currency = currency
        self.price = price
        self.quantity = quantity
        self.specs = specs
        self.shipping = shipping
        self.categories = categories
    }
}



extension ProductData: Equatable, Hashable {
    public static func ==(lhs: ProductData, rhs: ProductData) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.stallId != rhs.stallId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.images != rhs.images {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.price != rhs.price {
            return false
        }
        if lhs.quantity != rhs.quantity {
            return false
        }
        if lhs.specs != rhs.specs {
            return false
        }
        if lhs.shipping != rhs.shipping {
            return false
        }
        if lhs.categories != rhs.categories {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(stallId)
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(images)
        hasher.combine(currency)
        hasher.combine(price)
        hasher.combine(quantity)
        hasher.combine(specs)
        hasher.combine(shipping)
        hasher.combine(categories)
    }
}


public struct FfiConverterTypeProductData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProductData {
        return
            try ProductData(
                id: FfiConverterString.read(from: &buf), 
                stallId: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                images: FfiConverterOptionSequenceString.read(from: &buf), 
                currency: FfiConverterString.read(from: &buf), 
                price: FfiConverterDouble.read(from: &buf), 
                quantity: FfiConverterUInt64.read(from: &buf), 
                specs: FfiConverterOptionSequenceSequenceString.read(from: &buf), 
                shipping: FfiConverterSequenceTypeShippingCost.read(from: &buf), 
                categories: FfiConverterOptionSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: ProductData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.stallId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionSequenceString.write(value.images, into: &buf)
        FfiConverterString.write(value.currency, into: &buf)
        FfiConverterDouble.write(value.price, into: &buf)
        FfiConverterUInt64.write(value.quantity, into: &buf)
        FfiConverterOptionSequenceSequenceString.write(value.specs, into: &buf)
        FfiConverterSequenceTypeShippingCost.write(value.shipping, into: &buf)
        FfiConverterOptionSequenceString.write(value.categories, into: &buf)
    }
}


public func FfiConverterTypeProductData_lift(_ buf: RustBuffer) throws -> ProductData {
    return try FfiConverterTypeProductData.lift(buf)
}

public func FfiConverterTypeProductData_lower(_ value: ProductData) -> RustBuffer {
    return FfiConverterTypeProductData.lower(value)
}


/**
 * Raw event
 */
public struct RawEventRecord {
    /**
     * ID
     */
    public var id: String
    /**
     * Author
     */
    public var pubkey: String
    /**
     * Timestamp (seconds)
     */
    public var createdAt: UInt64
    /**
     * Kind
     */
    public var kind: UInt16
    /**
     * Vector of strings
     */
    public var tags: [[String]]
    /**
     * Content
     */
    public var content: String
    /**
     * Signature
     */
    public var sig: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * ID
         */id: String, 
        /**
         * Author
         */pubkey: String, 
        /**
         * Timestamp (seconds)
         */createdAt: UInt64, 
        /**
         * Kind
         */kind: UInt16, 
        /**
         * Vector of strings
         */tags: [[String]], 
        /**
         * Content
         */content: String, 
        /**
         * Signature
         */sig: String) {
        self.id = id
        self.pubkey = pubkey
        self.createdAt = createdAt
        self.kind = kind
        self.tags = tags
        self.content = content
        self.sig = sig
    }
}



extension RawEventRecord: Equatable, Hashable {
    public static func ==(lhs: RawEventRecord, rhs: RawEventRecord) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.sig != rhs.sig {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(pubkey)
        hasher.combine(createdAt)
        hasher.combine(kind)
        hasher.combine(tags)
        hasher.combine(content)
        hasher.combine(sig)
    }
}


public struct FfiConverterTypeRawEventRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RawEventRecord {
        return
            try RawEventRecord(
                id: FfiConverterString.read(from: &buf), 
                pubkey: FfiConverterString.read(from: &buf), 
                createdAt: FfiConverterUInt64.read(from: &buf), 
                kind: FfiConverterUInt16.read(from: &buf), 
                tags: FfiConverterSequenceSequenceString.read(from: &buf), 
                content: FfiConverterString.read(from: &buf), 
                sig: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RawEventRecord, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterUInt64.write(value.createdAt, into: &buf)
        FfiConverterUInt16.write(value.kind, into: &buf)
        FfiConverterSequenceSequenceString.write(value.tags, into: &buf)
        FfiConverterString.write(value.content, into: &buf)
        FfiConverterString.write(value.sig, into: &buf)
    }
}


public func FfiConverterTypeRawEventRecord_lift(_ buf: RustBuffer) throws -> RawEventRecord {
    return try FfiConverterTypeRawEventRecord.lift(buf)
}

public func FfiConverterTypeRawEventRecord_lower(_ value: RawEventRecord) -> RustBuffer {
    return FfiConverterTypeRawEventRecord.lower(value)
}


/**
 * A retention schedule for the relay
 */
public struct Retention {
    /**
     * The event kinds this retention pertains to
     */
    public var kinds: [RetentionKind]?
    /**
     * The amount of time these events are kept
     */
    public var time: UInt64?
    /**
     * The max number of events kept before removing older events
     */
    public var count: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The event kinds this retention pertains to
         */kinds: [RetentionKind]?, 
        /**
         * The amount of time these events are kept
         */time: UInt64?, 
        /**
         * The max number of events kept before removing older events
         */count: UInt64?) {
        self.kinds = kinds
        self.time = time
        self.count = count
    }
}



extension Retention: Equatable, Hashable {
    public static func ==(lhs: Retention, rhs: Retention) -> Bool {
        if lhs.kinds != rhs.kinds {
            return false
        }
        if lhs.time != rhs.time {
            return false
        }
        if lhs.count != rhs.count {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kinds)
        hasher.combine(time)
        hasher.combine(count)
    }
}


public struct FfiConverterTypeRetention: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Retention {
        return
            try Retention(
                kinds: FfiConverterOptionSequenceTypeRetentionKind.read(from: &buf), 
                time: FfiConverterOptionUInt64.read(from: &buf), 
                count: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Retention, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypeRetentionKind.write(value.kinds, into: &buf)
        FfiConverterOptionUInt64.write(value.time, into: &buf)
        FfiConverterOptionUInt64.write(value.count, into: &buf)
    }
}


public func FfiConverterTypeRetention_lift(_ buf: RustBuffer) throws -> Retention {
    return try FfiConverterTypeRetention.lift(buf)
}

public func FfiConverterTypeRetention_lower(_ value: Retention) -> RustBuffer {
    return FfiConverterTypeRetention.lower(value)
}


/**
 * Delivery cost for shipping method as defined by the merchant in the product
 */
public struct ShippingCost {
    /**
     * Id of the shipping method
     */
    public var id: String
    /**
     * Cost to use this shipping method
     */
    public var cost: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Id of the shipping method
         */id: String, 
        /**
         * Cost to use this shipping method
         */cost: Double) {
        self.id = id
        self.cost = cost
    }
}



extension ShippingCost: Equatable, Hashable {
    public static func ==(lhs: ShippingCost, rhs: ShippingCost) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.cost != rhs.cost {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(cost)
    }
}


public struct FfiConverterTypeShippingCost: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShippingCost {
        return
            try ShippingCost(
                id: FfiConverterString.read(from: &buf), 
                cost: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: ShippingCost, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterDouble.write(value.cost, into: &buf)
    }
}


public func FfiConverterTypeShippingCost_lift(_ buf: RustBuffer) throws -> ShippingCost {
    return try FfiConverterTypeShippingCost.lift(buf)
}

public func FfiConverterTypeShippingCost_lower(_ value: ShippingCost) -> RustBuffer {
    return FfiConverterTypeShippingCost.lower(value)
}


public struct ShippingMethodRecord {
    /**
     * Shipping method unique id by merchant
     */
    public var id: String
    /**
     * Shipping method name
     */
    public var name: String?
    /**
     * Shipping method cost (currency is the same as the stall)
     */
    public var cost: Double
    /**
     * Covered regions
     */
    public var regions: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Shipping method unique id by merchant
         */id: String, 
        /**
         * Shipping method name
         */name: String?, 
        /**
         * Shipping method cost (currency is the same as the stall)
         */cost: Double, 
        /**
         * Covered regions
         */regions: [String]) {
        self.id = id
        self.name = name
        self.cost = cost
        self.regions = regions
    }
}



extension ShippingMethodRecord: Equatable, Hashable {
    public static func ==(lhs: ShippingMethodRecord, rhs: ShippingMethodRecord) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.cost != rhs.cost {
            return false
        }
        if lhs.regions != rhs.regions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(cost)
        hasher.combine(regions)
    }
}


public struct FfiConverterTypeShippingMethodRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShippingMethodRecord {
        return
            try ShippingMethodRecord(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                cost: FfiConverterDouble.read(from: &buf), 
                regions: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: ShippingMethodRecord, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterDouble.write(value.cost, into: &buf)
        FfiConverterSequenceString.write(value.regions, into: &buf)
    }
}


public func FfiConverterTypeShippingMethodRecord_lift(_ buf: RustBuffer) throws -> ShippingMethodRecord {
    return try FfiConverterTypeShippingMethodRecord.lift(buf)
}

public func FfiConverterTypeShippingMethodRecord_lower(_ value: ShippingMethodRecord) -> RustBuffer {
    return FfiConverterTypeShippingMethodRecord.lower(value)
}


/**
 * Payload for creating or updating stall
 */
public struct StallDataRecord {
    /**
     * UUID of the stall generated by merchant
     */
    public var id: String
    /**
     * Stall name
     */
    public var name: String
    /**
     * Stall description
     */
    public var description: String?
    /**
     * Currency used
     */
    public var currency: String
    /**
     * Available shipping methods
     */
    public var shipping: [ShippingMethodRecord]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * UUID of the stall generated by merchant
         */id: String, 
        /**
         * Stall name
         */name: String, 
        /**
         * Stall description
         */description: String?, 
        /**
         * Currency used
         */currency: String, 
        /**
         * Available shipping methods
         */shipping: [ShippingMethodRecord]) {
        self.id = id
        self.name = name
        self.description = description
        self.currency = currency
        self.shipping = shipping
    }
}



extension StallDataRecord: Equatable, Hashable {
    public static func ==(lhs: StallDataRecord, rhs: StallDataRecord) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.shipping != rhs.shipping {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(currency)
        hasher.combine(shipping)
    }
}


public struct FfiConverterTypeStallDataRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StallDataRecord {
        return
            try StallDataRecord(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                currency: FfiConverterString.read(from: &buf), 
                shipping: FfiConverterSequenceTypeShippingMethodRecord.read(from: &buf)
        )
    }

    public static func write(_ value: StallDataRecord, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterString.write(value.currency, into: &buf)
        FfiConverterSequenceTypeShippingMethodRecord.write(value.shipping, into: &buf)
    }
}


public func FfiConverterTypeStallDataRecord_lift(_ buf: RustBuffer) throws -> StallDataRecord {
    return try FfiConverterTypeStallDataRecord.lift(buf)
}

public func FfiConverterTypeStallDataRecord_lower(_ value: StallDataRecord) -> RustBuffer {
    return FfiConverterTypeStallDataRecord.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Alphabet {
    
    case a
    case b
    case c
    case d
    case e
    case f
    case g
    case h
    case i
    case j
    case k
    case l
    case m
    case n
    case o
    case p
    case q
    case r
    case s
    case t
    case u
    case v
    case w
    case x
    case y
    case z
}


public struct FfiConverterTypeAlphabet: FfiConverterRustBuffer {
    typealias SwiftType = Alphabet

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Alphabet {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .a
        
        case 2: return .b
        
        case 3: return .c
        
        case 4: return .d
        
        case 5: return .e
        
        case 6: return .f
        
        case 7: return .g
        
        case 8: return .h
        
        case 9: return .i
        
        case 10: return .j
        
        case 11: return .k
        
        case 12: return .l
        
        case 13: return .m
        
        case 14: return .n
        
        case 15: return .o
        
        case 16: return .p
        
        case 17: return .q
        
        case 18: return .r
        
        case 19: return .s
        
        case 20: return .t
        
        case 21: return .u
        
        case 22: return .v
        
        case 23: return .w
        
        case 24: return .x
        
        case 25: return .y
        
        case 26: return .z
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Alphabet, into buf: inout [UInt8]) {
        switch value {
        
        
        case .a:
            writeInt(&buf, Int32(1))
        
        
        case .b:
            writeInt(&buf, Int32(2))
        
        
        case .c:
            writeInt(&buf, Int32(3))
        
        
        case .d:
            writeInt(&buf, Int32(4))
        
        
        case .e:
            writeInt(&buf, Int32(5))
        
        
        case .f:
            writeInt(&buf, Int32(6))
        
        
        case .g:
            writeInt(&buf, Int32(7))
        
        
        case .h:
            writeInt(&buf, Int32(8))
        
        
        case .i:
            writeInt(&buf, Int32(9))
        
        
        case .j:
            writeInt(&buf, Int32(10))
        
        
        case .k:
            writeInt(&buf, Int32(11))
        
        
        case .l:
            writeInt(&buf, Int32(12))
        
        
        case .m:
            writeInt(&buf, Int32(13))
        
        
        case .n:
            writeInt(&buf, Int32(14))
        
        
        case .o:
            writeInt(&buf, Int32(15))
        
        
        case .p:
            writeInt(&buf, Int32(16))
        
        
        case .q:
            writeInt(&buf, Int32(17))
        
        
        case .r:
            writeInt(&buf, Int32(18))
        
        
        case .s:
            writeInt(&buf, Int32(19))
        
        
        case .t:
            writeInt(&buf, Int32(20))
        
        
        case .u:
            writeInt(&buf, Int32(21))
        
        
        case .v:
            writeInt(&buf, Int32(22))
        
        
        case .w:
            writeInt(&buf, Int32(23))
        
        
        case .x:
            writeInt(&buf, Int32(24))
        
        
        case .y:
            writeInt(&buf, Int32(25))
        
        
        case .z:
            writeInt(&buf, Int32(26))
        
        }
    }
}


public func FfiConverterTypeAlphabet_lift(_ buf: RustBuffer) throws -> Alphabet {
    return try FfiConverterTypeAlphabet.lift(buf)
}

public func FfiConverterTypeAlphabet_lower(_ value: Alphabet) -> RustBuffer {
    return FfiConverterTypeAlphabet.lower(value)
}



extension Alphabet: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Messages sent by clients, received by relays
 */

public enum ClientMessageEnum {
    
    case eventMsg(event: Event
    )
    case req(subscriptionId: String, filters: [Filter]
    )
    case count(subscriptionId: String, filters: [Filter]
    )
    case close(subscriptionId: String
    )
    case auth(event: Event
    )
    /**
     * Negentropy Open
     */
    case negOpen(subscriptionId: String, filter: Filter, 
        /**
         * ID size (MUST be between 8 and 32, inclusive)
         */idSize: UInt8, initialMessage: String
    )
    /**
     * Negentropy Message
     */
    case negMsg(subscriptionId: String, message: String
    )
    /**
     * Negentropy Close
     */
    case negClose(subscriptionId: String
    )
}


public struct FfiConverterTypeClientMessageEnum: FfiConverterRustBuffer {
    typealias SwiftType = ClientMessageEnum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientMessageEnum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventMsg(event: try FfiConverterTypeEvent.read(from: &buf)
        )
        
        case 2: return .req(subscriptionId: try FfiConverterString.read(from: &buf), filters: try FfiConverterSequenceTypeFilter.read(from: &buf)
        )
        
        case 3: return .count(subscriptionId: try FfiConverterString.read(from: &buf), filters: try FfiConverterSequenceTypeFilter.read(from: &buf)
        )
        
        case 4: return .close(subscriptionId: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .auth(event: try FfiConverterTypeEvent.read(from: &buf)
        )
        
        case 6: return .negOpen(subscriptionId: try FfiConverterString.read(from: &buf), filter: try FfiConverterTypeFilter.read(from: &buf), idSize: try FfiConverterUInt8.read(from: &buf), initialMessage: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .negMsg(subscriptionId: try FfiConverterString.read(from: &buf), message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .negClose(subscriptionId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientMessageEnum, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .eventMsg(event):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEvent.write(event, into: &buf)
            
        
        case let .req(subscriptionId,filters):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterSequenceTypeFilter.write(filters, into: &buf)
            
        
        case let .count(subscriptionId,filters):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterSequenceTypeFilter.write(filters, into: &buf)
            
        
        case let .close(subscriptionId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(subscriptionId, into: &buf)
            
        
        case let .auth(event):
            writeInt(&buf, Int32(5))
            FfiConverterTypeEvent.write(event, into: &buf)
            
        
        case let .negOpen(subscriptionId,filter,idSize,initialMessage):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterTypeFilter.write(filter, into: &buf)
            FfiConverterUInt8.write(idSize, into: &buf)
            FfiConverterString.write(initialMessage, into: &buf)
            
        
        case let .negMsg(subscriptionId,message):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .negClose(subscriptionId):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(subscriptionId, into: &buf)
            
        }
    }
}


public func FfiConverterTypeClientMessageEnum_lift(_ buf: RustBuffer) throws -> ClientMessageEnum {
    return try FfiConverterTypeClientMessageEnum.lift(buf)
}

public func FfiConverterTypeClientMessageEnum_lower(_ value: ClientMessageEnum) -> RustBuffer {
    return FfiConverterTypeClientMessageEnum.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DataVendingMachineStatus {
    
    case paymentRequired
    case processing
    case error
    case success
    case partial
}


public struct FfiConverterTypeDataVendingMachineStatus: FfiConverterRustBuffer {
    typealias SwiftType = DataVendingMachineStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DataVendingMachineStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .paymentRequired
        
        case 2: return .processing
        
        case 3: return .error
        
        case 4: return .success
        
        case 5: return .partial
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DataVendingMachineStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .paymentRequired:
            writeInt(&buf, Int32(1))
        
        
        case .processing:
            writeInt(&buf, Int32(2))
        
        
        case .error:
            writeInt(&buf, Int32(3))
        
        
        case .success:
            writeInt(&buf, Int32(4))
        
        
        case .partial:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeDataVendingMachineStatus_lift(_ buf: RustBuffer) throws -> DataVendingMachineStatus {
    return try FfiConverterTypeDataVendingMachineStatus.lift(buf)
}

public func FfiConverterTypeDataVendingMachineStatus_lower(_ value: DataVendingMachineStatus) -> RustBuffer {
    return FfiConverterTypeDataVendingMachineStatus.lower(value)
}



extension DataVendingMachineStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Encrypted Secret Key version (NIP49)
 */

public enum EncryptedSecretKeyVersion {
    
    case v2
}


public struct FfiConverterTypeEncryptedSecretKeyVersion: FfiConverterRustBuffer {
    typealias SwiftType = EncryptedSecretKeyVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedSecretKeyVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .v2
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EncryptedSecretKeyVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .v2:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypeEncryptedSecretKeyVersion_lift(_ buf: RustBuffer) throws -> EncryptedSecretKeyVersion {
    return try FfiConverterTypeEncryptedSecretKeyVersion.lift(buf)
}

public func FfiConverterTypeEncryptedSecretKeyVersion_lower(_ value: EncryptedSecretKeyVersion) -> RustBuffer {
    return FfiConverterTypeEncryptedSecretKeyVersion.lower(value)
}



extension EncryptedSecretKeyVersion: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * NIP47 Response Error codes
 */

public enum ErrorCode {
    
    /**
     * The client is sending commands too fast.
     */
    case rateLimited
    /**
     * The command is not known of is intentionally not implemented
     */
    case notImplemented
    /**
     * The wallet does not have enough funds to cover a fee reserve or the payment amount
     */
    case insufficientBalance
    /**
     * The payment failed. This may be due to a timeout, exhausting all routes, insufficient capacity or similar.
     */
    case paymentFailed
    /**
     * The invoice could not be found by the given parameters.
     */
    case notFound
    /**
     * The wallet has exceeded its spending quota
     */
    case quotaExceeded
    /**
     * This public key is not allowed to do this operation
     */
    case restricted
    /**
     * This public key has no wallet connected
     */
    case unauthorized
    /**
     * An internal error
     */
    case `internal`
    /**
     * Other error
     */
    case other
}


public struct FfiConverterTypeErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = ErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .rateLimited
        
        case 2: return .notImplemented
        
        case 3: return .insufficientBalance
        
        case 4: return .paymentFailed
        
        case 5: return .notFound
        
        case 6: return .quotaExceeded
        
        case 7: return .restricted
        
        case 8: return .unauthorized
        
        case 9: return .`internal`
        
        case 10: return .other
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ErrorCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .rateLimited:
            writeInt(&buf, Int32(1))
        
        
        case .notImplemented:
            writeInt(&buf, Int32(2))
        
        
        case .insufficientBalance:
            writeInt(&buf, Int32(3))
        
        
        case .paymentFailed:
            writeInt(&buf, Int32(4))
        
        
        case .notFound:
            writeInt(&buf, Int32(5))
        
        
        case .quotaExceeded:
            writeInt(&buf, Int32(6))
        
        
        case .restricted:
            writeInt(&buf, Int32(7))
        
        
        case .unauthorized:
            writeInt(&buf, Int32(8))
        
        
        case .`internal`:
            writeInt(&buf, Int32(9))
        
        
        case .other:
            writeInt(&buf, Int32(10))
        
        }
    }
}


public func FfiConverterTypeErrorCode_lift(_ buf: RustBuffer) throws -> ErrorCode {
    return try FfiConverterTypeErrorCode.lift(buf)
}

public func FfiConverterTypeErrorCode_lower(_ value: ErrorCode) -> RustBuffer {
    return FfiConverterTypeErrorCode.lower(value)
}



extension ErrorCode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Supported external identity providers
 *
 * <https://github.com/nostr-protocol/nips/blob/master/39.md>
 */

public enum ExternalIdentity {
    
    /**
     * github.com
     */
    case gitHub
    /**
     * twitter.com
     */
    case twitter
    /**
     * mastodon.social
     */
    case mastodon
    /**
     * telegram.org
     */
    case telegram
}


public struct FfiConverterTypeExternalIdentity: FfiConverterRustBuffer {
    typealias SwiftType = ExternalIdentity

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalIdentity {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .gitHub
        
        case 2: return .twitter
        
        case 3: return .mastodon
        
        case 4: return .telegram
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ExternalIdentity, into buf: inout [UInt8]) {
        switch value {
        
        
        case .gitHub:
            writeInt(&buf, Int32(1))
        
        
        case .twitter:
            writeInt(&buf, Int32(2))
        
        
        case .mastodon:
            writeInt(&buf, Int32(3))
        
        
        case .telegram:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeExternalIdentity_lift(_ buf: RustBuffer) throws -> ExternalIdentity {
    return try FfiConverterTypeExternalIdentity.lift(buf)
}

public func FfiConverterTypeExternalIdentity_lower(_ value: ExternalIdentity) -> RustBuffer {
    return FfiConverterTypeExternalIdentity.lower(value)
}



extension ExternalIdentity: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum HttpMethod {
    
    case get
    case post
    case put
    case patch
}


public struct FfiConverterTypeHttpMethod: FfiConverterRustBuffer {
    typealias SwiftType = HttpMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .get
        
        case 2: return .post
        
        case 3: return .put
        
        case 4: return .patch
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HttpMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .get:
            writeInt(&buf, Int32(1))
        
        
        case .post:
            writeInt(&buf, Int32(2))
        
        
        case .put:
            writeInt(&buf, Int32(3))
        
        
        case .patch:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeHttpMethod_lift(_ buf: RustBuffer) throws -> HttpMethod {
    return try FfiConverterTypeHttpMethod.lift(buf)
}

public func FfiConverterTypeHttpMethod_lower(_ value: HttpMethod) -> RustBuffer {
    return FfiConverterTypeHttpMethod.lower(value)
}



extension HttpMethod: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum JsonValue {
    
    case bool(bool: Bool
    )
    case numberPosInt(number: UInt64
    )
    case numberNegInt(number: Int64
    )
    case numberFloat(number: Double
    )
    case str(s: String
    )
    case array(array: [JsonValue]
    )
    case object(map: [String: JsonValue]
    )
    case null
}


public struct FfiConverterTypeJsonValue: FfiConverterRustBuffer {
    typealias SwiftType = JsonValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsonValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bool(bool: try FfiConverterBool.read(from: &buf)
        )
        
        case 2: return .numberPosInt(number: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 3: return .numberNegInt(number: try FfiConverterInt64.read(from: &buf)
        )
        
        case 4: return .numberFloat(number: try FfiConverterDouble.read(from: &buf)
        )
        
        case 5: return .str(s: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .array(array: try FfiConverterSequenceTypeJsonValue.read(from: &buf)
        )
        
        case 7: return .object(map: try FfiConverterDictionaryStringTypeJsonValue.read(from: &buf)
        )
        
        case 8: return .null
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JsonValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bool(bool):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(bool, into: &buf)
            
        
        case let .numberPosInt(number):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(number, into: &buf)
            
        
        case let .numberNegInt(number):
            writeInt(&buf, Int32(3))
            FfiConverterInt64.write(number, into: &buf)
            
        
        case let .numberFloat(number):
            writeInt(&buf, Int32(4))
            FfiConverterDouble.write(number, into: &buf)
            
        
        case let .str(s):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(s, into: &buf)
            
        
        case let .array(array):
            writeInt(&buf, Int32(6))
            FfiConverterSequenceTypeJsonValue.write(array, into: &buf)
            
        
        case let .object(map):
            writeInt(&buf, Int32(7))
            FfiConverterDictionaryStringTypeJsonValue.write(map, into: &buf)
            
        
        case .null:
            writeInt(&buf, Int32(8))
        
        }
    }
}


public func FfiConverterTypeJsonValue_lift(_ buf: RustBuffer) throws -> JsonValue {
    return try FfiConverterTypeJsonValue.lift(buf)
}

public func FfiConverterTypeJsonValue_lower(_ value: JsonValue) -> RustBuffer {
    return FfiConverterTypeJsonValue.lower(value)
}



extension JsonValue: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Key security
 */

public enum KeySecurity {
    
    /**
     * The key has been known to have been handled insecurely (stored unencrypted, cut and paste unencrypted, etc)
     */
    case weak
    /**
     * The key has NOT been known to have been handled insecurely (stored encrypted, cut and paste encrypted, etc)
     */
    case medium
    /**
     * The client does not track this data
     */
    case unknown
}


public struct FfiConverterTypeKeySecurity: FfiConverterRustBuffer {
    typealias SwiftType = KeySecurity

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeySecurity {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .weak
        
        case 2: return .medium
        
        case 3: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeySecurity, into buf: inout [UInt8]) {
        switch value {
        
        
        case .weak:
            writeInt(&buf, Int32(1))
        
        
        case .medium:
            writeInt(&buf, Int32(2))
        
        
        case .unknown:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeKeySecurity_lift(_ buf: RustBuffer) throws -> KeySecurity {
    return try FfiConverterTypeKeySecurity.lift(buf)
}

public func FfiConverterTypeKeySecurity_lower(_ value: KeySecurity) -> RustBuffer {
    return FfiConverterTypeKeySecurity.lower(value)
}



extension KeySecurity: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum KindEnum {
    
    /**
     * Metadata (NIP01 and NIP05)
     */
    case metadata
    /**
     * Short Text Note (NIP01)
     */
    case textNote
    /**
     * Recommend Relay (NIP01 - deprecated)
     */
    case recommendRelay
    /**
     * Contacts (NIP02)
     */
    case contactList
    /**
     * OpenTimestamps Attestations (NIP03)
     */
    case openTimestamps
    /**
     * Encrypted Direct Messages (NIP04)
     */
    case encryptedDirectMessage
    /**
     * Event Deletion (NIP09)
     */
    case eventDeletion
    /**
     * Repost (NIP18)
     */
    case repost
    /**
     * Generic Repost (NIP18)
     */
    case genericRepost
    /**
     * Reaction (NIP25)
     */
    case reaction
    /**
     * Badge Award (NIP58)
     */
    case badgeAward
    /**
     * Channel Creation (NIP28)
     */
    case channelCreation
    /**
     * Channel Metadata (NIP28)
     */
    case channelMetadata
    /**
     * Channel Message (NIP28)
     */
    case channelMessage
    /**
     * Channel Hide Message (NIP28)
     */
    case channelHideMessage
    /**
     * Channel Mute User (NIP28)
     */
    case channelMuteUser
    /**
     * Public Chat Reserved (NIP28)
     */
    case publicChatReserved45
    /**
     * Public Chat Reserved (NIP28)
     */
    case publicChatReserved46
    /**
     * Public Chat Reserved (NIP28)
     */
    case publicChatReserved47
    /**
     * Public Chat Reserved (NIP28)
     */
    case publicChatReserved48
    /**
     * Public Chat Reserved (NIP28)
     */
    case publicChatReserved49
    /**
     * Label
     *
     * <https://github.com/nostr-protocol/nips/blob/master/32.md>
     */
    case label
    /**
     * Wallet Service Info (NIP47)
     */
    case walletConnectInfo
    /**
     * Reporting (NIP56)
     */
    case reporting
    /**
     * Zap Private Message (NIP57)
     */
    case zapPrivateMessage
    /**
     * Zap Request (NIP57)
     */
    case zapRequest
    /**
     * Zap Receipt (NIP57)
     */
    case zapReceipt
    /**
     * Mute List
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case muteList
    /**
     * Pin List
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case pinList
    /**
     * Bookmarks
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case bookmarks
    /**
     * Communities
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case communities
    /**
     * Public Chats
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case publicChats
    /**
     * Blocked Relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case blockedRelays
    /**
     * Search Relays
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case searchRelays
    /**
     * Simple Groups
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case simpleGroups
    /**
     * Interests
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case interests
    /**
     * Emojis
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case emojis
    /**
     * Follow Sets
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case followSets
    /**
     * Relay Sets
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case relaySets
    /**
     * Bookmark Sets
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case bookmarkSets
    /**
     * Articles Curation Sets
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case articlesCurationSets
    /**
     * Videos Curation Sets
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case videosCurationSets
    /**
     * Interest Sets
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case interestSets
    /**
     * Emoji Sets
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case emojiSets
    /**
     * Release Artifact Sets
     *
     * <https://github.com/nostr-protocol/nips/blob/master/51.md>
     */
    case releaseArtifactSets
    /**
     * Relay List Metadata (NIP65)
     */
    case relayList
    /**
     * Client Authentication (NIP42)
     */
    case authentication
    /**
     * Wallet Connect Request (NIP47)
     */
    case walletConnectRequest
    /**
     * Wallet Connect Response (NIP47)
     */
    case walletConnectResponse
    /**
     * Nostr Connect (NIP46)
     */
    case nostrConnect
    /**
     * Live Event (NIP53)
     */
    case liveEvent
    /**
     * Live Event Message (NIP53)
     */
    case liveEventMessage
    /**
     * Profile Badges (NIP58)
     */
    case profileBadges
    /**
     * Badge Definition (NIP58)
     */
    case badgeDefinition
    /**
     * Seal (NIP59)
     */
    case seal
    /**
     * Gift Wrap (NIP59)
     */
    case giftWrap
    /**
     * Private Direct message
     *
     * <https://github.com/nostr-protocol/nips/blob/master/17.md>
     */
    case privateDirectMessage
    /**
     * Long-form Text Note (NIP23)
     */
    case longFormTextNote
    /**
     * Application-specific Data (NIP78)
     */
    case applicationSpecificData
    /**
     * File Metadata (NIP94)
     */
    case fileMetadata
    /**
     * HTTP Auth (NIP98)
     */
    case httpAuth
    /**
     * Set stall (NIP15)
     */
    case setStall
    /**
     * Set product (NIP15)
     */
    case setProduct
    /**
     * Job Feedback (NIP90)
     */
    case jobFeedback
    case jobRequest(kind: UInt16
    )
    case jobResult(kind: UInt16
    )
    case regular(kind: UInt16
    )
    case replaceable(kind: UInt16
    )
    case ephemeral(kind: UInt16
    )
    case parameterizedReplaceable(kind: UInt16
    )
    case custom(kind: UInt16
    )
}


public struct FfiConverterTypeKindEnum: FfiConverterRustBuffer {
    typealias SwiftType = KindEnum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KindEnum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .metadata
        
        case 2: return .textNote
        
        case 3: return .recommendRelay
        
        case 4: return .contactList
        
        case 5: return .openTimestamps
        
        case 6: return .encryptedDirectMessage
        
        case 7: return .eventDeletion
        
        case 8: return .repost
        
        case 9: return .genericRepost
        
        case 10: return .reaction
        
        case 11: return .badgeAward
        
        case 12: return .channelCreation
        
        case 13: return .channelMetadata
        
        case 14: return .channelMessage
        
        case 15: return .channelHideMessage
        
        case 16: return .channelMuteUser
        
        case 17: return .publicChatReserved45
        
        case 18: return .publicChatReserved46
        
        case 19: return .publicChatReserved47
        
        case 20: return .publicChatReserved48
        
        case 21: return .publicChatReserved49
        
        case 22: return .label
        
        case 23: return .walletConnectInfo
        
        case 24: return .reporting
        
        case 25: return .zapPrivateMessage
        
        case 26: return .zapRequest
        
        case 27: return .zapReceipt
        
        case 28: return .muteList
        
        case 29: return .pinList
        
        case 30: return .bookmarks
        
        case 31: return .communities
        
        case 32: return .publicChats
        
        case 33: return .blockedRelays
        
        case 34: return .searchRelays
        
        case 35: return .simpleGroups
        
        case 36: return .interests
        
        case 37: return .emojis
        
        case 38: return .followSets
        
        case 39: return .relaySets
        
        case 40: return .bookmarkSets
        
        case 41: return .articlesCurationSets
        
        case 42: return .videosCurationSets
        
        case 43: return .interestSets
        
        case 44: return .emojiSets
        
        case 45: return .releaseArtifactSets
        
        case 46: return .relayList
        
        case 47: return .authentication
        
        case 48: return .walletConnectRequest
        
        case 49: return .walletConnectResponse
        
        case 50: return .nostrConnect
        
        case 51: return .liveEvent
        
        case 52: return .liveEventMessage
        
        case 53: return .profileBadges
        
        case 54: return .badgeDefinition
        
        case 55: return .seal
        
        case 56: return .giftWrap
        
        case 57: return .privateDirectMessage
        
        case 58: return .longFormTextNote
        
        case 59: return .applicationSpecificData
        
        case 60: return .fileMetadata
        
        case 61: return .httpAuth
        
        case 62: return .setStall
        
        case 63: return .setProduct
        
        case 64: return .jobFeedback
        
        case 65: return .jobRequest(kind: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 66: return .jobResult(kind: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 67: return .regular(kind: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 68: return .replaceable(kind: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 69: return .ephemeral(kind: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 70: return .parameterizedReplaceable(kind: try FfiConverterUInt16.read(from: &buf)
        )
        
        case 71: return .custom(kind: try FfiConverterUInt16.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KindEnum, into buf: inout [UInt8]) {
        switch value {
        
        
        case .metadata:
            writeInt(&buf, Int32(1))
        
        
        case .textNote:
            writeInt(&buf, Int32(2))
        
        
        case .recommendRelay:
            writeInt(&buf, Int32(3))
        
        
        case .contactList:
            writeInt(&buf, Int32(4))
        
        
        case .openTimestamps:
            writeInt(&buf, Int32(5))
        
        
        case .encryptedDirectMessage:
            writeInt(&buf, Int32(6))
        
        
        case .eventDeletion:
            writeInt(&buf, Int32(7))
        
        
        case .repost:
            writeInt(&buf, Int32(8))
        
        
        case .genericRepost:
            writeInt(&buf, Int32(9))
        
        
        case .reaction:
            writeInt(&buf, Int32(10))
        
        
        case .badgeAward:
            writeInt(&buf, Int32(11))
        
        
        case .channelCreation:
            writeInt(&buf, Int32(12))
        
        
        case .channelMetadata:
            writeInt(&buf, Int32(13))
        
        
        case .channelMessage:
            writeInt(&buf, Int32(14))
        
        
        case .channelHideMessage:
            writeInt(&buf, Int32(15))
        
        
        case .channelMuteUser:
            writeInt(&buf, Int32(16))
        
        
        case .publicChatReserved45:
            writeInt(&buf, Int32(17))
        
        
        case .publicChatReserved46:
            writeInt(&buf, Int32(18))
        
        
        case .publicChatReserved47:
            writeInt(&buf, Int32(19))
        
        
        case .publicChatReserved48:
            writeInt(&buf, Int32(20))
        
        
        case .publicChatReserved49:
            writeInt(&buf, Int32(21))
        
        
        case .label:
            writeInt(&buf, Int32(22))
        
        
        case .walletConnectInfo:
            writeInt(&buf, Int32(23))
        
        
        case .reporting:
            writeInt(&buf, Int32(24))
        
        
        case .zapPrivateMessage:
            writeInt(&buf, Int32(25))
        
        
        case .zapRequest:
            writeInt(&buf, Int32(26))
        
        
        case .zapReceipt:
            writeInt(&buf, Int32(27))
        
        
        case .muteList:
            writeInt(&buf, Int32(28))
        
        
        case .pinList:
            writeInt(&buf, Int32(29))
        
        
        case .bookmarks:
            writeInt(&buf, Int32(30))
        
        
        case .communities:
            writeInt(&buf, Int32(31))
        
        
        case .publicChats:
            writeInt(&buf, Int32(32))
        
        
        case .blockedRelays:
            writeInt(&buf, Int32(33))
        
        
        case .searchRelays:
            writeInt(&buf, Int32(34))
        
        
        case .simpleGroups:
            writeInt(&buf, Int32(35))
        
        
        case .interests:
            writeInt(&buf, Int32(36))
        
        
        case .emojis:
            writeInt(&buf, Int32(37))
        
        
        case .followSets:
            writeInt(&buf, Int32(38))
        
        
        case .relaySets:
            writeInt(&buf, Int32(39))
        
        
        case .bookmarkSets:
            writeInt(&buf, Int32(40))
        
        
        case .articlesCurationSets:
            writeInt(&buf, Int32(41))
        
        
        case .videosCurationSets:
            writeInt(&buf, Int32(42))
        
        
        case .interestSets:
            writeInt(&buf, Int32(43))
        
        
        case .emojiSets:
            writeInt(&buf, Int32(44))
        
        
        case .releaseArtifactSets:
            writeInt(&buf, Int32(45))
        
        
        case .relayList:
            writeInt(&buf, Int32(46))
        
        
        case .authentication:
            writeInt(&buf, Int32(47))
        
        
        case .walletConnectRequest:
            writeInt(&buf, Int32(48))
        
        
        case .walletConnectResponse:
            writeInt(&buf, Int32(49))
        
        
        case .nostrConnect:
            writeInt(&buf, Int32(50))
        
        
        case .liveEvent:
            writeInt(&buf, Int32(51))
        
        
        case .liveEventMessage:
            writeInt(&buf, Int32(52))
        
        
        case .profileBadges:
            writeInt(&buf, Int32(53))
        
        
        case .badgeDefinition:
            writeInt(&buf, Int32(54))
        
        
        case .seal:
            writeInt(&buf, Int32(55))
        
        
        case .giftWrap:
            writeInt(&buf, Int32(56))
        
        
        case .privateDirectMessage:
            writeInt(&buf, Int32(57))
        
        
        case .longFormTextNote:
            writeInt(&buf, Int32(58))
        
        
        case .applicationSpecificData:
            writeInt(&buf, Int32(59))
        
        
        case .fileMetadata:
            writeInt(&buf, Int32(60))
        
        
        case .httpAuth:
            writeInt(&buf, Int32(61))
        
        
        case .setStall:
            writeInt(&buf, Int32(62))
        
        
        case .setProduct:
            writeInt(&buf, Int32(63))
        
        
        case .jobFeedback:
            writeInt(&buf, Int32(64))
        
        
        case let .jobRequest(kind):
            writeInt(&buf, Int32(65))
            FfiConverterUInt16.write(kind, into: &buf)
            
        
        case let .jobResult(kind):
            writeInt(&buf, Int32(66))
            FfiConverterUInt16.write(kind, into: &buf)
            
        
        case let .regular(kind):
            writeInt(&buf, Int32(67))
            FfiConverterUInt16.write(kind, into: &buf)
            
        
        case let .replaceable(kind):
            writeInt(&buf, Int32(68))
            FfiConverterUInt16.write(kind, into: &buf)
            
        
        case let .ephemeral(kind):
            writeInt(&buf, Int32(69))
            FfiConverterUInt16.write(kind, into: &buf)
            
        
        case let .parameterizedReplaceable(kind):
            writeInt(&buf, Int32(70))
            FfiConverterUInt16.write(kind, into: &buf)
            
        
        case let .custom(kind):
            writeInt(&buf, Int32(71))
            FfiConverterUInt16.write(kind, into: &buf)
            
        }
    }
}


public func FfiConverterTypeKindEnum_lift(_ buf: RustBuffer) throws -> KindEnum {
    return try FfiConverterTypeKindEnum.lift(buf)
}

public func FfiConverterTypeKindEnum_lower(_ value: KindEnum) -> RustBuffer {
    return FfiConverterTypeKindEnum.lower(value)
}



extension KindEnum: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Live Event Marker
 */

public enum LiveEventMarker {
    
    /**
     * Host
     */
    case host
    /**
     * Speaker
     */
    case speaker
    /**
     * Participant
     */
    case participant
}


public struct FfiConverterTypeLiveEventMarker: FfiConverterRustBuffer {
    typealias SwiftType = LiveEventMarker

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveEventMarker {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .host
        
        case 2: return .speaker
        
        case 3: return .participant
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LiveEventMarker, into buf: inout [UInt8]) {
        switch value {
        
        
        case .host:
            writeInt(&buf, Int32(1))
        
        
        case .speaker:
            writeInt(&buf, Int32(2))
        
        
        case .participant:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeLiveEventMarker_lift(_ buf: RustBuffer) throws -> LiveEventMarker {
    return try FfiConverterTypeLiveEventMarker.lift(buf)
}

public func FfiConverterTypeLiveEventMarker_lower(_ value: LiveEventMarker) -> RustBuffer {
    return FfiConverterTypeLiveEventMarker.lower(value)
}



extension LiveEventMarker: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LiveEventStatus {
    
    case planned
    case live
    case ended
    case custom(custom: String
    )
}


public struct FfiConverterTypeLiveEventStatus: FfiConverterRustBuffer {
    typealias SwiftType = LiveEventStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveEventStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .planned
        
        case 2: return .live
        
        case 3: return .ended
        
        case 4: return .custom(custom: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LiveEventStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .planned:
            writeInt(&buf, Int32(1))
        
        
        case .live:
            writeInt(&buf, Int32(2))
        
        
        case .ended:
            writeInt(&buf, Int32(3))
        
        
        case let .custom(custom):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(custom, into: &buf)
            
        }
    }
}


public func FfiConverterTypeLiveEventStatus_lift(_ buf: RustBuffer) throws -> LiveEventStatus {
    return try FfiConverterTypeLiveEventStatus.lift(buf)
}

public func FfiConverterTypeLiveEventStatus_lower(_ value: LiveEventStatus) -> RustBuffer {
    return FfiConverterTypeLiveEventStatus.lower(value)
}



extension LiveEventStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Marker
 */

public enum Marker {
    
    /**
     * Root
     */
    case root
    /**
     * Reply
     */
    case reply
    /**
     * Mention
     */
    case mention
    /**
     * Custom
     */
    case custom(custom: String
    )
}


public struct FfiConverterTypeMarker: FfiConverterRustBuffer {
    typealias SwiftType = Marker

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Marker {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .root
        
        case 2: return .reply
        
        case 3: return .mention
        
        case 4: return .custom(custom: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Marker, into buf: inout [UInt8]) {
        switch value {
        
        
        case .root:
            writeInt(&buf, Int32(1))
        
        
        case .reply:
            writeInt(&buf, Int32(2))
        
        
        case .mention:
            writeInt(&buf, Int32(3))
        
        
        case let .custom(custom):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(custom, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMarker_lift(_ buf: RustBuffer) throws -> Marker {
    return try FfiConverterTypeMarker.lift(buf)
}

public func FfiConverterTypeMarker_lower(_ value: Marker) -> RustBuffer {
    return FfiConverterTypeMarker.lower(value)
}



extension Marker: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Method
 */

public enum Method {
    
    /**
     * Pay Invoice
     */
    case payInvoice
    /**
     * Multi Pay Invoice
     */
    case multiPayInvoice
    /**
     * Pay Keysend
     */
    case payKeysend
    /**
     * Multi Pay Keysend
     */
    case multiPayKeysend
    /**
     * Make Invoice
     */
    case makeInvoice
    /**
     * Lookup Invoice
     */
    case lookupInvoice
    /**
     * List transactions
     */
    case listTransactions
    /**
     * Get Balance
     */
    case getBalance
    /**
     * Get Info
     */
    case getInfo
}


public struct FfiConverterTypeMethod: FfiConverterRustBuffer {
    typealias SwiftType = Method

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Method {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .payInvoice
        
        case 2: return .multiPayInvoice
        
        case 3: return .payKeysend
        
        case 4: return .multiPayKeysend
        
        case 5: return .makeInvoice
        
        case 6: return .lookupInvoice
        
        case 7: return .listTransactions
        
        case 8: return .getBalance
        
        case 9: return .getInfo
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Method, into buf: inout [UInt8]) {
        switch value {
        
        
        case .payInvoice:
            writeInt(&buf, Int32(1))
        
        
        case .multiPayInvoice:
            writeInt(&buf, Int32(2))
        
        
        case .payKeysend:
            writeInt(&buf, Int32(3))
        
        
        case .multiPayKeysend:
            writeInt(&buf, Int32(4))
        
        
        case .makeInvoice:
            writeInt(&buf, Int32(5))
        
        
        case .lookupInvoice:
            writeInt(&buf, Int32(6))
        
        
        case .listTransactions:
            writeInt(&buf, Int32(7))
        
        
        case .getBalance:
            writeInt(&buf, Int32(8))
        
        
        case .getInfo:
            writeInt(&buf, Int32(9))
        
        }
    }
}


public func FfiConverterTypeMethod_lift(_ buf: RustBuffer) throws -> Method {
    return try FfiConverterTypeMethod.lift(buf)
}

public func FfiConverterTypeMethod_lower(_ value: Method) -> RustBuffer {
    return FfiConverterTypeMethod.lower(value)
}



extension Method: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A representation any `fNIP19` bech32 nostr object. Useful for decoding
 * `NIP19` bech32 strings without necessarily knowing what you're decoding
 * ahead of time.
 */

public enum Nip19Enum {
    
    /**
     * nsec
     */
    case secret(nsec: SecretKey
    )
    /**
     * Encrypted Secret Key
     */
    case encryptedSecret(ncryptsec: EncryptedSecretKey
    )
    /**
     * npub
     */
    case pubkey(npub: PublicKey
    )
    /**
     * nprofile
     */
    case profile(nprofile: Nip19Profile
    )
    /**
     * note
     */
    case note(eventId: EventId
    )
    /**
     * nevent
     */
    case event(event: Nip19Event
    )
    /**
     * naddr
     */
    case coord(coordinate: Coordinate
    )
}


public struct FfiConverterTypeNip19Enum: FfiConverterRustBuffer {
    typealias SwiftType = Nip19Enum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip19Enum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .secret(nsec: try FfiConverterTypeSecretKey.read(from: &buf)
        )
        
        case 2: return .encryptedSecret(ncryptsec: try FfiConverterTypeEncryptedSecretKey.read(from: &buf)
        )
        
        case 3: return .pubkey(npub: try FfiConverterTypePublicKey.read(from: &buf)
        )
        
        case 4: return .profile(nprofile: try FfiConverterTypeNip19Profile.read(from: &buf)
        )
        
        case 5: return .note(eventId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 6: return .event(event: try FfiConverterTypeNip19Event.read(from: &buf)
        )
        
        case 7: return .coord(coordinate: try FfiConverterTypeCoordinate.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Nip19Enum, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .secret(nsec):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecretKey.write(nsec, into: &buf)
            
        
        case let .encryptedSecret(ncryptsec):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEncryptedSecretKey.write(ncryptsec, into: &buf)
            
        
        case let .pubkey(npub):
            writeInt(&buf, Int32(3))
            FfiConverterTypePublicKey.write(npub, into: &buf)
            
        
        case let .profile(nprofile):
            writeInt(&buf, Int32(4))
            FfiConverterTypeNip19Profile.write(nprofile, into: &buf)
            
        
        case let .note(eventId):
            writeInt(&buf, Int32(5))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            
        
        case let .event(event):
            writeInt(&buf, Int32(6))
            FfiConverterTypeNip19Event.write(event, into: &buf)
            
        
        case let .coord(coordinate):
            writeInt(&buf, Int32(7))
            FfiConverterTypeCoordinate.write(coordinate, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNip19Enum_lift(_ buf: RustBuffer) throws -> Nip19Enum {
    return try FfiConverterTypeNip19Enum.lift(buf)
}

public func FfiConverterTypeNip19Enum_lower(_ value: Nip19Enum) -> RustBuffer {
    return FfiConverterTypeNip19Enum.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A representation any `NIP21` object. Useful for decoding
 * `NIP21` strings without necessarily knowing what you're decoding
 * ahead of time.
 */

public enum Nip21Enum {
    
    /**
     * nostr::npub
     */
    case pubkey(publicKey: PublicKey
    )
    /**
     * nostr::nprofile
     */
    case profile(profile: Nip19Profile
    )
    /**
     * nostr::note (EventId)
     */
    case note(eventId: EventId
    )
    /**
     * nostr::nevent
     */
    case event(event: Nip19Event
    )
    /**
     * nostr::naddr
     */
    case coord(coordinate: Coordinate
    )
}


public struct FfiConverterTypeNip21Enum: FfiConverterRustBuffer {
    typealias SwiftType = Nip21Enum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip21Enum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pubkey(publicKey: try FfiConverterTypePublicKey.read(from: &buf)
        )
        
        case 2: return .profile(profile: try FfiConverterTypeNip19Profile.read(from: &buf)
        )
        
        case 3: return .note(eventId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 4: return .event(event: try FfiConverterTypeNip19Event.read(from: &buf)
        )
        
        case 5: return .coord(coordinate: try FfiConverterTypeCoordinate.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Nip21Enum, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .pubkey(publicKey):
            writeInt(&buf, Int32(1))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            
        
        case let .profile(profile):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNip19Profile.write(profile, into: &buf)
            
        
        case let .note(eventId):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            
        
        case let .event(event):
            writeInt(&buf, Int32(4))
            FfiConverterTypeNip19Event.write(event, into: &buf)
            
        
        case let .coord(coordinate):
            writeInt(&buf, Int32(5))
            FfiConverterTypeCoordinate.write(coordinate, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNip21Enum_lift(_ buf: RustBuffer) throws -> Nip21Enum {
    return try FfiConverterTypeNip21Enum.lift(buf)
}

public func FfiConverterTypeNip21Enum_lower(_ value: Nip21Enum) -> RustBuffer {
    return FfiConverterTypeNip21Enum.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * NIP44 Version
 */

public enum Nip44Version {
    
    /**
     * V1 (deprecated)
     */
    case deprecated
    /**
     * V2 - Secp256k1 ECDH, HKDF, padding, ChaCha20, HMAC-SHA256 and base64
     */
    case v2
}


public struct FfiConverterTypeNip44Version: FfiConverterRustBuffer {
    typealias SwiftType = Nip44Version

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip44Version {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .deprecated
        
        case 2: return .v2
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Nip44Version, into buf: inout [UInt8]) {
        switch value {
        
        
        case .deprecated:
            writeInt(&buf, Int32(1))
        
        
        case .v2:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeNip44Version_lift(_ buf: RustBuffer) throws -> Nip44Version {
    return try FfiConverterTypeNip44Version.lift(buf)
}

public func FfiConverterTypeNip44Version_lower(_ value: Nip44Version) -> RustBuffer {
    return FfiConverterTypeNip44Version.lower(value)
}



extension Nip44Version: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Request (NIP-46)
 */

public enum Nip46Request {
    
    /**
     * Connect
     */
    case connect(
        /**
         * Remote public key
         */publicKey: PublicKey, 
        /**
         * Optional secret
         */secret: String?
    )
    /**
     * Get public key
     */
    case getPublicKey
    /**
     * Sign [`UnsignedEvent`]
     */
    case signEvent(unsigned: UnsignedEvent
    )
    /**
     * Get relays
     */
    case getRelays
    /**
     * Encrypt text (NIP04)
     */
    case nip04Encrypt(
        /**
         * Pubkey
         */publicKey: PublicKey, 
        /**
         * Plain text
         */text: String
    )
    /**
     * Decrypt (NIP04)
     */
    case nip04Decrypt(
        /**
         * Pubkey
         */publicKey: PublicKey, 
        /**
         * Ciphertext
         */ciphertext: String
    )
    /**
     * Encrypt text (NIP44)
     */
    case nip44Encrypt(
        /**
         * Pubkey
         */publicKey: PublicKey, 
        /**
         * Plain text
         */text: String
    )
    /**
     * Decrypt (NIP44)
     */
    case nip44Decrypt(
        /**
         * Pubkey
         */publicKey: PublicKey, 
        /**
         * Ciphertext
         */ciphertext: String
    )
    /**
     * Ping
     */
    case ping
}


public struct FfiConverterTypeNip46Request: FfiConverterRustBuffer {
    typealias SwiftType = Nip46Request

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip46Request {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .connect(publicKey: try FfiConverterTypePublicKey.read(from: &buf), secret: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 2: return .getPublicKey
        
        case 3: return .signEvent(unsigned: try FfiConverterTypeUnsignedEvent.read(from: &buf)
        )
        
        case 4: return .getRelays
        
        case 5: return .nip04Encrypt(publicKey: try FfiConverterTypePublicKey.read(from: &buf), text: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .nip04Decrypt(publicKey: try FfiConverterTypePublicKey.read(from: &buf), ciphertext: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .nip44Encrypt(publicKey: try FfiConverterTypePublicKey.read(from: &buf), text: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .nip44Decrypt(publicKey: try FfiConverterTypePublicKey.read(from: &buf), ciphertext: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .ping
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Nip46Request, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .connect(publicKey,secret):
            writeInt(&buf, Int32(1))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterOptionString.write(secret, into: &buf)
            
        
        case .getPublicKey:
            writeInt(&buf, Int32(2))
        
        
        case let .signEvent(unsigned):
            writeInt(&buf, Int32(3))
            FfiConverterTypeUnsignedEvent.write(unsigned, into: &buf)
            
        
        case .getRelays:
            writeInt(&buf, Int32(4))
        
        
        case let .nip04Encrypt(publicKey,text):
            writeInt(&buf, Int32(5))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterString.write(text, into: &buf)
            
        
        case let .nip04Decrypt(publicKey,ciphertext):
            writeInt(&buf, Int32(6))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterString.write(ciphertext, into: &buf)
            
        
        case let .nip44Encrypt(publicKey,text):
            writeInt(&buf, Int32(7))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterString.write(text, into: &buf)
            
        
        case let .nip44Decrypt(publicKey,ciphertext):
            writeInt(&buf, Int32(8))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterString.write(ciphertext, into: &buf)
            
        
        case .ping:
            writeInt(&buf, Int32(9))
        
        }
    }
}


public func FfiConverterTypeNip46Request_lift(_ buf: RustBuffer) throws -> Nip46Request {
    return try FfiConverterTypeNip46Request.lift(buf)
}

public func FfiConverterTypeNip46Request_lower(_ value: Nip46Request) -> RustBuffer {
    return FfiConverterTypeNip46Request.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NostrConnectMessage {
    
    case request(id: String, method: String, params: [String]
    )
    case response(id: String, result: String?, error: String?
    )
}


public struct FfiConverterTypeNostrConnectMessage: FfiConverterRustBuffer {
    typealias SwiftType = NostrConnectMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .request(id: try FfiConverterString.read(from: &buf), method: try FfiConverterString.read(from: &buf), params: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 2: return .response(id: try FfiConverterString.read(from: &buf), result: try FfiConverterOptionString.read(from: &buf), error: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NostrConnectMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .request(id,method,params):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(id, into: &buf)
            FfiConverterString.write(method, into: &buf)
            FfiConverterSequenceString.write(params, into: &buf)
            
        
        case let .response(id,result,error):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(id, into: &buf)
            FfiConverterOptionString.write(result, into: &buf)
            FfiConverterOptionString.write(error, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNostrConnectMessage_lift(_ buf: RustBuffer) throws -> NostrConnectMessage {
    return try FfiConverterTypeNostrConnectMessage.lift(buf)
}

public func FfiConverterTypeNostrConnectMessage_lower(_ value: NostrConnectMessage) -> RustBuffer {
    return FfiConverterTypeNostrConnectMessage.lower(value)
}



extension NostrConnectMessage: Equatable, Hashable {}




public enum NostrError {

    
    
    case Generic(message: String)
    
}


public struct FfiConverterTypeNostrError: FfiConverterRustBuffer {
    typealias SwiftType = NostrError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NostrError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


extension NostrError: Equatable, Hashable {}

extension NostrError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * NIP48 Proxy Protocol
 */

public enum Protocol {
    
    /**
     * ActivityPub
     */
    case activityPub
    /**
     * AT Protocol
     */
    case atProto
    /**
     * Rss
     */
    case rss
    /**
     * Web
     */
    case web
    /**
     * Custom
     */
    case custom(custom: String
    )
}


public struct FfiConverterTypeProtocol: FfiConverterRustBuffer {
    typealias SwiftType = Protocol

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Protocol {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .activityPub
        
        case 2: return .atProto
        
        case 3: return .rss
        
        case 4: return .web
        
        case 5: return .custom(custom: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Protocol, into buf: inout [UInt8]) {
        switch value {
        
        
        case .activityPub:
            writeInt(&buf, Int32(1))
        
        
        case .atProto:
            writeInt(&buf, Int32(2))
        
        
        case .rss:
            writeInt(&buf, Int32(3))
        
        
        case .web:
            writeInt(&buf, Int32(4))
        
        
        case let .custom(custom):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(custom, into: &buf)
            
        }
    }
}


public func FfiConverterTypeProtocol_lift(_ buf: RustBuffer) throws -> Protocol {
    return try FfiConverterTypeProtocol.lift(buf)
}

public func FfiConverterTypeProtocol_lower(_ value: Protocol) -> RustBuffer {
    return FfiConverterTypeProtocol.lower(value)
}



extension Protocol: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RelayMessageEnum {
    
    case eventMsg(subscriptionId: String, event: Event
    )
    case ok(eventId: EventId, status: Bool, message: String
    )
    case endOfStoredEvents(subscriptionId: String
    )
    case notice(message: String
    )
    case closed(subscriptionId: String, message: String
    )
    case auth(challenge: String
    )
    case count(subscriptionId: String, count: UInt64
    )
    case negMsg(subscriptionId: String, message: String
    )
    case negErr(subscriptionId: String, code: String
    )
}


public struct FfiConverterTypeRelayMessageEnum: FfiConverterRustBuffer {
    typealias SwiftType = RelayMessageEnum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayMessageEnum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventMsg(subscriptionId: try FfiConverterString.read(from: &buf), event: try FfiConverterTypeEvent.read(from: &buf)
        )
        
        case 2: return .ok(eventId: try FfiConverterTypeEventId.read(from: &buf), status: try FfiConverterBool.read(from: &buf), message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .endOfStoredEvents(subscriptionId: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .notice(message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .closed(subscriptionId: try FfiConverterString.read(from: &buf), message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .auth(challenge: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .count(subscriptionId: try FfiConverterString.read(from: &buf), count: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 8: return .negMsg(subscriptionId: try FfiConverterString.read(from: &buf), message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .negErr(subscriptionId: try FfiConverterString.read(from: &buf), code: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RelayMessageEnum, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .eventMsg(subscriptionId,event):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterTypeEvent.write(event, into: &buf)
            
        
        case let .ok(eventId,status,message):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            FfiConverterBool.write(status, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .endOfStoredEvents(subscriptionId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(subscriptionId, into: &buf)
            
        
        case let .notice(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .closed(subscriptionId,message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .auth(challenge):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(challenge, into: &buf)
            
        
        case let .count(subscriptionId,count):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterUInt64.write(count, into: &buf)
            
        
        case let .negMsg(subscriptionId,message):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .negErr(subscriptionId,code):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterString.write(code, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRelayMessageEnum_lift(_ buf: RustBuffer) throws -> RelayMessageEnum {
    return try FfiConverterTypeRelayMessageEnum.lift(buf)
}

public func FfiConverterTypeRelayMessageEnum_lower(_ value: RelayMessageEnum) -> RustBuffer {
    return FfiConverterTypeRelayMessageEnum.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RelayMetadata {
    
    /**
     * Read
     */
    case read
    /**
     * Write
     */
    case write
}


public struct FfiConverterTypeRelayMetadata: FfiConverterRustBuffer {
    typealias SwiftType = RelayMetadata

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayMetadata {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .read
        
        case 2: return .write
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RelayMetadata, into buf: inout [UInt8]) {
        switch value {
        
        
        case .read:
            writeInt(&buf, Int32(1))
        
        
        case .write:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeRelayMetadata_lift(_ buf: RustBuffer) throws -> RelayMetadata {
    return try FfiConverterTypeRelayMetadata.lift(buf)
}

public func FfiConverterTypeRelayMetadata_lower(_ value: RelayMetadata) -> RustBuffer {
    return FfiConverterTypeRelayMetadata.lower(value)
}



extension RelayMetadata: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Report
 *
 * <https://github.com/nostr-protocol/nips/blob/master/56.md>
 */

public enum Report {
    
    /**
     * Depictions of nudity, porn, etc
     */
    case nudity
    /**
     * Profanity, hateful speech, etc.
     */
    case profanity
    /**
     * Something which may be illegal in some jurisdiction
     *
     * Remember: there is what is right and there is the law.
     */
    case illegal
    /**
     * Spam
     */
    case spam
    /**
     * Someone pretending to be someone else
     */
    case impersonation
    /**
     * Reports that don't fit in the above categories
     */
    case other
}


public struct FfiConverterTypeReport: FfiConverterRustBuffer {
    typealias SwiftType = Report

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Report {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nudity
        
        case 2: return .profanity
        
        case 3: return .illegal
        
        case 4: return .spam
        
        case 5: return .impersonation
        
        case 6: return .other
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Report, into buf: inout [UInt8]) {
        switch value {
        
        
        case .nudity:
            writeInt(&buf, Int32(1))
        
        
        case .profanity:
            writeInt(&buf, Int32(2))
        
        
        case .illegal:
            writeInt(&buf, Int32(3))
        
        
        case .spam:
            writeInt(&buf, Int32(4))
        
        
        case .impersonation:
            writeInt(&buf, Int32(5))
        
        
        case .other:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypeReport_lift(_ buf: RustBuffer) throws -> Report {
    return try FfiConverterTypeReport.lift(buf)
}

public func FfiConverterTypeReport_lower(_ value: Report) -> RustBuffer {
    return FfiConverterTypeReport.lower(value)
}



extension Report: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Nostr Wallet Connect Request Params
 */

public enum RequestParams {
    
    /**
     * Pay Invoice
     */
    case payInvoice(payInvoice: PayInvoiceRequestParams
    )
    /**
     * Multi Pay Invoice
     */
    case multiPayInvoice(multiPayInvoice: MultiPayInvoiceRequestParams
    )
    /**
     * Pay Keysend
     */
    case payKeysend(payKeysend: PayKeysendRequestParams
    )
    /**
     * Multi Pay Keysend
     */
    case multiPayKeysend(multiPayKeysend: MultiPayKeysendRequestParams
    )
    /**
     * Make Invoice
     */
    case makeInvoice(makeInvoice: MakeInvoiceRequestParams
    )
    /**
     * Lookup Invoice
     */
    case lookupInvoice(lookupInvoice: LookupInvoiceRequestParams
    )
    /**
     * List Transactions
     */
    case listTransactions(listTransactions: ListTransactionsRequestParams
    )
    /**
     * Get Balance
     */
    case getBalance
    /**
     * Get Info
     */
    case getInfo
}


public struct FfiConverterTypeRequestParams: FfiConverterRustBuffer {
    typealias SwiftType = RequestParams

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestParams {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .payInvoice(payInvoice: try FfiConverterTypePayInvoiceRequestParams.read(from: &buf)
        )
        
        case 2: return .multiPayInvoice(multiPayInvoice: try FfiConverterTypeMultiPayInvoiceRequestParams.read(from: &buf)
        )
        
        case 3: return .payKeysend(payKeysend: try FfiConverterTypePayKeysendRequestParams.read(from: &buf)
        )
        
        case 4: return .multiPayKeysend(multiPayKeysend: try FfiConverterTypeMultiPayKeysendRequestParams.read(from: &buf)
        )
        
        case 5: return .makeInvoice(makeInvoice: try FfiConverterTypeMakeInvoiceRequestParams.read(from: &buf)
        )
        
        case 6: return .lookupInvoice(lookupInvoice: try FfiConverterTypeLookupInvoiceRequestParams.read(from: &buf)
        )
        
        case 7: return .listTransactions(listTransactions: try FfiConverterTypeListTransactionsRequestParams.read(from: &buf)
        )
        
        case 8: return .getBalance
        
        case 9: return .getInfo
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestParams, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .payInvoice(payInvoice):
            writeInt(&buf, Int32(1))
            FfiConverterTypePayInvoiceRequestParams.write(payInvoice, into: &buf)
            
        
        case let .multiPayInvoice(multiPayInvoice):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMultiPayInvoiceRequestParams.write(multiPayInvoice, into: &buf)
            
        
        case let .payKeysend(payKeysend):
            writeInt(&buf, Int32(3))
            FfiConverterTypePayKeysendRequestParams.write(payKeysend, into: &buf)
            
        
        case let .multiPayKeysend(multiPayKeysend):
            writeInt(&buf, Int32(4))
            FfiConverterTypeMultiPayKeysendRequestParams.write(multiPayKeysend, into: &buf)
            
        
        case let .makeInvoice(makeInvoice):
            writeInt(&buf, Int32(5))
            FfiConverterTypeMakeInvoiceRequestParams.write(makeInvoice, into: &buf)
            
        
        case let .lookupInvoice(lookupInvoice):
            writeInt(&buf, Int32(6))
            FfiConverterTypeLookupInvoiceRequestParams.write(lookupInvoice, into: &buf)
            
        
        case let .listTransactions(listTransactions):
            writeInt(&buf, Int32(7))
            FfiConverterTypeListTransactionsRequestParams.write(listTransactions, into: &buf)
            
        
        case .getBalance:
            writeInt(&buf, Int32(8))
        
        
        case .getInfo:
            writeInt(&buf, Int32(9))
        
        }
    }
}


public func FfiConverterTypeRequestParams_lift(_ buf: RustBuffer) throws -> RequestParams {
    return try FfiConverterTypeRequestParams.lift(buf)
}

public func FfiConverterTypeRequestParams_lower(_ value: RequestParams) -> RustBuffer {
    return FfiConverterTypeRequestParams.lower(value)
}



extension RequestParams: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * NIP47 Response Result
 */

public enum ResponseResult {
    
    /**
     * Pay Invoice
     */
    case payInvoice(payInvoice: PayInvoiceResponseResult
    )
    /**
     * Multi Pay Invoice
     */
    case multiPayInvoice(payInvoice: PayInvoiceResponseResult
    )
    /**
     * Pay Keysend
     */
    case payKeysend(payKeysend: PayKeysendResponseResult
    )
    /**
     * Multi Pay Keysend
     */
    case multiPayKeysend(payKeysend: PayKeysendResponseResult
    )
    /**
     * Make Invoice
     */
    case makeInvoice(makeInvoice: MakeInvoiceResponseResult
    )
    /**
     * Lookup Invoice
     */
    case lookupInvoice(lookupInvoice: LookupInvoiceResponseResult
    )
    /**
     * List Transactions
     */
    case listTransactions(listTransactions: [LookupInvoiceResponseResult]
    )
    /**
     * Get Balance
     */
    case getBalance(getBalance: GetBalanceResponseResult
    )
    /**
     * Get Info
     */
    case getInfo(getInfo: GetInfoResponseResult
    )
}


public struct FfiConverterTypeResponseResult: FfiConverterRustBuffer {
    typealias SwiftType = ResponseResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResponseResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .payInvoice(payInvoice: try FfiConverterTypePayInvoiceResponseResult.read(from: &buf)
        )
        
        case 2: return .multiPayInvoice(payInvoice: try FfiConverterTypePayInvoiceResponseResult.read(from: &buf)
        )
        
        case 3: return .payKeysend(payKeysend: try FfiConverterTypePayKeysendResponseResult.read(from: &buf)
        )
        
        case 4: return .multiPayKeysend(payKeysend: try FfiConverterTypePayKeysendResponseResult.read(from: &buf)
        )
        
        case 5: return .makeInvoice(makeInvoice: try FfiConverterTypeMakeInvoiceResponseResult.read(from: &buf)
        )
        
        case 6: return .lookupInvoice(lookupInvoice: try FfiConverterTypeLookupInvoiceResponseResult.read(from: &buf)
        )
        
        case 7: return .listTransactions(listTransactions: try FfiConverterSequenceTypeLookupInvoiceResponseResult.read(from: &buf)
        )
        
        case 8: return .getBalance(getBalance: try FfiConverterTypeGetBalanceResponseResult.read(from: &buf)
        )
        
        case 9: return .getInfo(getInfo: try FfiConverterTypeGetInfoResponseResult.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResponseResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .payInvoice(payInvoice):
            writeInt(&buf, Int32(1))
            FfiConverterTypePayInvoiceResponseResult.write(payInvoice, into: &buf)
            
        
        case let .multiPayInvoice(payInvoice):
            writeInt(&buf, Int32(2))
            FfiConverterTypePayInvoiceResponseResult.write(payInvoice, into: &buf)
            
        
        case let .payKeysend(payKeysend):
            writeInt(&buf, Int32(3))
            FfiConverterTypePayKeysendResponseResult.write(payKeysend, into: &buf)
            
        
        case let .multiPayKeysend(payKeysend):
            writeInt(&buf, Int32(4))
            FfiConverterTypePayKeysendResponseResult.write(payKeysend, into: &buf)
            
        
        case let .makeInvoice(makeInvoice):
            writeInt(&buf, Int32(5))
            FfiConverterTypeMakeInvoiceResponseResult.write(makeInvoice, into: &buf)
            
        
        case let .lookupInvoice(lookupInvoice):
            writeInt(&buf, Int32(6))
            FfiConverterTypeLookupInvoiceResponseResult.write(lookupInvoice, into: &buf)
            
        
        case let .listTransactions(listTransactions):
            writeInt(&buf, Int32(7))
            FfiConverterSequenceTypeLookupInvoiceResponseResult.write(listTransactions, into: &buf)
            
        
        case let .getBalance(getBalance):
            writeInt(&buf, Int32(8))
            FfiConverterTypeGetBalanceResponseResult.write(getBalance, into: &buf)
            
        
        case let .getInfo(getInfo):
            writeInt(&buf, Int32(9))
            FfiConverterTypeGetInfoResponseResult.write(getInfo, into: &buf)
            
        }
    }
}


public func FfiConverterTypeResponseResult_lift(_ buf: RustBuffer) throws -> ResponseResult {
    return try FfiConverterTypeResponseResult.lift(buf)
}

public func FfiConverterTypeResponseResult_lower(_ value: ResponseResult) -> RustBuffer {
    return FfiConverterTypeResponseResult.lower(value)
}



extension ResponseResult: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RetentionKind {
    
    case single(single: UInt64
    )
    case range(start: UInt64, end: UInt64
    )
}


public struct FfiConverterTypeRetentionKind: FfiConverterRustBuffer {
    typealias SwiftType = RetentionKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetentionKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .single(single: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .range(start: try FfiConverterUInt64.read(from: &buf), end: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RetentionKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .single(single):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(single, into: &buf)
            
        
        case let .range(start,end):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(start, into: &buf)
            FfiConverterUInt64.write(end, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRetentionKind_lift(_ buf: RustBuffer) throws -> RetentionKind {
    return try FfiConverterTypeRetentionKind.lift(buf)
}

public func FfiConverterTypeRetentionKind_lower(_ value: RetentionKind) -> RustBuffer {
    return FfiConverterTypeRetentionKind.lower(value)
}



extension RetentionKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TagKind {
    
    case singleLetter(singleLetter: SingleLetterTag
    )
    /**
     * Relay
     */
    case relayUrl
    /**
     * Nonce
     */
    case nonce
    /**
     * Delegation
     */
    case delegation
    /**
     * Content warning
     */
    case contentWarning
    /**
     * Expiration
     */
    case expiration
    /**
     * Subject
     */
    case subject
    /**
     * Auth challenge
     */
    case challenge
    /**
     * Title (NIP23)
     */
    case title
    /**
     * Image (NIP23)
     */
    case image
    /**
     * Thumbnail
     */
    case thumb
    /**
     * Summary (NIP23)
     */
    case summary
    /**
     * PublishedAt (NIP23)
     */
    case publishedAt
    /**
     * Description (NIP57)
     */
    case description
    /**
     * Bolt11 Invoice (NIP57)
     */
    case bolt11
    /**
     * Preimage (NIP57)
     */
    case preimage
    /**
     * Relays (NIP57)
     */
    case relays
    /**
     * Amount (NIP57)
     */
    case amount
    /**
     * Lnurl (NIP57)
     */
    case lnurl
    /**
     * Name tag
     */
    case name
    /**
     * Url
     */
    case url
    /**
     * AES 256 GCM
     */
    case aes256Gcm
    /**
     * Size of file in bytes
     */
    case size
    /**
     * Size of file in pixels
     */
    case dim
    /**
     * Magnet
     */
    case magnet
    /**
     * Blurhash
     */
    case blurhash
    /**
     * Streaming
     */
    case streaming
    /**
     * Recording
     */
    case recording
    /**
     * Starts
     */
    case starts
    /**
     * Ends
     */
    case ends
    /**
     * Status
     */
    case status
    /**
     * Current participants
     */
    case currentParticipants
    /**
     * Total participants
     */
    case totalParticipants
    /**
     * HTTP Method Request
     */
    case method
    /**
     * Payload HASH
     */
    case payload
    case anon
    case proxy
    case emoji
    /**
     * Encrypted
     */
    case encrypted
    case request
    case word
    case unknown(unknown: String
    )
}


public struct FfiConverterTypeTagKind: FfiConverterRustBuffer {
    typealias SwiftType = TagKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TagKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .singleLetter(singleLetter: try FfiConverterTypeSingleLetterTag.read(from: &buf)
        )
        
        case 2: return .relayUrl
        
        case 3: return .nonce
        
        case 4: return .delegation
        
        case 5: return .contentWarning
        
        case 6: return .expiration
        
        case 7: return .subject
        
        case 8: return .challenge
        
        case 9: return .title
        
        case 10: return .image
        
        case 11: return .thumb
        
        case 12: return .summary
        
        case 13: return .publishedAt
        
        case 14: return .description
        
        case 15: return .bolt11
        
        case 16: return .preimage
        
        case 17: return .relays
        
        case 18: return .amount
        
        case 19: return .lnurl
        
        case 20: return .name
        
        case 21: return .url
        
        case 22: return .aes256Gcm
        
        case 23: return .size
        
        case 24: return .dim
        
        case 25: return .magnet
        
        case 26: return .blurhash
        
        case 27: return .streaming
        
        case 28: return .recording
        
        case 29: return .starts
        
        case 30: return .ends
        
        case 31: return .status
        
        case 32: return .currentParticipants
        
        case 33: return .totalParticipants
        
        case 34: return .method
        
        case 35: return .payload
        
        case 36: return .anon
        
        case 37: return .proxy
        
        case 38: return .emoji
        
        case 39: return .encrypted
        
        case 40: return .request
        
        case 41: return .word
        
        case 42: return .unknown(unknown: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TagKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .singleLetter(singleLetter):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSingleLetterTag.write(singleLetter, into: &buf)
            
        
        case .relayUrl:
            writeInt(&buf, Int32(2))
        
        
        case .nonce:
            writeInt(&buf, Int32(3))
        
        
        case .delegation:
            writeInt(&buf, Int32(4))
        
        
        case .contentWarning:
            writeInt(&buf, Int32(5))
        
        
        case .expiration:
            writeInt(&buf, Int32(6))
        
        
        case .subject:
            writeInt(&buf, Int32(7))
        
        
        case .challenge:
            writeInt(&buf, Int32(8))
        
        
        case .title:
            writeInt(&buf, Int32(9))
        
        
        case .image:
            writeInt(&buf, Int32(10))
        
        
        case .thumb:
            writeInt(&buf, Int32(11))
        
        
        case .summary:
            writeInt(&buf, Int32(12))
        
        
        case .publishedAt:
            writeInt(&buf, Int32(13))
        
        
        case .description:
            writeInt(&buf, Int32(14))
        
        
        case .bolt11:
            writeInt(&buf, Int32(15))
        
        
        case .preimage:
            writeInt(&buf, Int32(16))
        
        
        case .relays:
            writeInt(&buf, Int32(17))
        
        
        case .amount:
            writeInt(&buf, Int32(18))
        
        
        case .lnurl:
            writeInt(&buf, Int32(19))
        
        
        case .name:
            writeInt(&buf, Int32(20))
        
        
        case .url:
            writeInt(&buf, Int32(21))
        
        
        case .aes256Gcm:
            writeInt(&buf, Int32(22))
        
        
        case .size:
            writeInt(&buf, Int32(23))
        
        
        case .dim:
            writeInt(&buf, Int32(24))
        
        
        case .magnet:
            writeInt(&buf, Int32(25))
        
        
        case .blurhash:
            writeInt(&buf, Int32(26))
        
        
        case .streaming:
            writeInt(&buf, Int32(27))
        
        
        case .recording:
            writeInt(&buf, Int32(28))
        
        
        case .starts:
            writeInt(&buf, Int32(29))
        
        
        case .ends:
            writeInt(&buf, Int32(30))
        
        
        case .status:
            writeInt(&buf, Int32(31))
        
        
        case .currentParticipants:
            writeInt(&buf, Int32(32))
        
        
        case .totalParticipants:
            writeInt(&buf, Int32(33))
        
        
        case .method:
            writeInt(&buf, Int32(34))
        
        
        case .payload:
            writeInt(&buf, Int32(35))
        
        
        case .anon:
            writeInt(&buf, Int32(36))
        
        
        case .proxy:
            writeInt(&buf, Int32(37))
        
        
        case .emoji:
            writeInt(&buf, Int32(38))
        
        
        case .encrypted:
            writeInt(&buf, Int32(39))
        
        
        case .request:
            writeInt(&buf, Int32(40))
        
        
        case .word:
            writeInt(&buf, Int32(41))
        
        
        case let .unknown(unknown):
            writeInt(&buf, Int32(42))
            FfiConverterString.write(unknown, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTagKind_lift(_ buf: RustBuffer) throws -> TagKind {
    return try FfiConverterTypeTagKind.lift(buf)
}

public func FfiConverterTypeTagKind_lower(_ value: TagKind) -> RustBuffer {
    return FfiConverterTypeTagKind.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Standardized tag
 */

public enum TagStandard {
    
    case eventTag(eventId: EventId, relayUrl: String?, marker: Marker?, 
        /**
         * Should be the public key of the author of the referenced event
         */publicKey: PublicKey?
    )
    case publicKeyTag(publicKey: PublicKey, relayUrl: String?, alias: String?, 
        /**
         * Whether the p tag is an uppercase P or not
         */uppercase: Bool
    )
    case eventReport(eventId: EventId, report: Report
    )
    case pubKeyReport(publicKey: PublicKey, report: Report
    )
    case publicKeyLiveEvent(publicKey: PublicKey, relayUrl: String?, marker: LiveEventMarker, proof: String?
    )
    case reference(reference: String
    )
    case relayMetadataTag(relayUrl: String, rw: RelayMetadata?
    )
    case hashtag(hashtag: String
    )
    case geohash(geohash: String
    )
    case identifier(identifier: String
    )
    case externalIdentity(identity: Identity
    )
    case coordinateTag(coordinate: Coordinate, relayUrl: String?
    )
    case kind(kind: KindEnum
    )
    case relayUrl(relayUrl: String
    )
    case pow(nonce: String, difficulty: UInt8
    )
    case delegation(delegator: PublicKey, conditions: String, sig: String
    )
    case contentWarning(reason: String?
    )
    case expiration(timestamp: Timestamp
    )
    case subject(subject: String
    )
    case challenge(challenge: String
    )
    case title(title: String
    )
    case image(url: String, dimensions: ImageDimensions?
    )
    case thumb(url: String, dimensions: ImageDimensions?
    )
    case summary(summary: String
    )
    case description(desc: String
    )
    case bolt11(bolt11: String
    )
    case preimage(preimage: String
    )
    case relays(urls: [String]
    )
    case amount(millisats: UInt64, bolt11: String?
    )
    case lnurl(lnurl: String
    )
    case name(name: String
    )
    case publishedAt(timestamp: Timestamp
    )
    case urlTag(url: String
    )
    case mimeType(mime: String
    )
    case aes256Gcm(key: String, iv: String
    )
    case sha256(hash: String
    )
    case size(size: UInt64
    )
    /**
     * Size of file in pixels
     */
    case dim(dimensions: ImageDimensions
    )
    case magnet(uri: String
    )
    case blurhash(blurhash: String
    )
    case streaming(url: String
    )
    case recording(url: String
    )
    case starts(timestamp: Timestamp
    )
    case ends(timestamp: Timestamp
    )
    case liveEventStatusTag(status: LiveEventStatus
    )
    case currentParticipants(num: UInt64
    )
    case totalParticipants(num: UInt64
    )
    case absoluteUrl(url: String
    )
    case method(method: HttpMethod
    )
    case payload(hash: String
    )
    case anon(msg: String?
    )
    case proxy(id: String, `protocol`: Protocol
    )
    case emoji(shortcode: String, url: String
    )
    case encrypted
    case request(event: Event
    )
    case dataVendingMachineStatusTag(status: DataVendingMachineStatus, extraInfo: String?
    )
    case word(word: String
    )
    case labelNamespace(namespace: String
    )
    case label(label: [String]
    )
}


public struct FfiConverterTypeTagStandard: FfiConverterRustBuffer {
    typealias SwiftType = TagStandard

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TagStandard {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventTag(eventId: try FfiConverterTypeEventId.read(from: &buf), relayUrl: try FfiConverterOptionString.read(from: &buf), marker: try FfiConverterOptionTypeMarker.read(from: &buf), publicKey: try FfiConverterOptionTypePublicKey.read(from: &buf)
        )
        
        case 2: return .publicKeyTag(publicKey: try FfiConverterTypePublicKey.read(from: &buf), relayUrl: try FfiConverterOptionString.read(from: &buf), alias: try FfiConverterOptionString.read(from: &buf), uppercase: try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .eventReport(eventId: try FfiConverterTypeEventId.read(from: &buf), report: try FfiConverterTypeReport.read(from: &buf)
        )
        
        case 4: return .pubKeyReport(publicKey: try FfiConverterTypePublicKey.read(from: &buf), report: try FfiConverterTypeReport.read(from: &buf)
        )
        
        case 5: return .publicKeyLiveEvent(publicKey: try FfiConverterTypePublicKey.read(from: &buf), relayUrl: try FfiConverterOptionString.read(from: &buf), marker: try FfiConverterTypeLiveEventMarker.read(from: &buf), proof: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 6: return .reference(reference: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .relayMetadataTag(relayUrl: try FfiConverterString.read(from: &buf), rw: try FfiConverterOptionTypeRelayMetadata.read(from: &buf)
        )
        
        case 8: return .hashtag(hashtag: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .geohash(geohash: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .identifier(identifier: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .externalIdentity(identity: try FfiConverterTypeIdentity.read(from: &buf)
        )
        
        case 12: return .coordinateTag(coordinate: try FfiConverterTypeCoordinate.read(from: &buf), relayUrl: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 13: return .kind(kind: try FfiConverterTypeKindEnum.read(from: &buf)
        )
        
        case 14: return .relayUrl(relayUrl: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .pow(nonce: try FfiConverterString.read(from: &buf), difficulty: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 16: return .delegation(delegator: try FfiConverterTypePublicKey.read(from: &buf), conditions: try FfiConverterString.read(from: &buf), sig: try FfiConverterString.read(from: &buf)
        )
        
        case 17: return .contentWarning(reason: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 18: return .expiration(timestamp: try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 19: return .subject(subject: try FfiConverterString.read(from: &buf)
        )
        
        case 20: return .challenge(challenge: try FfiConverterString.read(from: &buf)
        )
        
        case 21: return .title(title: try FfiConverterString.read(from: &buf)
        )
        
        case 22: return .image(url: try FfiConverterString.read(from: &buf), dimensions: try FfiConverterOptionTypeImageDimensions.read(from: &buf)
        )
        
        case 23: return .thumb(url: try FfiConverterString.read(from: &buf), dimensions: try FfiConverterOptionTypeImageDimensions.read(from: &buf)
        )
        
        case 24: return .summary(summary: try FfiConverterString.read(from: &buf)
        )
        
        case 25: return .description(desc: try FfiConverterString.read(from: &buf)
        )
        
        case 26: return .bolt11(bolt11: try FfiConverterString.read(from: &buf)
        )
        
        case 27: return .preimage(preimage: try FfiConverterString.read(from: &buf)
        )
        
        case 28: return .relays(urls: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 29: return .amount(millisats: try FfiConverterUInt64.read(from: &buf), bolt11: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 30: return .lnurl(lnurl: try FfiConverterString.read(from: &buf)
        )
        
        case 31: return .name(name: try FfiConverterString.read(from: &buf)
        )
        
        case 32: return .publishedAt(timestamp: try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 33: return .urlTag(url: try FfiConverterString.read(from: &buf)
        )
        
        case 34: return .mimeType(mime: try FfiConverterString.read(from: &buf)
        )
        
        case 35: return .aes256Gcm(key: try FfiConverterString.read(from: &buf), iv: try FfiConverterString.read(from: &buf)
        )
        
        case 36: return .sha256(hash: try FfiConverterString.read(from: &buf)
        )
        
        case 37: return .size(size: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 38: return .dim(dimensions: try FfiConverterTypeImageDimensions.read(from: &buf)
        )
        
        case 39: return .magnet(uri: try FfiConverterString.read(from: &buf)
        )
        
        case 40: return .blurhash(blurhash: try FfiConverterString.read(from: &buf)
        )
        
        case 41: return .streaming(url: try FfiConverterString.read(from: &buf)
        )
        
        case 42: return .recording(url: try FfiConverterString.read(from: &buf)
        )
        
        case 43: return .starts(timestamp: try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 44: return .ends(timestamp: try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 45: return .liveEventStatusTag(status: try FfiConverterTypeLiveEventStatus.read(from: &buf)
        )
        
        case 46: return .currentParticipants(num: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 47: return .totalParticipants(num: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 48: return .absoluteUrl(url: try FfiConverterString.read(from: &buf)
        )
        
        case 49: return .method(method: try FfiConverterTypeHttpMethod.read(from: &buf)
        )
        
        case 50: return .payload(hash: try FfiConverterString.read(from: &buf)
        )
        
        case 51: return .anon(msg: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 52: return .proxy(id: try FfiConverterString.read(from: &buf), protocol: try FfiConverterTypeProtocol.read(from: &buf)
        )
        
        case 53: return .emoji(shortcode: try FfiConverterString.read(from: &buf), url: try FfiConverterString.read(from: &buf)
        )
        
        case 54: return .encrypted
        
        case 55: return .request(event: try FfiConverterTypeEvent.read(from: &buf)
        )
        
        case 56: return .dataVendingMachineStatusTag(status: try FfiConverterTypeDataVendingMachineStatus.read(from: &buf), extraInfo: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 57: return .word(word: try FfiConverterString.read(from: &buf)
        )
        
        case 58: return .labelNamespace(namespace: try FfiConverterString.read(from: &buf)
        )
        
        case 59: return .label(label: try FfiConverterSequenceString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TagStandard, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .eventTag(eventId,relayUrl,marker,publicKey):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            FfiConverterOptionString.write(relayUrl, into: &buf)
            FfiConverterOptionTypeMarker.write(marker, into: &buf)
            FfiConverterOptionTypePublicKey.write(publicKey, into: &buf)
            
        
        case let .publicKeyTag(publicKey,relayUrl,alias,uppercase):
            writeInt(&buf, Int32(2))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterOptionString.write(relayUrl, into: &buf)
            FfiConverterOptionString.write(alias, into: &buf)
            FfiConverterBool.write(uppercase, into: &buf)
            
        
        case let .eventReport(eventId,report):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            FfiConverterTypeReport.write(report, into: &buf)
            
        
        case let .pubKeyReport(publicKey,report):
            writeInt(&buf, Int32(4))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterTypeReport.write(report, into: &buf)
            
        
        case let .publicKeyLiveEvent(publicKey,relayUrl,marker,proof):
            writeInt(&buf, Int32(5))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterOptionString.write(relayUrl, into: &buf)
            FfiConverterTypeLiveEventMarker.write(marker, into: &buf)
            FfiConverterOptionString.write(proof, into: &buf)
            
        
        case let .reference(reference):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(reference, into: &buf)
            
        
        case let .relayMetadataTag(relayUrl,rw):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(relayUrl, into: &buf)
            FfiConverterOptionTypeRelayMetadata.write(rw, into: &buf)
            
        
        case let .hashtag(hashtag):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(hashtag, into: &buf)
            
        
        case let .geohash(geohash):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(geohash, into: &buf)
            
        
        case let .identifier(identifier):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(identifier, into: &buf)
            
        
        case let .externalIdentity(identity):
            writeInt(&buf, Int32(11))
            FfiConverterTypeIdentity.write(identity, into: &buf)
            
        
        case let .coordinateTag(coordinate,relayUrl):
            writeInt(&buf, Int32(12))
            FfiConverterTypeCoordinate.write(coordinate, into: &buf)
            FfiConverterOptionString.write(relayUrl, into: &buf)
            
        
        case let .kind(kind):
            writeInt(&buf, Int32(13))
            FfiConverterTypeKindEnum.write(kind, into: &buf)
            
        
        case let .relayUrl(relayUrl):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(relayUrl, into: &buf)
            
        
        case let .pow(nonce,difficulty):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(nonce, into: &buf)
            FfiConverterUInt8.write(difficulty, into: &buf)
            
        
        case let .delegation(delegator,conditions,sig):
            writeInt(&buf, Int32(16))
            FfiConverterTypePublicKey.write(delegator, into: &buf)
            FfiConverterString.write(conditions, into: &buf)
            FfiConverterString.write(sig, into: &buf)
            
        
        case let .contentWarning(reason):
            writeInt(&buf, Int32(17))
            FfiConverterOptionString.write(reason, into: &buf)
            
        
        case let .expiration(timestamp):
            writeInt(&buf, Int32(18))
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            
        
        case let .subject(subject):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(subject, into: &buf)
            
        
        case let .challenge(challenge):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(challenge, into: &buf)
            
        
        case let .title(title):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(title, into: &buf)
            
        
        case let .image(url,dimensions):
            writeInt(&buf, Int32(22))
            FfiConverterString.write(url, into: &buf)
            FfiConverterOptionTypeImageDimensions.write(dimensions, into: &buf)
            
        
        case let .thumb(url,dimensions):
            writeInt(&buf, Int32(23))
            FfiConverterString.write(url, into: &buf)
            FfiConverterOptionTypeImageDimensions.write(dimensions, into: &buf)
            
        
        case let .summary(summary):
            writeInt(&buf, Int32(24))
            FfiConverterString.write(summary, into: &buf)
            
        
        case let .description(desc):
            writeInt(&buf, Int32(25))
            FfiConverterString.write(desc, into: &buf)
            
        
        case let .bolt11(bolt11):
            writeInt(&buf, Int32(26))
            FfiConverterString.write(bolt11, into: &buf)
            
        
        case let .preimage(preimage):
            writeInt(&buf, Int32(27))
            FfiConverterString.write(preimage, into: &buf)
            
        
        case let .relays(urls):
            writeInt(&buf, Int32(28))
            FfiConverterSequenceString.write(urls, into: &buf)
            
        
        case let .amount(millisats,bolt11):
            writeInt(&buf, Int32(29))
            FfiConverterUInt64.write(millisats, into: &buf)
            FfiConverterOptionString.write(bolt11, into: &buf)
            
        
        case let .lnurl(lnurl):
            writeInt(&buf, Int32(30))
            FfiConverterString.write(lnurl, into: &buf)
            
        
        case let .name(name):
            writeInt(&buf, Int32(31))
            FfiConverterString.write(name, into: &buf)
            
        
        case let .publishedAt(timestamp):
            writeInt(&buf, Int32(32))
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            
        
        case let .urlTag(url):
            writeInt(&buf, Int32(33))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .mimeType(mime):
            writeInt(&buf, Int32(34))
            FfiConverterString.write(mime, into: &buf)
            
        
        case let .aes256Gcm(key,iv):
            writeInt(&buf, Int32(35))
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(iv, into: &buf)
            
        
        case let .sha256(hash):
            writeInt(&buf, Int32(36))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .size(size):
            writeInt(&buf, Int32(37))
            FfiConverterUInt64.write(size, into: &buf)
            
        
        case let .dim(dimensions):
            writeInt(&buf, Int32(38))
            FfiConverterTypeImageDimensions.write(dimensions, into: &buf)
            
        
        case let .magnet(uri):
            writeInt(&buf, Int32(39))
            FfiConverterString.write(uri, into: &buf)
            
        
        case let .blurhash(blurhash):
            writeInt(&buf, Int32(40))
            FfiConverterString.write(blurhash, into: &buf)
            
        
        case let .streaming(url):
            writeInt(&buf, Int32(41))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .recording(url):
            writeInt(&buf, Int32(42))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .starts(timestamp):
            writeInt(&buf, Int32(43))
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            
        
        case let .ends(timestamp):
            writeInt(&buf, Int32(44))
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            
        
        case let .liveEventStatusTag(status):
            writeInt(&buf, Int32(45))
            FfiConverterTypeLiveEventStatus.write(status, into: &buf)
            
        
        case let .currentParticipants(num):
            writeInt(&buf, Int32(46))
            FfiConverterUInt64.write(num, into: &buf)
            
        
        case let .totalParticipants(num):
            writeInt(&buf, Int32(47))
            FfiConverterUInt64.write(num, into: &buf)
            
        
        case let .absoluteUrl(url):
            writeInt(&buf, Int32(48))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .method(method):
            writeInt(&buf, Int32(49))
            FfiConverterTypeHttpMethod.write(method, into: &buf)
            
        
        case let .payload(hash):
            writeInt(&buf, Int32(50))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .anon(msg):
            writeInt(&buf, Int32(51))
            FfiConverterOptionString.write(msg, into: &buf)
            
        
        case let .proxy(id,`protocol`):
            writeInt(&buf, Int32(52))
            FfiConverterString.write(id, into: &buf)
            FfiConverterTypeProtocol.write(`protocol`, into: &buf)
            
        
        case let .emoji(shortcode,url):
            writeInt(&buf, Int32(53))
            FfiConverterString.write(shortcode, into: &buf)
            FfiConverterString.write(url, into: &buf)
            
        
        case .encrypted:
            writeInt(&buf, Int32(54))
        
        
        case let .request(event):
            writeInt(&buf, Int32(55))
            FfiConverterTypeEvent.write(event, into: &buf)
            
        
        case let .dataVendingMachineStatusTag(status,extraInfo):
            writeInt(&buf, Int32(56))
            FfiConverterTypeDataVendingMachineStatus.write(status, into: &buf)
            FfiConverterOptionString.write(extraInfo, into: &buf)
            
        
        case let .word(word):
            writeInt(&buf, Int32(57))
            FfiConverterString.write(word, into: &buf)
            
        
        case let .labelNamespace(namespace):
            writeInt(&buf, Int32(58))
            FfiConverterString.write(namespace, into: &buf)
            
        
        case let .label(label):
            writeInt(&buf, Int32(59))
            FfiConverterSequenceString.write(label, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTagStandard_lift(_ buf: RustBuffer) throws -> TagStandard {
    return try FfiConverterTypeTagStandard.lift(buf)
}

public func FfiConverterTypeTagStandard_lower(_ value: TagStandard) -> RustBuffer {
    return FfiConverterTypeTagStandard.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Transaction Type
 */

public enum TransactionType {
    
    /**
     * Incoming payments
     */
    case incoming
    /**
     * Outgoing payments
     */
    case outgoing
}


public struct FfiConverterTypeTransactionType: FfiConverterRustBuffer {
    typealias SwiftType = TransactionType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .incoming
        
        case 2: return .outgoing
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .incoming:
            writeInt(&buf, Int32(1))
        
        
        case .outgoing:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeTransactionType_lift(_ buf: RustBuffer) throws -> TransactionType {
    return try FfiConverterTypeTransactionType.lift(buf)
}

public func FfiConverterTypeTransactionType_lower(_ value: TransactionType) -> RustBuffer {
    return FfiConverterTypeTransactionType.lower(value)
}



extension TransactionType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ZapType {
    
    /**
     * Public
     */
    case `public`
    /**
     * Private
     */
    case `private`
    /**
     * Anonymous
     */
    case anonymous
}


public struct FfiConverterTypeZapType: FfiConverterRustBuffer {
    typealias SwiftType = ZapType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZapType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`public`
        
        case 2: return .`private`
        
        case 3: return .anonymous
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZapType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`public`:
            writeInt(&buf, Int32(1))
        
        
        case .`private`:
            writeInt(&buf, Int32(2))
        
        
        case .anonymous:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeZapType_lift(_ buf: RustBuffer) throws -> ZapType {
    return try FfiConverterTypeZapType.lift(buf)
}

public func FfiConverterTypeZapType_lower(_ value: ZapType) -> RustBuffer {
    return FfiConverterTypeZapType.lower(value)
}



extension ZapType: Equatable, Hashable {}



fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEvent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEvent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventId: FfiConverterRustBuffer {
    typealias SwiftType = EventId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeImageDimensions: FfiConverterRustBuffer {
    typealias SwiftType = ImageDimensions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImageDimensions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImageDimensions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePublicKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePublicKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSingleLetterTag: FfiConverterRustBuffer {
    typealias SwiftType = SingleLetterTag?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSingleLetterTag.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSingleLetterTag.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Timestamp?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTimestamp.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTimestamp.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFeeSchedules: FfiConverterRustBuffer {
    typealias SwiftType = FeeSchedules?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFeeSchedules.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFeeSchedules.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeImage: FfiConverterRustBuffer {
    typealias SwiftType = Image?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLimitation: FfiConverterRustBuffer {
    typealias SwiftType = Limitation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLimitation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLimitation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLiveEventHost: FfiConverterRustBuffer {
    typealias SwiftType = LiveEventHost?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLiveEventHost.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLiveEventHost.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeJsonValue: FfiConverterRustBuffer {
    typealias SwiftType = JsonValue?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeJsonValue.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeJsonValue.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLiveEventStatus: FfiConverterRustBuffer {
    typealias SwiftType = LiveEventStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLiveEventStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLiveEventStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMarker: FfiConverterRustBuffer {
    typealias SwiftType = Marker?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMarker.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMarker.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRelayMetadata: FfiConverterRustBuffer {
    typealias SwiftType = RelayMetadata?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRelayMetadata.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRelayMetadata.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTagStandard: FfiConverterRustBuffer {
    typealias SwiftType = TagStandard?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTagStandard.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTagStandard.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTransactionType: FfiConverterRustBuffer {
    typealias SwiftType = TransactionType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTransactionType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTransactionType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceUInt16: FfiConverterRustBuffer {
    typealias SwiftType = [UInt16]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeEventId: FfiConverterRustBuffer {
    typealias SwiftType = [EventId]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeEventId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeEventId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeKind: FfiConverterRustBuffer {
    typealias SwiftType = [Kind]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeKind.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeKind.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePublicKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePublicKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeRetentionKind: FfiConverterRustBuffer {
    typealias SwiftType = [RetentionKind]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeRetentionKind.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeRetentionKind.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt16: FfiConverterRustBuffer {
    typealias SwiftType = [UInt16]

    public static func write(_ value: [UInt16], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt16.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt16] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt16]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt16.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeContact: FfiConverterRustBuffer {
    typealias SwiftType = [Contact]

    public static func write(_ value: [Contact], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeContact.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Contact] {
        let len: Int32 = try readInt(&buf)
        var seq = [Contact]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeContact.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeCoordinate: FfiConverterRustBuffer {
    typealias SwiftType = [Coordinate]

    public static func write(_ value: [Coordinate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCoordinate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Coordinate] {
        let len: Int32 = try readInt(&buf)
        var seq = [Coordinate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCoordinate.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = [Event]

    public static func write(_ value: [Event], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEvent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Event] {
        let len: Int32 = try readInt(&buf)
        var seq = [Event]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEvent.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeEventId: FfiConverterRustBuffer {
    typealias SwiftType = [EventId]

    public static func write(_ value: [EventId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEventId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EventId] {
        let len: Int32 = try readInt(&buf)
        var seq = [EventId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEventId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = [Filter]

    public static func write(_ value: [Filter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Filter] {
        let len: Int32 = try readInt(&buf)
        var seq = [Filter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFilter.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeKind: FfiConverterRustBuffer {
    typealias SwiftType = [Kind]

    public static func write(_ value: [Kind], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeKind.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Kind] {
        let len: Int32 = try readInt(&buf)
        var seq = [Kind]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeKind.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    public static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeShippingMethod: FfiConverterRustBuffer {
    typealias SwiftType = [ShippingMethod]

    public static func write(_ value: [ShippingMethod], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeShippingMethod.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ShippingMethod] {
        let len: Int32 = try readInt(&buf)
        var seq = [ShippingMethod]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeShippingMethod.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTag: FfiConverterRustBuffer {
    typealias SwiftType = [Tag]

    public static func write(_ value: [Tag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Tag] {
        let len: Int32 = try readInt(&buf)
        var seq = [Tag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTag.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeEmojiInfo: FfiConverterRustBuffer {
    typealias SwiftType = [EmojiInfo]

    public static func write(_ value: [EmojiInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEmojiInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EmojiInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [EmojiInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEmojiInfo.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFeeSchedule: FfiConverterRustBuffer {
    typealias SwiftType = [FeeSchedule]

    public static func write(_ value: [FeeSchedule], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFeeSchedule.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FeeSchedule] {
        let len: Int32 = try readInt(&buf)
        var seq = [FeeSchedule]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFeeSchedule.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeGenericTag: FfiConverterRustBuffer {
    typealias SwiftType = [GenericTag]

    public static func write(_ value: [GenericTag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGenericTag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GenericTag] {
        let len: Int32 = try readInt(&buf)
        var seq = [GenericTag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGenericTag.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeImage: FfiConverterRustBuffer {
    typealias SwiftType = [Image]

    public static func write(_ value: [Image], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeImage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Image] {
        let len: Int32 = try readInt(&buf)
        var seq = [Image]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeImage.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeKeysendTLVRecord: FfiConverterRustBuffer {
    typealias SwiftType = [KeysendTlvRecord]

    public static func write(_ value: [KeysendTlvRecord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeKeysendTLVRecord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [KeysendTlvRecord] {
        let len: Int32 = try readInt(&buf)
        var seq = [KeysendTlvRecord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeKeysendTLVRecord.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLookupInvoiceResponseResult: FfiConverterRustBuffer {
    typealias SwiftType = [LookupInvoiceResponseResult]

    public static func write(_ value: [LookupInvoiceResponseResult], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLookupInvoiceResponseResult.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LookupInvoiceResponseResult] {
        let len: Int32 = try readInt(&buf)
        var seq = [LookupInvoiceResponseResult]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLookupInvoiceResponseResult.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePayInvoiceRequestParams: FfiConverterRustBuffer {
    typealias SwiftType = [PayInvoiceRequestParams]

    public static func write(_ value: [PayInvoiceRequestParams], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePayInvoiceRequestParams.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PayInvoiceRequestParams] {
        let len: Int32 = try readInt(&buf)
        var seq = [PayInvoiceRequestParams]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePayInvoiceRequestParams.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePayKeysendRequestParams: FfiConverterRustBuffer {
    typealias SwiftType = [PayKeysendRequestParams]

    public static func write(_ value: [PayKeysendRequestParams], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePayKeysendRequestParams.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PayKeysendRequestParams] {
        let len: Int32 = try readInt(&buf)
        var seq = [PayKeysendRequestParams]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePayKeysendRequestParams.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePerson: FfiConverterRustBuffer {
    typealias SwiftType = [Person]

    public static func write(_ value: [Person], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerson.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Person] {
        let len: Int32 = try readInt(&buf)
        var seq = [Person]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerson.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRetention: FfiConverterRustBuffer {
    typealias SwiftType = [Retention]

    public static func write(_ value: [Retention], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRetention.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Retention] {
        let len: Int32 = try readInt(&buf)
        var seq = [Retention]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRetention.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeShippingCost: FfiConverterRustBuffer {
    typealias SwiftType = [ShippingCost]

    public static func write(_ value: [ShippingCost], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeShippingCost.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ShippingCost] {
        let len: Int32 = try readInt(&buf)
        var seq = [ShippingCost]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeShippingCost.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeShippingMethodRecord: FfiConverterRustBuffer {
    typealias SwiftType = [ShippingMethodRecord]

    public static func write(_ value: [ShippingMethodRecord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeShippingMethodRecord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ShippingMethodRecord] {
        let len: Int32 = try readInt(&buf)
        var seq = [ShippingMethodRecord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeShippingMethodRecord.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeJsonValue: FfiConverterRustBuffer {
    typealias SwiftType = [JsonValue]

    public static func write(_ value: [JsonValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeJsonValue.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [JsonValue] {
        let len: Int32 = try readInt(&buf)
        var seq = [JsonValue]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeJsonValue.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRetentionKind: FfiConverterRustBuffer {
    typealias SwiftType = [RetentionKind]

    public static func write(_ value: [RetentionKind], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRetentionKind.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RetentionKind] {
        let len: Int32 = try readInt(&buf)
        var seq = [RetentionKind]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRetentionKind.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]

    public static func write(_ value: [[String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[String]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[String]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringTypeJsonValue: FfiConverterRustBuffer {
    public static func write(_ value: [String: JsonValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeJsonValue.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: JsonValue] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: JsonValue]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeJsonValue.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringOptionTypeRelayMetadata: FfiConverterRustBuffer {
    public static func write(_ value: [String: RelayMetadata?], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterOptionTypeRelayMetadata.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: RelayMetadata?] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: RelayMetadata?]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterOptionTypeRelayMetadata.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
/**
 * Create a NIP-26 delegation tag (including the signature).
 * See also validate_delegation_tag().
 *
 * <https://github.com/nostr-protocol/nips/blob/master/26.md>
 */
public func createDelegationTag(delegatorKeys: Keys, delegateePubkey: PublicKey, conditions: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_create_delegation_tag(
        FfiConverterTypeKeys.lower(delegatorKeys),
        FfiConverterTypePublicKey.lower(delegateePubkey),
        FfiConverterString.lower(conditions),$0
    )
})
}
public func decryptReceivedPrivateZapMessage(secretKey: SecretKey, privateZap: Event)throws  -> Event {
    return try  FfiConverterTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_decrypt_received_private_zap_message(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypeEvent.lower(privateZap),$0
    )
})
}
public func decryptSentPrivateZapMessage(secretKey: SecretKey, publicKey: PublicKey, privateZap: Event)throws  -> Event {
    return try  FfiConverterTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_decrypt_sent_private_zap_message(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterTypeEvent.lower(privateZap),$0
    )
})
}
/**
 * Extracts the relay info (url, optional read/write flag) from the event
 */
public func extractRelayList(event: Event) -> [String: RelayMetadata?] {
    return try!  FfiConverterDictionaryStringOptionTypeRelayMetadata.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_func_extract_relay_list(
        FfiConverterTypeEvent.lower(event),$0
    )
})
}
/**
 * Generate shared key
 *
 * **Important: use of a strong cryptographic hash function may be critical to security! Do NOT use
 * unless you understand cryptographical implications.**
 */
public func generateSharedKey(secretKey: SecretKey, publicKey: PublicKey) -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_func_generate_shared_key(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypePublicKey.lower(publicKey),$0
    )
})
}
/**
 * Gets the number of leading zero bits. Result is between 0 and 255.
 */
public func getLeadingZeroBits(bytes: Data) -> UInt8 {
    return try!  FfiConverterUInt8.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_func_get_leading_zero_bits(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func getNip05Profile(nip05: String, proxy: String? = nil)async throws  -> Nip19Profile {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_ffi_fn_func_get_nip05_profile(FfiConverterString.lower(nip05),FfiConverterOptionString.lower(proxy)
                )
            },
            pollFunc: ffi_nostr_ffi_rust_future_poll_pointer,
            completeFunc: ffi_nostr_ffi_rust_future_complete_pointer,
            freeFunc: ffi_nostr_ffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeNip19Profile.lift,
            errorHandler: FfiConverterTypeNostrError.lift
        )
}
/**
 * Returns all possible ID prefixes (hex) that have the specified number of leading zero bits.
 *
 * Possible values: 0-255
 */
public func getPrefixesForDifficulty(leadingZeroBits: UInt8) -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_func_get_prefixes_for_difficulty(
        FfiConverterUInt8.lower(leadingZeroBits),$0
    )
})
}
/**
 * Build Gift Wrap
 *
 * <https://github.com/nostr-protocol/nips/blob/master/59.md>
 */
public func giftWrap(senderKeys: Keys, receiverPubkey: PublicKey, rumor: UnsignedEvent, expiration: Timestamp?)throws  -> Event {
    return try  FfiConverterTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_gift_wrap(
        FfiConverterTypeKeys.lower(senderKeys),
        FfiConverterTypePublicKey.lower(receiverPubkey),
        FfiConverterTypeUnsignedEvent.lower(rumor),
        FfiConverterOptionTypeTimestamp.lower(expiration),$0
    )
})
}
/**
 * Build Gift Wrap from Seal
 *
 * <https://github.com/nostr-protocol/nips/blob/master/59.md>
 */
public func giftWrapFromSeal(receiver: PublicKey, seal: Event, expiration: Timestamp?)throws  -> Event {
    return try  FfiConverterTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_gift_wrap_from_seal(
        FfiConverterTypePublicKey.lower(receiver),
        FfiConverterTypeEvent.lower(seal),
        FfiConverterOptionTypeTimestamp.lower(expiration),$0
    )
})
}
public func nip04Decrypt(secretKey: SecretKey, publicKey: PublicKey, encryptedContent: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_nip04_decrypt(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(encryptedContent),$0
    )
})
}
public func nip04Encrypt(secretKey: SecretKey, publicKey: PublicKey, content: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_nip04_encrypt(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(content),$0
    )
})
}
public func nip44Decrypt(secretKey: SecretKey, publicKey: PublicKey, payload: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_nip44_decrypt(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(payload),$0
    )
})
}
public func nip44Encrypt(secretKey: SecretKey, publicKey: PublicKey, content: String, version: Nip44Version)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_nip44_encrypt(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(content),
        FfiConverterTypeNip44Version.lower(version),$0
    )
})
}
public func nip57AnonymousZapRequest(data: ZapRequestData)throws  -> Event {
    return try  FfiConverterTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_nip57_anonymous_zap_request(
        FfiConverterTypeZapRequestData.lower(data),$0
    )
})
}
public func nip57PrivateZapRequest(data: ZapRequestData, keys: Keys)throws  -> Event {
    return try  FfiConverterTypeEvent.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_nip57_private_zap_request(
        FfiConverterTypeZapRequestData.lower(data),
        FfiConverterTypeKeys.lower(keys),$0
    )
})
}
/**
 * Sign delegation.
 * See `create_delegation_tag` for more complete functionality.
 *
 * <https://github.com/nostr-protocol/nips/blob/master/26.md>
 */
public func signDelegation(delegatorKeys: Keys, delegateePk: PublicKey, conditions: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_sign_delegation(
        FfiConverterTypeKeys.lower(delegatorKeys),
        FfiConverterTypePublicKey.lower(delegateePk),
        FfiConverterString.lower(conditions),$0
    )
})
}
/**
 * Validate a NIP-26 delegation tag, check signature and conditions.
 *
 * <https://github.com/nostr-protocol/nips/blob/master/26.md>
 */
public func validateDelegationTag(delegationTag: String, delegateePubkey: PublicKey, eventKind: Kind, createdAt: UInt64) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_nostr_ffi_fn_func_validate_delegation_tag(
        FfiConverterString.lower(delegationTag),
        FfiConverterTypePublicKey.lower(delegateePubkey),
        FfiConverterTypeKind.lower(eventKind),
        FfiConverterUInt64.lower(createdAt),$0
    )
})
}
/**
 * Verify delegation signature
 *
 * <https://github.com/nostr-protocol/nips/blob/master/26.md>
 */
public func verifyDelegationSignature(delegatorPublicKey: PublicKey, delegateePublicKey: PublicKey, conditions: String, signature: String)throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_verify_delegation_signature(
        FfiConverterTypePublicKey.lower(delegatorPublicKey),
        FfiConverterTypePublicKey.lower(delegateePublicKey),
        FfiConverterString.lower(conditions),
        FfiConverterString.lower(signature),$0
    )
})
}
public func verifyNip05(publicKey: PublicKey, nip05: String, proxy: String? = nil)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_nostr_ffi_fn_func_verify_nip05(FfiConverterTypePublicKey.lower(publicKey),FfiConverterString.lower(nip05),FfiConverterOptionString.lower(proxy)
                )
            },
            pollFunc: ffi_nostr_ffi_rust_future_poll_i8,
            completeFunc: ffi_nostr_ffi_rust_future_complete_i8,
            freeFunc: ffi_nostr_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNostrError.lift
        )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_nostr_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_create_delegation_tag() != 39643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_decrypt_received_private_zap_message() != 31929) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_decrypt_sent_private_zap_message() != 57065) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_extract_relay_list() != 51894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_generate_shared_key() != 24701) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_get_leading_zero_bits() != 55983) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_get_nip05_profile() != 2525) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_get_prefixes_for_difficulty() != 14470) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_gift_wrap() != 12272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_gift_wrap_from_seal() != 39743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_nip04_decrypt() != 38491) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_nip04_encrypt() != 24648) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_nip44_decrypt() != 37647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_nip44_encrypt() != 2053) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_nip57_anonymous_zap_request() != 51353) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_nip57_private_zap_request() != 31681) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_sign_delegation() != 28721) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_validate_delegation_tag() != 56480) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_verify_delegation_signature() != 1929) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_verify_nip05() != 9101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_clientmessage_as_enum() != 33173) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_clientmessage_as_json() != 25711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_contact_alias() != 19227) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_contact_public_key() != 12349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_contact_relay_url() != 44747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_coordinate_identifier() != 48595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_coordinate_kind() != 52111) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_coordinate_public_key() != 23569) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_coordinate_relays() != 12945) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_coordinate_to_bech32() != 29387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_coordinate_to_nostr_uri() != 54439) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_encryptedsecretkey_key_security() != 20932) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_encryptedsecretkey_to_bech32() != 47366) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_encryptedsecretkey_to_secret_key() != 45470) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_encryptedsecretkey_version() != 27626) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_as_json() != 6443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_author() != 55205) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_content() != 3434) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_coordinates() != 21059) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_created_at() != 20644) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_event_ids() != 26038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_expiration() != 26242) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_id() != 64311) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_identifier() != 23430) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_is_ephemeral() != 21349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_is_expired() != 57175) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_is_job_request() != 26053) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_is_job_result() != 54684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_is_parameterized_replaceable() != 17253) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_is_regular() != 8941) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_is_replaceable() != 57468) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_kind() != 15262) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_public_keys() != 60861) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_signature() != 11666) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_tags() != 47189) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_verify() != 11448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_verify_id() != 58200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_verify_signature() != 63925) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventbuilder_add_tags() != 37368) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventbuilder_custom_created_at() != 25828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventbuilder_to_event() != 27477) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventbuilder_to_pow_event() != 361) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_event() != 12334) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_pow_event() != 38142) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventid_as_bytes() != 42102) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventid_to_bech32() != 64584) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventid_to_hex() != 61729) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventid_to_nostr_uri() != 46695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filemetadata_aes_256_gcm() != 47596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filemetadata_blurhash() != 22155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filemetadata_dimensions() != 43810) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filemetadata_magnet() != 19539) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filemetadata_size() != 25033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_as_json() != 2504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_as_record() != 10817) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_author() != 2123) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_authors() != 56938) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_custom_tag() != 53153) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_event() != 9878) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_events() != 58098) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_hashtag() != 37311) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_hashtags() != 18297) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_id() != 44226) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_identifier() != 49862) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_identifiers() != 51204) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_ids() != 8911) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_is_empty() != 26481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_kind() != 56023) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_kinds() != 58074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_limit() != 10602) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_match_event() != 9337) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_pubkey() != 49251) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_pubkeys() != 54202) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_reference() != 5468) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_references() != 37241) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_authors() != 19914) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_custom_tag() != 9906) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_events() != 12945) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_hashtags() != 14229) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_identifiers() != 54851) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_ids() != 895) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_kinds() != 46527) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_limit() != 49122) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_pubkeys() != 47794) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_references() != 318) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_search() != 51973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_since() != 41179) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_until() != 8584) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_search() != 43387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_since() != 59944) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_until() != 519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_imagedimensions_height() != 33735) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_imagedimensions_width() != 1901) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_keys_public_key() != 8351) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_keys_secret_key() != 10917) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_keys_sign_schnorr() != 38932) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_kind_as_enum() != 37013) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_kind_as_u16() != 42491) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_kind_as_u64() != 51642) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_as_json() != 49741) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_as_record() != 14817) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_about() != 6408) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_banner() != 8981) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_custom_field() != 46605) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_display_name() != 17403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_lud06() != 2507) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_lud16() != 58234) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_name() != 23420) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_nip05() != 23082) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_picture() != 40475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_website() != 33949) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_about() != 51614) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_banner() != 24250) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_custom_field() != 55088) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_display_name() != 39071) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_lud06() != 14055) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_lud16() != 6913) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_name() != 17602) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_nip05() != 48621) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_picture() != 55880) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_website() != 21361) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19_as_enum() != 16291) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19event_author() != 18411) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19event_event_id() != 2218) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19event_relays() != 18458) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19event_to_bech32() != 62414) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19event_to_nostr_uri() != 17113) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19profile_public_key() != 57418) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19profile_relays() != 40076) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19profile_to_bech32() != 6768) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19profile_to_nostr_uri() != 7355) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip21_as_enum() != 62859) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip21_to_nostr_uri() != 50917) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_as_json() != 46001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_description() != 20591) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_icons() != 35460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrconnectmetadata_url() != 38230) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrconnecturi_as_string() != 50623) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrlibrary_git_hash_version() != 11110) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_lud16() != 46259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_public_key() != 42711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_relay_url() != 45352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_secret() != 54573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_publickey_to_bech32() != 6908) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_publickey_to_hex() != 28417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_publickey_to_nostr_uri() != 23126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_rawevent_as_json() != 12712) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_rawevent_as_record() != 15974) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_contact() != 46735) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_description() != 23135) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_fees() != 55926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_icon() != 32188) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_language_tags() != 31609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_limitation() != 40270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_name() != 18381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_payments_url() != 40933) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_posting_policy() != 8196) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_pubkey() != 58101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_relay_countries() != 36520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_retention() != 49899) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_software() != 10815) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_supported_nips() != 15217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_tags() != 12950) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_version() != 8680) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relaymessage_as_enum() != 56517) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relaymessage_as_json() != 2111) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_request_method() != 18547) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_request_params() != 61907) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_secretkey_encrypt() != 47103) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_secretkey_to_bech32() != 37711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_secretkey_to_hex() != 26766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_shippingmethod_get_shipping_cost() != 1960) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_shippingmethod_name() != 29) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_shippingmethod_regions() != 17040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_singlelettertag_is_lowercase() != 14686) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_singlelettertag_is_uppercase() != 50218) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_stalldata_as_json() != 14021) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_stalldata_as_record() != 56802) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_stalldata_currency() != 47328) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_stalldata_description() != 56576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_stalldata_id() != 41895) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_stalldata_name() != 14568) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_stalldata_shipping() != 57313) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_tag_as_standardized() != 40509) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_tag_as_vec() != 32049) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_tag_content() != 16124) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_tag_is_reply() != 40577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_tag_is_root() != 32828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_tag_kind() != 61495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_tag_single_letter_tag() != 32689) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_timestamp_as_secs() != 12186) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_timestamp_to_human_datetime() != 33432) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_add_signature() != 65391) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_as_json() != 44697) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_author() != 15518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_content() != 59369) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_created_at() != 52665) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_id() != 59439) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_kind() != 46769) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_sign() != 52286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_tags() != 19159) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unwrappedgift_rumor() != 18174) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unwrappedgift_sender() != 36759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_zaprequestdata_amount() != 57086) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_zaprequestdata_event_id() != 38377) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_zaprequestdata_lnurl() != 14270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_zaprequestdata_message() != 22547) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_clientmessage_auth() != 52193) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_clientmessage_close() != 12730) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_clientmessage_count() != 17443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_clientmessage_event() != 34212) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_clientmessage_from_enum() != 24237) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_clientmessage_from_json() != 23906) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_clientmessage_req() != 29877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_contact_new() != 40535) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_coordinate_from_bech32() != 20802) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_coordinate_from_nostr_uri() != 29111) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_coordinate_new() != 12320) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_coordinate_parse() != 24703) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_encryptedsecretkey_from_bech32() != 48746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_encryptedsecretkey_new() != 63240) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_event_from_json() != 25979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_articles_curation_sets() != 16928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_auth() != 34135) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_award_badge() != 36328) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_blocked_relays() != 35361) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_bookmarks() != 19909) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_bookmarks_sets() != 9871) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_channel() != 21301) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_channel_metadata() != 26640) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_channel_msg() != 46295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_communities() != 13346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_contact_list() != 9790) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_define_badge() != 2433) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_delete() != 13098) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_emoji_sets() != 12072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_emojis() != 32679) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_encrypted_direct_msg() != 30966) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_file_metadata() != 5575) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_follow_sets() != 1429) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_hide_channel_msg() != 22099) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_http_auth() != 49716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_interests() != 25709) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_feedback() != 60551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_request() != 14465) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_result() != 58268) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_label() != 47535) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event() != 34212) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event_msg() != 9139) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_long_form_text_note() != 18893) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_metadata() != 35356) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_mute_channel_user() != 35702) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_mute_list() != 13594) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_new() != 11099) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_nostr_connect() != 41623) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_pinned_notes() != 22014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_private_msg_rumor() != 62698) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_product_data() != 54242) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_profile_badges() != 824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_public_chats() != 47562) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_public_zap_request() != 43070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_reaction() != 45033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_reaction_extended() != 18337) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_relay_list() != 11684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_relay_sets() != 62101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_report() != 49328) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_repost() != 58942) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_search_relays() != 35576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_stall_data() != 52935) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_text_note() != 21682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_text_note_reply() != 49537) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_videos_curation_sets() != 55053) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_zap_receipt() != 9732) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventid_from_bech32() != 58481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventid_from_bytes() != 26070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventid_from_hex() != 34860) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventid_from_nostr_uri() != 47915) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventid_new() != 31406) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventid_parse() != 31805) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_filemetadata_new() != 32554) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_filter_from_json() != 8004) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_filter_from_record() != 20357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_filter_new() != 63951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_imagedimensions_new() != 24393) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_keys_from_mnemonic() != 2337) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_keys_from_mnemonic_advanced() != 46078) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_keys_from_mnemonic_with_account() != 844) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_keys_from_public_key() != 57552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_keys_generate() != 34326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_keys_new() != 32326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_keys_parse() != 16239) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_keys_vanity() != 20910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_kind_from_enum() != 24008) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_kind_new() != 42942) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_metadata_from_json() != 45694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_metadata_from_record() != 39316) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_metadata_new() != 37576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip19_from_bech32() != 25248) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip19event_from_bech32() != 50101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip19event_from_nostr_uri() != 60241) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip19event_new() != 29588) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip19profile_from_bech32() != 30442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip19profile_from_nostr_uri() != 33427) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip19profile_new() != 43655) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip21_parse() != 30203) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nostrconnectmetadata_new() != 37150) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nostrconnecturi_parse() != 49790) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nostrlibrary_new() != 54546) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nostrwalletconnecturi_new() != 64158) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nostrwalletconnecturi_parse() != 62225) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_publickey_from_bech32() != 16497) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_publickey_from_bytes() != 15604) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_publickey_from_hex() != 21577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_publickey_from_nostr_uri() != 21697) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_publickey_parse() != 1285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_rawevent_from_json() != 26027) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_rawevent_from_record() != 51955) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_get() != 53581) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_new() != 46265) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_relaymessage_auth() != 29124) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_relaymessage_closed() != 55009) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_relaymessage_count() != 42279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_relaymessage_eose() != 10440) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_relaymessage_event() != 24541) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_relaymessage_from_enum() != 62038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_relaymessage_from_json() != 21031) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_relaymessage_notice() != 34446) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_relaymessage_ok() != 17767) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_request_new() != 59137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_request_parse() != 35736) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_secretkey_from_bech32() != 57257) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_secretkey_from_bytes() != 61333) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_secretkey_from_hex() != 11652) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_secretkey_generate() != 51859) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_secretkey_parse() != 23943) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_shippingmethod_new() != 65060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_singlelettertag_lowercase() != 59471) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_singlelettertag_uppercase() != 23850) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_stalldata_from_json() != 22214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_stalldata_from_record() != 38214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_stalldata_new() != 34499) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_coordinate() != 27758) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_custom() != 40165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_event() != 49250) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_event_report() != 39217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_expiration() != 65320) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_from_standardized() != 42506) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_hashtag() != 42443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_identifier() != 38639) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_parse() != 14656) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_pow() != 65247) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_public_key() != 422) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_public_key_report() != 36694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_relay_metadata() != 53981) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_timestamp_from_secs() != 46579) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_timestamp_now() != 63297) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_unsignedevent_from_json() != 39161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_unwrappedgift_from_gift_wrap() != 32822) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_zaprequestdata_new() != 55311) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all